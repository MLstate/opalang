/*
    Copyright Â© 2011 MLstate

    This file is part of OPA.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
/*
 * Author    : Adam Koprowski <adam.koprowski@mlstate.com>
 **/

import stdlib.apis.worldweather
import stdlib.web.client

/**
 * A widget displaying a weather forecast.
 *
 * @author Adam Koprowski, 2010
 * @category widget
 * @destination public
 */

/**
 * {1 About this module}
 *
 * This widget can be used to present a weather forecast for a given location.
 *
 * {1 Where should I start?}
 *
 * Take a look at the {!html} function, which constructs a widget given its
 * configuration, location for the weather forecast and an identifier to be
 * used as a prefix for all DOM ids created by the widget.
 *
 * {!weather_widget_css} provides a basic CSS for rendering the widget. At the
 * moment the HTML generated by this widget is not customizable, but by
 * customizing CSS it is possible to adapt the look of the widget.
 */

/**
 * Configuration of the widget. For now it only includes the configuration
 * of the World Weather API, see {!WorldWeather.config} for details.
**/
type WeatherWidget.config = {
  world_weather_config : WorldWeather.config
}

CWeather = {{

  @private
  @server
  s_onmessage(_, msg) =
    match msg with
    | {weather_for=location; ~config; reply_to=channel} ->
        callback(weather) = send(channel, {weather_response = weather; query = location}:{...})
        do WorldWeather.get_weather(location, config, callback)
        {unchanged}

  @private
  @server
  s_channel = Session.make(void, s_onmessage)

  @private
  date_printer = Date.generate_printer("%a, %E of %b")

  @private
  render_weather(weather_response, query) =
    now = Date.round_to_day(Date.now())
    draw_date(d, acc) =
      dur = Duration.between(now, Date.round_to_day(d.date))
      dur_str = Duration.to_string(dur)
      date_str =
        match String.trim(dur_str) with // FIXME do it differently
        | "now" -> "today"
        | "tomorrow" -> "tomorrow"
        | _ -> Date.to_formatted_string(date_printer, d.date)
      <><td>{date_str}</>{acc}</>    draw_temp(d, acc) = <><td>{d.tempMin}&deg;C / {d.tempMax}&deg;C</>{acc}</>
    draw_icon(d, acc) = <><td><img src={d.iconUrl} /></>{acc}</>
    draw_desc(d, acc) = <><td>{d.desc}</>{acc}</>
    content =
      match weather_response with
      | {none} ->
          <span class=error>
            Unable to get weather report for <emph>&laquo;{query}&raquo;</emph>.
            Please check the spelling.
          </span>
      | ~{some=~{location weather_data}} ->
          present = List.fold(_, weather_data, <></>)
          <>
            <table cellpadding=0 cellspacing=0>
              <tr>
                <th colspan={List.length(weather_data)}>
                  {location}
                </th>
              </tr>
              <tr class=date>
                {present(draw_date)}
              </>
              <tr class=temp>
                {present(draw_temp)}
              </>
              <tr class=icon>
                {present(draw_icon)}
              </>
              <tr class=desc>
                {present(draw_desc)}
              </>
            </table>
          </>
    res =
      <div class="weatherWidget">
        {content}
      </div>
    res

  @private
  show_response(id, content) =
    Dom.transform([#{id} <- content])

  @private
  show_weather(config, id, location, c_channel, _) =
    do show_response(id, <>Fetching weather, please wait...</>)
    Session.send(s_channel, {weather_for = location; ~config; reply_to = c_channel})

  @private
  c_onmessage(id, msg) =
    match msg with
    | ~{weather_response query} ->
        xhtml = render_weather(weather_response, query)
        do show_response(id, xhtml)
        {unchanged}

  /**
   * Given an API key to World Weather Online service, it constructs a default
   * configuration of the widget.
  **/
  default_config(api : string) : WeatherWidget.config =
    { world_weather_config = WorldWeather.default_config(api) }

  /**
   * This function creates an XHTML snippet of the widget.
   *
   * @param config configuration of the widget (see {!WeatherWidget.config})
   * @param id a prefix for all DOM identifiers created by this widget
   * @param location a location for the forecast (in "City, Country" format,
   *        with country optional).
   * @return XHTML snippet with the weather for the given location
  **/
  html(config : WeatherWidget.config, id : string, location : string) : xhtml =
    c_channel = Session.make(id, c_onmessage)
    xhtml = <div id=#{id} onready={show_weather(config.world_weather_config, id, location, c_channel, _)} />
    xhtml
}}

/**
 * A basic CSS for the widget
**/
weather_widget_css = css
 div.weatherWidget {
   margin: 20px;
 }
 .weatherWidget table {
   border: 1px solid black;
   background: #F8FFFF;
 }
 .weatherWidget tr.date td {
   background: #CEF;
   border-top: 1px solid black;
 }
 .weatherWidget th {
   background: #A6C4F4;
   padding: 5px;
 }
 .weatherWidget td {
   width: 120px;
   height: 100%;
   text-align: center;
   padding: 5px;
   border-left: 1px solid black;
 }
 .weatherWidget td:first-child {
   border-left: none;
 }
 .weatherWidget .error {
   border: 1px solid black;
   padding: 5px;
   background: #FEE;
 }
 .weatherWidget emph {
   font-weight: bold;
 }
