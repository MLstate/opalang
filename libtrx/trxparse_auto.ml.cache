open Base
module Make
(R_ : Reader.S) = struct
let _grammar_rules = [ ("Trxparse_strict_GElem", None) ; ("Trxparse_rule_annots", Some(("rule annotations"))) ; ("Trxparse_optionType", Some(("TRX option name"))) ; ("Trxparse_mlvar", Some(("element name"))) ; ("Trxparse_mlcomment", None) ; ("Trxparse_mlCOMMENTSTOP", None) ; ("Trxparse_mlCOMMENTSTART", None) ; ("Trxparse_memo_opt", Some(("memoization annotation"))) ; ("Trxparse_maybe_GElems_no_sp_eof", None) ; ("Trxparse_maybe_GElems_no_sp", None) ; ("Trxparse_maybe_GElem_no_sp", None) ; ("Trxparse_item_list", None) ; ("Trxparse_construct_name_secondary", None) ; ("Trxparse_construct_name_primary", None) ; ("Trxparse_construct_name_opt", Some(("optional rule name"))) ; ("Trxparse_Type", None) ; ("Trxparse_TILDE", None) ; ("Trxparse_SuffixElement", None) ; ("Trxparse_Suffix", Some(("element's suffix"))) ; ("Trxparse_StoppableCode", None) ; ("Trxparse_Spacing", Some(("spacing"))) ; ("Trxparse_Space", None) ; ("Trxparse_Sequence", Some(("a sequence of parsing expressions"))) ; ("Trxparse_STAR", None) ; ("Trxparse_SLASH", None) ; ("Trxparse_SEMI", None) ; ("Trxparse_Range", None) ; ("Trxparse_RIGHTARROW", None) ; ("Trxparse_RBRACE", None) ; ("Trxparse_QUESTION", None) ; ("Trxparse_Primary", Some(("parsing element"))) ; ("Trxparse_PrefixElement", None) ; ("Trxparse_Prefix", Some(("element's prefix"))) ; ("Trxparse_PLUS", None) ; ("Trxparse_Option", Some(("TRX option"))) ; ("Trxparse_OPEN", None) ; ("Trxparse_Names", None) ; ("Trxparse_Name", None) ; ("Trxparse_NOT", None) ; ("Trxparse_Module", None) ; ("Trxparse_MARK", None) ; ("Trxparse_Literal", Some(("literal"))) ; ("Trxparse_LET", None) ; ("Trxparse_LEFTARROW", None) ; ("Trxparse_LBRACE", None) ; ("Trxparse_KEEP_CACHE", None) ; ("Trxparse_IncludeRead", Some(("include directive"))) ; ("Trxparse_Identifier", Some(("identifier"))) ; ("Trxparse_HeaderCode", None) ; ("Trxparse_Grammar", Some(("TRX grammar"))) ; ("Trxparse_GElems", Some(("list of TRX elements"))) ; ("Trxparse_GElem_no_sp", None) ; ("Trxparse_GElem", Some(("TRX element"))) ; ("Trxparse_Function", Some(("TRX function"))) ; ("Trxparse_Filename", Some(("file name"))) ; ("Trxparse_Extra", Some(("extra directive"))) ; ("Trxparse_Exprs", Some(("list of expressions"))) ; ("Trxparse_Expression", Some(("rule body"))) ; ("Trxparse_EQUAL", None) ; ("Trxparse_EOL", Some(("end of line"))) ; ("Trxparse_EOF", None) ; ("Trxparse_ENd", None) ; ("Trxparse_END", None) ; ("Trxparse_Definition", Some(("TRX rule"))) ; ("Trxparse_DefaultCodeNoStop", None) ; ("Trxparse_DefaultCode", None) ; ("Trxparse_DefExpr", None) ; ("Trxparse_DOT", None) ; ("Trxparse_DOLLAR", None) ; ("Trxparse_DEBUG", None) ; ("Trxparse_Comment", Some(("a comment"))) ; ("Trxparse_CodeRange", None) ; ("Trxparse_Code", Some(("rule production"))) ; ("Trxparse_Class", Some(("class of symbols"))) ; ("Trxparse_Char", None) ; ("Trxparse_COMMA", None) ; ("Trxparse_COLON", None) ; ("Trxparse_CLOSE", None) ; ("Trxparse_BackId", None) ; ("Trxparse_BEGIn", None) ; ("Trxparse_BEGIN", None) ; ("Trxparse_AND", None) ]
let parse_with f_noerr f_err _text _start = let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (f_noerr (_text) (_start)) with
Some ( ( pos, res ) ) -> (pos, res)
| None -> (match (f_err (_text) (_start)) with
Trx_runtime.Ok ( ( ( _, _ ), _ ) ) -> (assert false)
| Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.gen_syntax_error (((FilePos.get_pos_no_cache) ((_get_sub (0) (_len))))) (err))))
let memo_Trxparse_AND = ((Hashtbl.create) (128))
let memo_Trxparse_AND_err = ((Hashtbl.create) (128))
let memo_Trxparse_CLOSE = ((Hashtbl.create) (128))
let memo_Trxparse_CLOSE_err = ((Hashtbl.create) (128))
let memo_Trxparse_COMMA = ((Hashtbl.create) (128))
let memo_Trxparse_COMMA_err = ((Hashtbl.create) (128))
let memo_Trxparse_Char = ((Hashtbl.create) (128))
let memo_Trxparse_Char_err = ((Hashtbl.create) (128))
let memo_Trxparse_Class = ((Hashtbl.create) (128))
let memo_Trxparse_Class_err = ((Hashtbl.create) (128))
let memo_Trxparse_Code = ((Hashtbl.create) (128))
let memo_Trxparse_Code_err = ((Hashtbl.create) (128))
let memo_Trxparse_CodeRange = ((Hashtbl.create) (128))
let memo_Trxparse_CodeRange_err = ((Hashtbl.create) (128))
let memo_Trxparse_Comment = ((Hashtbl.create) (128))
let memo_Trxparse_Comment_err = ((Hashtbl.create) (128))
let memo_Trxparse_DOLLAR = ((Hashtbl.create) (128))
let memo_Trxparse_DOLLAR_err = ((Hashtbl.create) (128))
let memo_Trxparse_DOT = ((Hashtbl.create) (128))
let memo_Trxparse_DOT_err = ((Hashtbl.create) (128))
let memo_Trxparse_DefExpr = ((Hashtbl.create) (128))
let memo_Trxparse_DefExpr_err = ((Hashtbl.create) (128))
let memo_Trxparse_DefaultCode = ((Hashtbl.create) (128))
let memo_Trxparse_DefaultCode_err = ((Hashtbl.create) (128))
let memo_Trxparse_DefaultCodeNoStop = ((Hashtbl.create) (128))
let memo_Trxparse_DefaultCodeNoStop_err = ((Hashtbl.create) (128))
let memo_Trxparse_Definition = ((Hashtbl.create) (128))
let memo_Trxparse_Definition_err = ((Hashtbl.create) (128))
let memo_Trxparse_END = ((Hashtbl.create) (128))
let memo_Trxparse_END_err = ((Hashtbl.create) (128))
let memo_Trxparse_ENd = ((Hashtbl.create) (128))
let memo_Trxparse_ENd_err = ((Hashtbl.create) (128))
let memo_Trxparse_EOL = ((Hashtbl.create) (128))
let memo_Trxparse_EOL_err = ((Hashtbl.create) (128))
let memo_Trxparse_EQUAL = ((Hashtbl.create) (128))
let memo_Trxparse_EQUAL_err = ((Hashtbl.create) (128))
let memo_Trxparse_Expression = ((Hashtbl.create) (128))
let memo_Trxparse_Expression_err = ((Hashtbl.create) (128))
let memo_Trxparse_Exprs = ((Hashtbl.create) (128))
let memo_Trxparse_Exprs_err = ((Hashtbl.create) (128))
let memo_Trxparse_Extra = ((Hashtbl.create) (128))
let memo_Trxparse_Extra_err = ((Hashtbl.create) (128))
let memo_Trxparse_Filename = ((Hashtbl.create) (128))
let memo_Trxparse_Filename_err = ((Hashtbl.create) (128))
let memo_Trxparse_Function = ((Hashtbl.create) (128))
let memo_Trxparse_Function_err = ((Hashtbl.create) (128))
let memo_Trxparse_GElems = ((Hashtbl.create) (128))
let memo_Trxparse_GElems_err = ((Hashtbl.create) (128))
let memo_Trxparse_Grammar = ((Hashtbl.create) (128))
let memo_Trxparse_Grammar_err = ((Hashtbl.create) (128))
let memo_Trxparse_HeaderCode = ((Hashtbl.create) (128))
let memo_Trxparse_HeaderCode_err = ((Hashtbl.create) (128))
let memo_Trxparse_Identifier = ((Hashtbl.create) (128))
let memo_Trxparse_Identifier_err = ((Hashtbl.create) (128))
let memo_Trxparse_IncludeRead = ((Hashtbl.create) (128))
let memo_Trxparse_IncludeRead_err = ((Hashtbl.create) (128))
let memo_Trxparse_KEEP_CACHE = ((Hashtbl.create) (128))
let memo_Trxparse_KEEP_CACHE_err = ((Hashtbl.create) (128))
let memo_Trxparse_LBRACE = ((Hashtbl.create) (128))
let memo_Trxparse_LBRACE_err = ((Hashtbl.create) (128))
let memo_Trxparse_LEFTARROW = ((Hashtbl.create) (128))
let memo_Trxparse_LEFTARROW_err = ((Hashtbl.create) (128))
let memo_Trxparse_LET = ((Hashtbl.create) (128))
let memo_Trxparse_LET_err = ((Hashtbl.create) (128))
let memo_Trxparse_Literal = ((Hashtbl.create) (128))
let memo_Trxparse_Literal_err = ((Hashtbl.create) (128))
let memo_Trxparse_Module = ((Hashtbl.create) (128))
let memo_Trxparse_Module_err = ((Hashtbl.create) (128))
let memo_Trxparse_NOT = ((Hashtbl.create) (128))
let memo_Trxparse_NOT_err = ((Hashtbl.create) (128))
let memo_Trxparse_Name = ((Hashtbl.create) (128))
let memo_Trxparse_Name_err = ((Hashtbl.create) (128))
let memo_Trxparse_Names = ((Hashtbl.create) (128))
let memo_Trxparse_Names_err = ((Hashtbl.create) (128))
let memo_Trxparse_OPEN = ((Hashtbl.create) (128))
let memo_Trxparse_OPEN_err = ((Hashtbl.create) (128))
let memo_Trxparse_Option = ((Hashtbl.create) (128))
let memo_Trxparse_Option_err = ((Hashtbl.create) (128))
let memo_Trxparse_PLUS = ((Hashtbl.create) (128))
let memo_Trxparse_PLUS_err = ((Hashtbl.create) (128))
let memo_Trxparse_Prefix = ((Hashtbl.create) (128))
let memo_Trxparse_Prefix_err = ((Hashtbl.create) (128))
let memo_Trxparse_PrefixElement = ((Hashtbl.create) (128))
let memo_Trxparse_PrefixElement_err = ((Hashtbl.create) (128))
let memo_Trxparse_Primary = ((Hashtbl.create) (128))
let memo_Trxparse_Primary_err = ((Hashtbl.create) (128))
let memo_Trxparse_QUESTION = ((Hashtbl.create) (128))
let memo_Trxparse_QUESTION_err = ((Hashtbl.create) (128))
let memo_Trxparse_RBRACE = ((Hashtbl.create) (128))
let memo_Trxparse_RBRACE_err = ((Hashtbl.create) (128))
let memo_Trxparse_Range = ((Hashtbl.create) (128))
let memo_Trxparse_Range_err = ((Hashtbl.create) (128))
let memo_Trxparse_SEMI = ((Hashtbl.create) (128))
let memo_Trxparse_SEMI_err = ((Hashtbl.create) (128))
let memo_Trxparse_SLASH = ((Hashtbl.create) (128))
let memo_Trxparse_SLASH_err = ((Hashtbl.create) (128))
let memo_Trxparse_STAR = ((Hashtbl.create) (128))
let memo_Trxparse_STAR_err = ((Hashtbl.create) (128))
let memo_Trxparse_Sequence = ((Hashtbl.create) (128))
let memo_Trxparse_Sequence_err = ((Hashtbl.create) (128))
let memo_Trxparse_Space = ((Hashtbl.create) (128))
let memo_Trxparse_Space_err = ((Hashtbl.create) (128))
let memo_Trxparse_Spacing = ((Hashtbl.create) (128))
let memo_Trxparse_Spacing_err = ((Hashtbl.create) (128))
let memo_Trxparse_StoppableCode = ((Hashtbl.create) (128))
let memo_Trxparse_StoppableCode_err = ((Hashtbl.create) (128))
let memo_Trxparse_Suffix = ((Hashtbl.create) (128))
let memo_Trxparse_Suffix_err = ((Hashtbl.create) (128))
let memo_Trxparse_SuffixElement = ((Hashtbl.create) (128))
let memo_Trxparse_SuffixElement_err = ((Hashtbl.create) (128))
let memo_Trxparse_TILDE = ((Hashtbl.create) (128))
let memo_Trxparse_TILDE_err = ((Hashtbl.create) (128))
let memo_Trxparse_Type = ((Hashtbl.create) (128))
let memo_Trxparse_Type_err = ((Hashtbl.create) (128))
let memo_Trxparse_construct_name_opt = ((Hashtbl.create) (128))
let memo_Trxparse_construct_name_opt_err = ((Hashtbl.create) (128))
let memo_Trxparse_construct_name_primary = ((Hashtbl.create) (128))
let memo_Trxparse_construct_name_primary_err = ((Hashtbl.create) (128))
let memo_Trxparse_construct_name_secondary = ((Hashtbl.create) (128))
let memo_Trxparse_construct_name_secondary_err = ((Hashtbl.create) (128))
let memo_Trxparse_item_list = ((Hashtbl.create) (128))
let memo_Trxparse_item_list_err = ((Hashtbl.create) (128))
let memo_Trxparse_memo_opt = ((Hashtbl.create) (128))
let memo_Trxparse_memo_opt_err = ((Hashtbl.create) (128))
let memo_Trxparse_mlCOMMENTSTART = ((Hashtbl.create) (128))
let memo_Trxparse_mlCOMMENTSTART_err = ((Hashtbl.create) (128))
let memo_Trxparse_mlCOMMENTSTOP = ((Hashtbl.create) (128))
let memo_Trxparse_mlCOMMENTSTOP_err = ((Hashtbl.create) (128))
let memo_Trxparse_mlcomment = ((Hashtbl.create) (128))
let memo_Trxparse_mlcomment_err = ((Hashtbl.create) (128))
let memo_Trxparse_mlvar = ((Hashtbl.create) (128))
let memo_Trxparse_mlvar_err = ((Hashtbl.create) (128))
let memo_Trxparse_optionType = ((Hashtbl.create) (128))
let memo_Trxparse_optionType_err = ((Hashtbl.create) (128))
let memo_Trxparse_rule_annots = ((Hashtbl.create) (128))
let memo_Trxparse_rule_annots_err = ((Hashtbl.create) (128))
let prepare_cache () = ((Hashtbl.clear) (memo_Trxparse_AND)) ; ((Hashtbl.clear) (memo_Trxparse_AND_err)) ; ((Hashtbl.clear) (memo_Trxparse_CLOSE)) ; ((Hashtbl.clear) (memo_Trxparse_CLOSE_err)) ; ((Hashtbl.clear) (memo_Trxparse_COMMA)) ; ((Hashtbl.clear) (memo_Trxparse_COMMA_err)) ; ((Hashtbl.clear) (memo_Trxparse_Char)) ; ((Hashtbl.clear) (memo_Trxparse_Char_err)) ; ((Hashtbl.clear) (memo_Trxparse_Class)) ; ((Hashtbl.clear) (memo_Trxparse_Class_err)) ; ((Hashtbl.clear) (memo_Trxparse_Code)) ; ((Hashtbl.clear) (memo_Trxparse_Code_err)) ; ((Hashtbl.clear) (memo_Trxparse_CodeRange)) ; ((Hashtbl.clear) (memo_Trxparse_CodeRange_err)) ; ((Hashtbl.clear) (memo_Trxparse_Comment)) ; ((Hashtbl.clear) (memo_Trxparse_Comment_err)) ; ((Hashtbl.clear) (memo_Trxparse_DOLLAR)) ; ((Hashtbl.clear) (memo_Trxparse_DOLLAR_err)) ; ((Hashtbl.clear) (memo_Trxparse_DOT)) ; ((Hashtbl.clear) (memo_Trxparse_DOT_err)) ; ((Hashtbl.clear) (memo_Trxparse_DefExpr)) ; ((Hashtbl.clear) (memo_Trxparse_DefExpr_err)) ; ((Hashtbl.clear) (memo_Trxparse_DefaultCode)) ; ((Hashtbl.clear) (memo_Trxparse_DefaultCode_err)) ; ((Hashtbl.clear) (memo_Trxparse_DefaultCodeNoStop)) ; ((Hashtbl.clear) (memo_Trxparse_DefaultCodeNoStop_err)) ; ((Hashtbl.clear) (memo_Trxparse_Definition)) ; ((Hashtbl.clear) (memo_Trxparse_Definition_err)) ; ((Hashtbl.clear) (memo_Trxparse_END)) ; ((Hashtbl.clear) (memo_Trxparse_END_err)) ; ((Hashtbl.clear) (memo_Trxparse_ENd)) ; ((Hashtbl.clear) (memo_Trxparse_ENd_err)) ; ((Hashtbl.clear) (memo_Trxparse_EOL)) ; ((Hashtbl.clear) (memo_Trxparse_EOL_err)) ; ((Hashtbl.clear) (memo_Trxparse_EQUAL)) ; ((Hashtbl.clear) (memo_Trxparse_EQUAL_err)) ; ((Hashtbl.clear) (memo_Trxparse_Expression)) ; ((Hashtbl.clear) (memo_Trxparse_Expression_err)) ; ((Hashtbl.clear) (memo_Trxparse_Exprs)) ; ((Hashtbl.clear) (memo_Trxparse_Exprs_err)) ; ((Hashtbl.clear) (memo_Trxparse_Extra)) ; ((Hashtbl.clear) (memo_Trxparse_Extra_err)) ; ((Hashtbl.clear) (memo_Trxparse_Filename)) ; ((Hashtbl.clear) (memo_Trxparse_Filename_err)) ; ((Hashtbl.clear) (memo_Trxparse_Function)) ; ((Hashtbl.clear) (memo_Trxparse_Function_err)) ; ((Hashtbl.clear) (memo_Trxparse_GElems)) ; ((Hashtbl.clear) (memo_Trxparse_GElems_err)) ; ((Hashtbl.clear) (memo_Trxparse_Grammar)) ; ((Hashtbl.clear) (memo_Trxparse_Grammar_err)) ; ((Hashtbl.clear) (memo_Trxparse_HeaderCode)) ; ((Hashtbl.clear) (memo_Trxparse_HeaderCode_err)) ; ((Hashtbl.clear) (memo_Trxparse_Identifier)) ; ((Hashtbl.clear) (memo_Trxparse_Identifier_err)) ; ((Hashtbl.clear) (memo_Trxparse_IncludeRead)) ; ((Hashtbl.clear) (memo_Trxparse_IncludeRead_err)) ; ((Hashtbl.clear) (memo_Trxparse_KEEP_CACHE)) ; ((Hashtbl.clear) (memo_Trxparse_KEEP_CACHE_err)) ; ((Hashtbl.clear) (memo_Trxparse_LBRACE)) ; ((Hashtbl.clear) (memo_Trxparse_LBRACE_err)) ; ((Hashtbl.clear) (memo_Trxparse_LEFTARROW)) ; ((Hashtbl.clear) (memo_Trxparse_LEFTARROW_err)) ; ((Hashtbl.clear) (memo_Trxparse_LET)) ; ((Hashtbl.clear) (memo_Trxparse_LET_err)) ; ((Hashtbl.clear) (memo_Trxparse_Literal)) ; ((Hashtbl.clear) (memo_Trxparse_Literal_err)) ; ((Hashtbl.clear) (memo_Trxparse_Module)) ; ((Hashtbl.clear) (memo_Trxparse_Module_err)) ; ((Hashtbl.clear) (memo_Trxparse_NOT)) ; ((Hashtbl.clear) (memo_Trxparse_NOT_err)) ; ((Hashtbl.clear) (memo_Trxparse_Name)) ; ((Hashtbl.clear) (memo_Trxparse_Name_err)) ; ((Hashtbl.clear) (memo_Trxparse_Names)) ; ((Hashtbl.clear) (memo_Trxparse_Names_err)) ; ((Hashtbl.clear) (memo_Trxparse_OPEN)) ; ((Hashtbl.clear) (memo_Trxparse_OPEN_err)) ; ((Hashtbl.clear) (memo_Trxparse_Option)) ; ((Hashtbl.clear) (memo_Trxparse_Option_err)) ; ((Hashtbl.clear) (memo_Trxparse_PLUS)) ; ((Hashtbl.clear) (memo_Trxparse_PLUS_err)) ; ((Hashtbl.clear) (memo_Trxparse_Prefix)) ; ((Hashtbl.clear) (memo_Trxparse_Prefix_err)) ; ((Hashtbl.clear) (memo_Trxparse_PrefixElement)) ; ((Hashtbl.clear) (memo_Trxparse_PrefixElement_err)) ; ((Hashtbl.clear) (memo_Trxparse_Primary)) ; ((Hashtbl.clear) (memo_Trxparse_Primary_err)) ; ((Hashtbl.clear) (memo_Trxparse_QUESTION)) ; ((Hashtbl.clear) (memo_Trxparse_QUESTION_err)) ; ((Hashtbl.clear) (memo_Trxparse_RBRACE)) ; ((Hashtbl.clear) (memo_Trxparse_RBRACE_err)) ; ((Hashtbl.clear) (memo_Trxparse_Range)) ; ((Hashtbl.clear) (memo_Trxparse_Range_err)) ; ((Hashtbl.clear) (memo_Trxparse_SEMI)) ; ((Hashtbl.clear) (memo_Trxparse_SEMI_err)) ; ((Hashtbl.clear) (memo_Trxparse_SLASH)) ; ((Hashtbl.clear) (memo_Trxparse_SLASH_err)) ; ((Hashtbl.clear) (memo_Trxparse_STAR)) ; ((Hashtbl.clear) (memo_Trxparse_STAR_err)) ; ((Hashtbl.clear) (memo_Trxparse_Sequence)) ; ((Hashtbl.clear) (memo_Trxparse_Sequence_err)) ; ((Hashtbl.clear) (memo_Trxparse_Space)) ; ((Hashtbl.clear) (memo_Trxparse_Space_err)) ; ((Hashtbl.clear) (memo_Trxparse_Spacing)) ; ((Hashtbl.clear) (memo_Trxparse_Spacing_err)) ; ((Hashtbl.clear) (memo_Trxparse_StoppableCode)) ; ((Hashtbl.clear) (memo_Trxparse_StoppableCode_err)) ; ((Hashtbl.clear) (memo_Trxparse_Suffix)) ; ((Hashtbl.clear) (memo_Trxparse_Suffix_err)) ; ((Hashtbl.clear) (memo_Trxparse_SuffixElement)) ; ((Hashtbl.clear) (memo_Trxparse_SuffixElement_err)) ; ((Hashtbl.clear) (memo_Trxparse_TILDE)) ; ((Hashtbl.clear) (memo_Trxparse_TILDE_err)) ; ((Hashtbl.clear) (memo_Trxparse_Type)) ; ((Hashtbl.clear) (memo_Trxparse_Type_err)) ; ((Hashtbl.clear) (memo_Trxparse_construct_name_opt)) ; ((Hashtbl.clear) (memo_Trxparse_construct_name_opt_err)) ; ((Hashtbl.clear) (memo_Trxparse_construct_name_primary)) ; ((Hashtbl.clear) (memo_Trxparse_construct_name_primary_err)) ; ((Hashtbl.clear) (memo_Trxparse_construct_name_secondary)) ; ((Hashtbl.clear) (memo_Trxparse_construct_name_secondary_err)) ; ((Hashtbl.clear) (memo_Trxparse_item_list)) ; ((Hashtbl.clear) (memo_Trxparse_item_list_err)) ; ((Hashtbl.clear) (memo_Trxparse_memo_opt)) ; ((Hashtbl.clear) (memo_Trxparse_memo_opt_err)) ; ((Hashtbl.clear) (memo_Trxparse_mlCOMMENTSTART)) ; ((Hashtbl.clear) (memo_Trxparse_mlCOMMENTSTART_err)) ; ((Hashtbl.clear) (memo_Trxparse_mlCOMMENTSTOP)) ; ((Hashtbl.clear) (memo_Trxparse_mlCOMMENTSTOP_err)) ; ((Hashtbl.clear) (memo_Trxparse_mlcomment)) ; ((Hashtbl.clear) (memo_Trxparse_mlcomment_err)) ; ((Hashtbl.clear) (memo_Trxparse_mlvar)) ; ((Hashtbl.clear) (memo_Trxparse_mlvar_err)) ; ((Hashtbl.clear) (memo_Trxparse_optionType)) ; ((Hashtbl.clear) (memo_Trxparse_optionType_err)) ; ((Hashtbl.clear) (memo_Trxparse_rule_annots)) ; ((Hashtbl.clear) (memo_Trxparse_rule_annots_err))
let rec try_Trxparse_EOF_noerr = 
#257 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
Some((((succ) (input)), `Class(c))) ) else ( None ) with
None -> let input_281 = input in
let __1 = `Not in
Some((input_281, `Seq(input, input_281, ((__1)::([])))))
| Some ( ( _, _ ) ) -> None) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_EOF", None, res)))
| ( None ) as __pat_var -> __pat_var))
let rec try_Trxparse_EOL_noerr = 
#255 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_EOL) (input))
) with
Not_found -> let res = (match (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\n'))) ((((=)) (c) ('\r')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_280, __1 ) ) -> Some((input_280, `Seq(input, input_280, ((__1)::([])))))) with
None -> (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('\r'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "\r"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_278, __1 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_278) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_278) (0))))) ('\n'))) (true)))) ) then ( Some(((((+)) (input_278) (1)), `Literal(input_278, "\n"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_279, __2 ) ) -> Some((input_279, `Seq(input, input_279, [ __1 ; __2 ])))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_EOL", Some(("end of line")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_EOL) (input) (res)) ; res)
)
let rec try_Trxparse_Space_noerr = 
#254 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Space) (input))
) with
Not_found -> let res = (match (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) (' '))) ((((=)) (c) ('\t')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_114, __1 ) ) -> Some((input_114, `Seq(input, input_114, ((__1)::([])))))) with
None -> (match (try_Trxparse_EOL_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_113, __1 ) ) -> Some((input_113, `Seq(input, input_113, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Space", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Space) (input) (res)) ; res)
)
let rec try_Trxparse_mlcomment_noerr = 
#250 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_mlcomment) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_mlCOMMENTSTART_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_16, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_19 -> (match (try_Trxparse_mlCOMMENTSTOP_noerr (_filename) (_text) (input_19)) with
None -> let input_20 = input_19 in
let __1 = `Not in
(match (match (match (try_Trxparse_mlcomment_noerr (_filename) (_text) (input_20)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_23, __1 ) ) -> Some((input_23, `Seq(input_20, input_23, ((__1)::([])))))) with
None -> (match if ( (((<)) (input_20) (_len)) ) then ( let c = ((_get_char) (input_20)) in
Some((((succ) (input_20)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_22, __1 ) ) -> Some((input_22, `Seq(input_20, input_22, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_21, __2 ) ) -> Some((input_21, `Seq(input_19, input_21, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_16)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_17, __2 ) ) -> (match (try_Trxparse_mlCOMMENTSTOP_noerr (_filename) (_text) (input_17)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_18, __3 ) ) -> Some((input_18, `Seq(input, input_18, [ __1 ; __2 ; __3 ])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_mlcomment", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_mlcomment) (input) (res)) ; res)
)
and try_Trxparse_Spacing_noerr = 
#245 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Spacing) (input))
) with
Not_found -> let res = (match (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_110 -> (match (match (try_Trxparse_Space_noerr (_filename) (_text) (input_110)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_112, __1 ) ) -> Some((input_112, `Seq(input_110, input_112, ((__1)::([])))))) with
None -> (match (try_Trxparse_Comment_noerr (_filename) (_text) (input_110)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_111, __1 ) ) -> Some((input_111, `Seq(input_110, input_111, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)))) (input)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_109, __1 ) ) -> Some((input_109, `Seq(input, input_109, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Spacing", Some(("spacing")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Spacing) (input) (res)) ; res)
)
and try_Trxparse_mlCOMMENTSTOP_noerr = 
#252 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_mlCOMMENTSTOP) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (')'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "*)"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_24, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_24)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_25, __2 ) ) -> Some((input_25, `Seq(input, input_25, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_mlCOMMENTSTOP", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_mlCOMMENTSTOP) (input) (res)) ; res)
)
and try_Trxparse_Comment_noerr = 
#247 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Comment) (input))
) with
Not_found -> let res = (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('#'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "#"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_347, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_352 -> (match (try_Trxparse_EOL_noerr (_filename) (_text) (input_352)) with
None -> let input_353 = input_352 in
let __1 = `Not in
(match if ( (((<)) (input_353) (_len)) ) then ( let c = ((_get_char) (input_353)) in
Some((((succ) (input_353)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_354, __2 ) ) -> Some((input_354, `Seq(input_352, input_354, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_347)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_348, __2 ) ) -> (match (match (match (try_Trxparse_EOL_noerr (_filename) (_text) (input_348)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_351, __1 ) ) -> Some((input_351, `Seq(input_348, input_351, ((__1)::([])))))) with
None -> (match (try_Trxparse_EOF_noerr (_filename) (_text) (input_348)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_350, __1 ) ) -> Some((input_350, `Seq(input_348, input_350, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_349, __3 ) ) -> Some((input_349, `Seq(input, input_349, [ __1 ; __2 ; __3 ])))))) with
None -> (match (try_Trxparse_mlcomment_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_346, __1 ) ) -> Some((input_346, `Seq(input, input_346, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Comment", Some(("a comment")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Comment) (input) (res)) ; res)
)
and try_Trxparse_mlCOMMENTSTART_noerr = 
#251 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_mlCOMMENTSTART) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('('))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "(*"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_26, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_26)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_27, __2 ) ) -> Some((input_27, `Seq(input, input_27, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_mlCOMMENTSTART", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_mlCOMMENTSTART) (input) (res)) ; res)
)
let rec try_Trxparse_AND_noerr = 
#228 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_AND) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('&')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_395, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_395)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_396, __2 ) ) -> Some((input_396, `Seq(input, input_396, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_AND", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_AND) (input) (res)) ; res)
)
let rec try_Trxparse_NOT_noerr = 
#229 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_NOT) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('!')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_175, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_175)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_176, __2 ) ) -> Some((input_176, `Seq(input, input_176, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_NOT", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_NOT) (input) (res)) ; res)
)
let rec try_Trxparse_PrefixElement_noerr = 
#172 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_PrefixElement) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_AND_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_150, __1 ) ) -> Some((input_150, `Seq(input, input_150, ((__1)::([])))))) with
None -> (match (try_Trxparse_NOT_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_149, __1 ) ) -> Some((input_149, `Seq(input, input_149, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_PrefixElement", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_PrefixElement) (input) (res)) ; res)
)
let rec try_Trxparse_Prefix_noerr = 
#174 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Prefix) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_PrefixElement_noerr (_filename) (_text) (input)) with
None -> Some((input, `Option(None)))
| Some ( ( input_152, r ) ) -> Some((input_152, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_151, __1 ) ) -> Some((input_151, `Seq(input, input_151, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Prefix", Some(("element's prefix")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Prefix) (input) (res)) ; res)
)
let rec try_Trxparse_CLOSE_noerr = 
#234 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_CLOSE) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (')')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_389, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_389)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_390, __2 ) ) -> Some((input_390, `Seq(input, input_390, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_CLOSE", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_CLOSE) (input) (res)) ; res)
)
let rec try_Trxparse_Char_noerr = 
#212 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Char) (input))
) with
Not_found -> let res = (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('\\'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "\\"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_383, __1 ) ) -> (match if ( (((<)) (input_383) (_len)) ) then ( let c = ((_get_char) (input_383)) in
if ( (((||)) ((((=)) (c) ('n'))) ((((||)) ((((=)) (c) ('r'))) ((((||)) ((((=)) (c) ('t'))) ((((||)) ((((=)) (c) ('\''))) ((((||)) ((((=)) (c) ('"'))) ((((||)) ((((=)) (c) ('\\'))) ((((||)) ((((=)) (c) ('['))) ((((||)) ((((=)) (c) (']'))) ((((=)) (c) ('-')))))))))))))))))) ) then ( Some((((succ) (input_383)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_384, __2 ) ) -> Some((input_384, `Seq(input, input_384, [ __1 ; __2 ]))))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('\\'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "\\"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_380, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (true) ((fun input_382 -> if ( (((<)) (input_382) (_len)) ) then ( let c = ((_get_char) (input_382)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_382)), `Class(c))) ) else ( None ) ) else ( None ))) (input_380)) with
Some ( ( pos, res ) ) -> Some((pos, `Plus(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_381, __2 ) ) -> Some((input_381, `Seq(input, input_381, [ __1 ; __2 ]))))) with
None -> (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('\\'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "\\"))) ) else ( None ) with
None -> let input_378 = input in
let __1 = `Not in
(match if ( (((<)) (input_378) (_len)) ) then ( let c = ((_get_char) (input_378)) in
Some((((succ) (input_378)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_379, __2 ) ) -> Some((input_379, `Seq(input, input_379, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None)
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Char", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Char) (input) (res)) ; res)
)
let rec try_Trxparse_Range_noerr = 
#210 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Range) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_Char_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_125, __1 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_125) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_125) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input_125) (1)), `Literal(input_125, "-"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_126, __2 ) ) -> (match (try_Trxparse_Char_noerr (_filename) (_text) (input_126)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_127, __3 ) ) -> Some((input_127, `Seq(input, input_127, [ __1 ; __2 ; __3 ])))))) with
None -> (match (try_Trxparse_Char_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_124, __1 ) ) -> Some((input_124, `Seq(input, input_124, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Range", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Range) (input) (res)) ; res)
)
let rec try_Trxparse_Class_noerr = 
#206 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Class) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('['))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "["))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_369, __1 ) ) -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_369) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_369) (0))))) ('^'))) (true)))) ) then ( Some(((((+)) (input_369) (1)), `Literal(input_369, "^"))) ) else ( None ) with
None -> Some((input_369, `Option(None)))
| Some ( ( input_377, r ) ) -> Some((input_377, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_370, __2 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_374 -> (match if ( (((&&)) ((((<=)) ((((+)) (input_374) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_374) (0))))) (']'))) (true)))) ) then ( Some(((((+)) (input_374) (1)), `Literal(input_374, "]"))) ) else ( None ) with
None -> let input_375 = input_374 in
let __1 = `Not in
(match (try_Trxparse_Range_noerr (_filename) (_text) (input_375)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_376, __2 ) ) -> Some((input_376, `Seq(input_374, input_376, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_370)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_371, __3 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_371) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_371) (0))))) (']'))) (true)))) ) then ( Some(((((+)) (input_371) (1)), `Literal(input_371, "]"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_372, __4 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_372)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_373, __5 ) ) -> Some((input_373, `Seq(input, input_373, [ __1 ; __2 ; __3 ; __4 ; __5 ])))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Class", Some(("class of symbols")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Class) (input) (res)) ; res)
)
let rec try_Trxparse_DOT_noerr = 
#235 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DOT) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_341, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_341)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_342, __2 ) ) -> Some((input_342, `Seq(input, input_342, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_DOT", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DOT) (input) (res)) ; res)
)
let rec try_Trxparse_EQUAL_noerr = 
#238 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_EQUAL) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('=')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_276, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_276)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_277, __2 ) ) -> Some((input_277, `Seq(input, input_277, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_EQUAL", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_EQUAL) (input) (res)) ; res)
)
let rec try_Trxparse_SLASH_noerr = 
#227 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_SLASH) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('/')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_120, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_120)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_121, __2 ) ) -> Some((input_121, `Seq(input, input_121, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_SLASH", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_SLASH) (input) (res)) ; res)
)
let rec try_Trxparse_CodeRange_noerr = 
#157 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_CodeRange) (input))
) with
Not_found -> let res = (match (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('_'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, ":_"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_356, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_356)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_357, __2 ) ) -> Some((input_357, `Seq(input, input_357, [ __1 ; __2 ]))))) with
None -> Some((input, `Option(None)))
| Some ( ( input_358, r ) ) -> Some((input_358, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_355, __1 ) ) -> Some((input_355, `Seq(input, input_355, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_CodeRange", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_CodeRange) (input) (res)) ; res)
)
let rec try_Trxparse_DOLLAR_noerr = 
#236 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DOLLAR) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('$')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_343, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_343)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_344, __2 ) ) -> Some((input_344, `Seq(input, input_344, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_DOLLAR", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DOLLAR) (input) (res)) ; res)
)
let rec try_Trxparse_BEGIN_noerr = 
#221 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('{'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('{'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "{{"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_394, __1 ) ) -> Some((input_394, `Seq(input, input_394, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_BEGIN", None, res)))
| ( None ) as __pat_var -> __pat_var))
let rec try_Trxparse_BEGIn_noerr = 
#223 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('{'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('|'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "{|"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_393, __1 ) ) -> Some((input_393, `Seq(input, input_393, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_BEGIn", None, res)))
| ( None ) as __pat_var -> __pat_var))
let rec try_Trxparse_END_noerr = 
#222 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_END) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('}'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('}'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "}}"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_284, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_284)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_285, __2 ) ) -> Some((input_285, `Seq(input, input_285, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_END", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_END) (input) (res)) ; res)
)
let rec try_Trxparse_ENd_noerr = 
#224 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_ENd) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('|'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('}'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "|}"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_282, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_282)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_283, __2 ) ) -> Some((input_283, `Seq(input, input_283, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_ENd", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_ENd) (input) (res)) ; res)
)
let rec try_Trxparse_StoppableCode_noerr = 
#158 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_StoppableCode) (input))
) with
Not_found -> let res = (match (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('!'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "!!"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_106, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_106)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_107, __2 ) ) -> Some((input_107, `Seq(input, input_107, [ __1 ; __2 ]))))) with
None -> Some((input, `Option(None)))
| Some ( ( input_108, r ) ) -> Some((input_108, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_105, __1 ) ) -> Some((input_105, `Seq(input, input_105, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_StoppableCode", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_StoppableCode) (input) (res)) ; res)
)
let rec try_Trxparse_DefaultCode_noerr = 
#163 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DefaultCode) (input))
) with
Not_found -> let res = (match (match (match (match (match (try_Trxparse_BEGIn_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_335, __1 ) ) -> Some((input_335, `Seq(input, input_335, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_323, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_323)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_324, __2 ) ) -> (match (try_Trxparse_StoppableCode_noerr (_filename) (_text) (input_324)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_325, __3 ) ) -> (match (try_Trxparse_CodeRange_noerr (_filename) (_text) (input_325)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_326, __4 ) ) -> (match (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_331 -> (match (match (try_Trxparse_ENd_noerr (_filename) (_text) (input_331)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_334, __1 ) ) -> Some((input_334, `Seq(input_331, input_334, ((__1)::([])))))) with
None -> let input_332 = input_331 in
let __1 = `Not in
(match if ( (((<)) (input_332) (_len)) ) then ( let c = ((_get_char) (input_332)) in
Some((((succ) (input_332)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_333, __2 ) ) -> Some((input_333, `Seq(input_331, input_333, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_326)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_330, __1 ) ) -> Some((input_330, `Seq(input_326, input_330, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_327, __5 ) ) -> (match (match (try_Trxparse_ENd_noerr (_filename) (_text) (input_327)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_329, __1 ) ) -> Some((input_329, `Seq(input_327, input_329, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_328, __6 ) ) -> Some((input_328, `Seq(input, input_328, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ]))))))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_322, __1 ) ) -> Some((input_322, `Seq(input, input_322, ((__1)::([])))))) with
None -> (match (match (match (try_Trxparse_BEGIN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_321, __1 ) ) -> Some((input_321, `Seq(input, input_321, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_309, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_309)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_310, __2 ) ) -> (match (try_Trxparse_StoppableCode_noerr (_filename) (_text) (input_310)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_311, __3 ) ) -> (match (try_Trxparse_CodeRange_noerr (_filename) (_text) (input_311)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_312, __4 ) ) -> (match (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_317 -> (match (match (try_Trxparse_END_noerr (_filename) (_text) (input_317)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_320, __1 ) ) -> Some((input_320, `Seq(input_317, input_320, ((__1)::([])))))) with
None -> let input_318 = input_317 in
let __1 = `Not in
(match if ( (((<)) (input_318) (_len)) ) then ( let c = ((_get_char) (input_318)) in
Some((((succ) (input_318)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_319, __2 ) ) -> Some((input_319, `Seq(input_317, input_319, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_312)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_316, __1 ) ) -> Some((input_316, `Seq(input_312, input_316, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_313, __5 ) ) -> (match (match (try_Trxparse_END_noerr (_filename) (_text) (input_313)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_315, __1 ) ) -> Some((input_315, `Seq(input_313, input_315, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_314, __6 ) ) -> Some((input_314, `Seq(input, input_314, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ]))))))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_308, __1 ) ) -> Some((input_308, `Seq(input, input_308, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_DefaultCode", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DefaultCode) (input) (res)) ; res)
)
let rec try_Trxparse_Code_noerr = 
#167 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Code) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_DefaultCode_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_368, __1 ) ) -> Some((input_368, `Seq(input, input_368, ((__1)::([])))))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('$'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('_'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "$_"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_365, __1 ) ) -> (match (try_Trxparse_CodeRange_noerr (_filename) (_text) (input_365)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_366, __2 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_366)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_367, __3 ) ) -> Some((input_367, `Seq(input, input_367, [ __1 ; __2 ; __3 ])))))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('$'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "$:"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_360, __1 ) ) -> (match (match (match (Trx_runtime.while_primary_noerr (true) ((fun input_364 -> if ( (((<)) (input_364) (_len)) ) then ( let c = ((_get_char) (input_364)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_364)), `Class(c))) ) else ( None ) ) else ( None ))) (input_360)) with
Some ( ( pos, res ) ) -> Some((pos, `Plus(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_363, __1 ) ) -> Some((input_363, `Seq(input_360, input_363, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_361, __2 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_361)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_362, __3 ) ) -> Some((input_362, `Seq(input, input_362, [ __1 ; __2 ; __3 ])))))) with
None -> (match (try_Trxparse_DOLLAR_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_359, __1 ) ) -> Some((input_359, `Seq(input, input_359, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Code", Some(("rule production")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Code) (input) (res)) ; res)
)
let rec try_Trxparse_COMMA_noerr = 
#239 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_COMMA) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (',')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_385, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_385)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_386, __2 ) ) -> Some((input_386, `Seq(input, input_386, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_COMMA", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_COMMA) (input) (res)) ; res)
)
let rec try_Trxparse_OPEN_noerr = 
#233 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_OPEN) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('(')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_162, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_162)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_163, __2 ) ) -> Some((input_163, `Seq(input, input_163, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_OPEN", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_OPEN) (input) (res)) ; res)
)
let rec try_Trxparse_Module_noerr = 
#194 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Module) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_177, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_179 -> if ( (((<)) (input_179) (_len)) ) then ( let c = ((_get_char) (input_179)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input_179)), `Class(c))) ) else ( None ) ) else ( None ))) (input_177)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_178, __2 ) ) -> Some((input_178, `Seq(input, input_178, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Module", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Module) (input) (res)) ; res)
)
let rec try_Trxparse_Name_noerr = 
#195 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Name) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((=)) (c) ('_')))))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_172, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_174 -> if ( (((<)) (input_174) (_len)) ) then ( let c = ((_get_char) (input_174)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input_174)), `Class(c))) ) else ( None ) ) else ( None ))) (input_172)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_173, __2 ) ) -> Some((input_173, `Seq(input, input_173, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Name", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Name) (input) (res)) ; res)
)
let rec try_Trxparse_Identifier_noerr = 
#198 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Identifier) (input))
) with
Not_found -> let res = (match (match (match (match (try_Trxparse_Module_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_215, __1 ) ) -> (match if ( (((<)) (input_215) (_len)) ) then ( let c = ((_get_char) (input_215)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_215)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_216, __2 ) ) -> (match (try_Trxparse_Name_noerr (_filename) (_text) (input_216)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_217, __3 ) ) -> Some((input_217, `Seq(input, input_217, [ __1 ; __2 ; __3 ])))))) with
None -> (match (try_Trxparse_Name_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_214, __1 ) ) -> Some((input_214, `Seq(input, input_214, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_212, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_212)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_213, __2 ) ) -> Some((input_213, `Seq(input, input_213, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Identifier", Some(("identifier")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Identifier) (input) (res)) ; res)
)
let rec try_Trxparse_LEFTARROW_noerr = 
#225 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_LEFTARROW) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "<-"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_197, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_197)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_198, __2 ) ) -> Some((input_198, `Seq(input, input_198, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_LEFTARROW", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_LEFTARROW) (input) (res)) ; res)
)
let rec try_Trxparse_Literal_noerr = 
#203 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Literal) (input))
) with
Not_found -> let res = (match (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_188, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_192 -> (match if ( (((<)) (input_192) (_len)) ) then ( let c = ((_get_char) (input_192)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input_192)), `Class(c))) ) else ( None ) ) else ( None ) with
None -> let input_193 = input_192 in
let __1 = `Not in
(match (try_Trxparse_Char_noerr (_filename) (_text) (input_193)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_194, __2 ) ) -> Some((input_194, `Seq(input_192, input_194, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_188)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_189, __2 ) ) -> (match if ( (((<)) (input_189) (_len)) ) then ( let c = ((_get_char) (input_189)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input_189)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_190, __3 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_190)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_191, __4 ) ) -> Some((input_191, `Seq(input, input_191, [ __1 ; __2 ; __3 ; __4 ]))))))) with
None -> (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_181, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_185 -> (match if ( (((<)) (input_185) (_len)) ) then ( let c = ((_get_char) (input_185)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input_185)), `Class(c))) ) else ( None ) ) else ( None ) with
None -> let input_186 = input_185 in
let __1 = `Not in
(match (try_Trxparse_Char_noerr (_filename) (_text) (input_186)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_187, __2 ) ) -> Some((input_187, `Seq(input_185, input_187, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_181)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_182, __2 ) ) -> (match if ( (((<)) (input_182) (_len)) ) then ( let c = ((_get_char) (input_182)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input_182)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_183, __3 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_183)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_184, __4 ) ) -> Some((input_184, `Seq(input, input_184, [ __1 ; __2 ; __3 ; __4 ])))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Literal", Some(("literal")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Literal) (input) (res)) ; res)
)
let rec try_Trxparse_TILDE_noerr = 
#237 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_TILDE) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('~')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_98, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_98)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_99, __2 ) ) -> Some((input_99, `Seq(input, input_99, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_TILDE", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_TILDE) (input) (res)) ; res)
)
let rec try_Trxparse_PLUS_noerr = 
#232 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_PLUS) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('+')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_153, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_153)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_154, __2 ) ) -> Some((input_154, `Seq(input, input_154, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_PLUS", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_PLUS) (input) (res)) ; res)
)
let rec try_Trxparse_QUESTION_noerr = 
#230 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_QUESTION) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('?')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_132, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_132)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_133, __2 ) ) -> Some((input_133, `Seq(input, input_133, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_QUESTION", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_QUESTION) (input) (res)) ; res)
)
let rec try_Trxparse_STAR_noerr = 
#231 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_STAR) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('*')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_118, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_118)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_119, __2 ) ) -> Some((input_119, `Seq(input, input_119, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_STAR", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_STAR) (input) (res)) ; res)
)
let rec try_Trxparse_SuffixElement_noerr = 
#173 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_SuffixElement) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_QUESTION_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_102, __1 ) ) -> Some((input_102, `Seq(input, input_102, ((__1)::([])))))) with
None -> (match (match (try_Trxparse_STAR_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_101, __1 ) ) -> Some((input_101, `Seq(input, input_101, ((__1)::([])))))) with
None -> (match (try_Trxparse_PLUS_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_100, __1 ) ) -> Some((input_100, `Seq(input, input_100, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_SuffixElement", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_SuffixElement) (input) (res)) ; res)
)
let rec try_Trxparse_Suffix_noerr = 
#176 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Suffix) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_SuffixElement_noerr (_filename) (_text) (input)) with
None -> Some((input, `Option(None)))
| Some ( ( input_104, r ) ) -> Some((input_104, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_103, __1 ) ) -> Some((input_103, `Seq(input, input_103, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Suffix", Some(("element's suffix")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Suffix) (input) (res)) ; res)
)
let rec try_Trxparse_mlvar_noerr = 
#127 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_mlvar) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((=)) (c) ('_')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_13, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_15 -> if ( (((<)) (input_15) (_len)) ) then ( let c = ((_get_char) (input_15)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input_15)), `Class(c))) ) else ( None ) ) else ( None ))) (input_13)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_14, __2 ) ) -> Some((input_14, `Seq(input, input_14, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_mlvar", Some(("element name")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_mlvar) (input) (res)) ; res)
)
let rec try_Trxparse_Expression_noerr = 
#134 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Expression) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_SLASH_noerr (_filename) (_text) (input)) with
None -> Some((input, `Option(None)))
| Some ( ( input_275, r ) ) -> Some((input_275, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_269, __1 ) ) -> (match (try_Trxparse_Sequence_noerr (_filename) (_text) (input_269)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_270, __2 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_272 -> (match (try_Trxparse_SLASH_noerr (_filename) (_text) (input_272)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_273, __1 ) ) -> (match (try_Trxparse_Sequence_noerr (_filename) (_text) (input_273)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_274, __2 ) ) -> Some((input_274, `Seq(input_272, input_274, [ __1 ; __2 ]))))))) (input_270)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_271, __3 ) ) -> Some((input_271, `Seq(input, input_271, [ __1 ; __2 ; __3 ])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Expression", Some(("rule body")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Expression) (input) (res)) ; res)
)
and try_Trxparse_Sequence_noerr = 
#145 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Sequence) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_item_list_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_115, __1 ) ) -> (match (match (try_Trxparse_Code_noerr (_filename) (_text) (input_115)) with
None -> Some((input_115, `Option(None)))
| Some ( ( input_117, r ) ) -> Some((input_117, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_116, __2 ) ) -> Some((input_116, `Seq(input, input_116, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Sequence", Some(("a sequence of parsing expressions")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Sequence) (input) (res)) ; res)
)
and try_Trxparse_Primary_noerr = 
#178 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Primary) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_Identifier_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_147, __1 ) ) -> (match (try_Trxparse_LEFTARROW_noerr (_filename) (_text) (input_147)) with
None -> let input_148 = input_147 in
let __2 = `Not in
Some((input_148, `Seq(input, input_148, [ __1 ; __2 ])))
| Some ( ( _, _ ) ) -> None)) with
None -> (match (match (try_Trxparse_OPEN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_142, __1 ) ) -> (match (try_Trxparse_EQUAL_noerr (_filename) (_text) (input_142)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_143, __2 ) ) -> (match (try_Trxparse_Identifier_noerr (_filename) (_text) (input_143)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_144, __3 ) ) -> (match (try_Trxparse_Exprs_noerr (_filename) (_text) (input_144)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_145, __4 ) ) -> (match (try_Trxparse_CLOSE_noerr (_filename) (_text) (input_145)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_146, __5 ) ) -> Some((input_146, `Seq(input, input_146, [ __1 ; __2 ; __3 ; __4 ; __5 ])))))))) with
None -> (match (match (try_Trxparse_OPEN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_139, __1 ) ) -> (match (try_Trxparse_Expression_noerr (_filename) (_text) (input_139)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_140, __2 ) ) -> (match (try_Trxparse_CLOSE_noerr (_filename) (_text) (input_140)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_141, __3 ) ) -> Some((input_141, `Seq(input, input_141, [ __1 ; __2 ; __3 ])))))) with
None -> (match (match (try_Trxparse_Literal_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_136, __1 ) ) -> (match (match (try_Trxparse_TILDE_noerr (_filename) (_text) (input_136)) with
None -> Some((input_136, `Option(None)))
| Some ( ( input_138, r ) ) -> Some((input_138, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_137, __2 ) ) -> Some((input_137, `Seq(input, input_137, [ __1 ; __2 ]))))) with
None -> (match (match (try_Trxparse_Class_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_135, __1 ) ) -> Some((input_135, `Seq(input, input_135, ((__1)::([])))))) with
None -> (match (try_Trxparse_DOT_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_134, __1 ) ) -> Some((input_134, `Seq(input, input_134, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Primary", Some(("parsing element")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Primary) (input) (res)) ; res)
)
and try_Trxparse_Exprs_noerr = 
#106 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Exprs) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_OPEN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_262, __1 ) ) -> (match (try_Trxparse_Expression_noerr (_filename) (_text) (input_262)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_263, __2 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_266 -> (match (try_Trxparse_COMMA_noerr (_filename) (_text) (input_266)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_267, __1 ) ) -> (match (try_Trxparse_Expression_noerr (_filename) (_text) (input_267)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_268, __2 ) ) -> Some((input_268, `Seq(input_266, input_268, [ __1 ; __2 ]))))))) (input_263)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_264, __3 ) ) -> (match (try_Trxparse_CLOSE_noerr (_filename) (_text) (input_264)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_265, __4 ) ) -> Some((input_265, `Seq(input, input_265, [ __1 ; __2 ; __3 ; __4 ]))))))) with
None -> (match (try_Trxparse_OPEN_noerr (_filename) (_text) (input)) with
None -> let input_260 = input in
let __1 = `Not in
(match (try_Trxparse_Expression_noerr (_filename) (_text) (input_260)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_261, __2 ) ) -> Some((input_261, `Seq(input, input_261, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None)
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Exprs", Some(("list of expressions")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Exprs) (input) (res)) ; res)
)
and try_Trxparse_item_list_noerr = 
#137 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_item_list) (input))
) with
Not_found -> let res = (match (match (match (Trx_runtime.while_primary_noerr (true) ((fun input_42 -> (match (try_Trxparse_Prefix_noerr (_filename) (_text) (input_42)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_43, __1 ) ) -> (match (try_Trxparse_Primary_noerr (_filename) (_text) (input_43)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_44, __2 ) ) -> (match (try_Trxparse_Suffix_noerr (_filename) (_text) (input_44)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_45, __3 ) ) -> (match (match (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_45)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_47, __1 ) ) -> (match if ( (((<)) (input_47) (_len)) ) then ( let c = ((_get_char) (input_47)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input_47)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_48, __2 ) ) -> (match (match if ( (((<)) (input_48) (_len)) ) then ( let c = ((_get_char) (input_48)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input_48)), `Class(c))) ) else ( None ) ) else ( None ) with
None -> Some((input_48, `Option(None)))
| Some ( ( input_53, r ) ) -> Some((input_53, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_49, __3 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_49)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_50, __4 ) ) -> (match (try_Trxparse_mlvar_noerr (_filename) (_text) (input_50)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_51, __5 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_51)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_52, __6 ) ) -> Some((input_52, `Seq(input_45, input_52, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ]))))))))) with
None -> Some((input_45, `Option(None)))
| Some ( ( input_54, r ) ) -> Some((input_54, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_46, __4 ) ) -> Some((input_46, `Seq(input_42, input_46, [ __1 ; __2 ; __3 ; __4 ]))))))))) (input)) with
Some ( ( pos, res ) ) -> Some((pos, `Plus(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_41, __1 ) ) -> Some((input_41, `Seq(input, input_41, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_item_list", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_item_list) (input) (res)) ; res)
)
let rec try_Trxparse_EOF = 
#257 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
Some((((succ) (input)), `Class(c))) ) else ( None )) (input) (((Trx_runtime.Expected(("any character")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_678 = input in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_678, `Seq(input, input_678, ((__1)::([])))), ((Trx_runtime.emptyError) (input_678))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_EOF", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))
let rec try_Trxparse_EOL = 
#255 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_EOL_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\n'))) ((((=)) (c) ('\r')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'\n'")) ; Trx_runtime.Expected(("'\r'")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_677, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_677, `Seq(input, input_677, ((__1)::([])))), ((Trx_runtime.emptyError) (input_677))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('\r'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "\r"))) ) else ( None )) (input) ("\"\r\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_675, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_675) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_675) (0))))) ('\n'))) (true)))) ) then ( Some(((((+)) (input_675) (1)), `Literal(input_675, "\n"))) ) else ( None )) (input_675) ("\"\n\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_676, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_676, `Seq(input, input_676, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_676))))))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_EOL", Some(("end of line")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<end of line>")))::([])))) in
(Hashtbl.add (memo_Trxparse_EOL_err) (input) (res)) ; res)
)
let rec try_Trxparse_Space = 
#254 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Space_err) (input))
) with
Not_found -> let res = (match (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) (' '))) ((((=)) (c) ('\t')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'\t'")) ; Trx_runtime.Expected(("' '")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_511, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_511, `Seq(input, input_511, ((__1)::([])))), ((Trx_runtime.emptyError) (input_511))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_EOL (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_510, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_510, `Seq(input, input_510, ((__1)::([])))), ((Trx_runtime.emptyError) (input_510)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Space", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Space_err) (input) (res)) ; res)
)
let rec try_Trxparse_mlcomment = 
#250 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_mlcomment_err) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_mlCOMMENTSTART (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_413, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_416 -> (match (try_Trxparse_mlCOMMENTSTOP (_filename) (_text) (input_416)) with
Trx_runtime.Fail ( ( err ) ) -> let input_417 = input_416 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (match (match (try_Trxparse_mlcomment (_filename) (_text) (input_417)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_420, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_420, `Seq(input_417, input_420, ((__1)::([])))), ((Trx_runtime.emptyError) (input_420))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_417) (_len)) ) then ( let c = ((_get_char) (input_417)) in
Some((((succ) (input_417)), `Class(c))) ) else ( None )) (input_417) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_419, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_419, `Seq(input_417, input_419, ((__1)::([])))), ((Trx_runtime.emptyError) (input_419)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_418, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_418, `Seq(input_416, input_418, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_418)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_413)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_414, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_mlCOMMENTSTOP (_filename) (_text) (input_414)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_415, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_415, `Seq(input, input_415, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_415))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_mlcomment", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_mlcomment_err) (input) (res)) ; res)
)
and try_Trxparse_mlCOMMENTSTOP = 
#252 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_mlCOMMENTSTOP_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (')'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "*)"))) ) else ( None )) (input) ("\"*)\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_421, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_421)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_422, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_422, `Seq(input, input_422, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_422)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_mlCOMMENTSTOP", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_mlCOMMENTSTOP_err) (input) (res)) ; res)
)
and try_Trxparse_Spacing = 
#245 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Spacing_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (Trx_runtime.while_primary (false) ((fun input_507 -> (match (match (try_Trxparse_Space (_filename) (_text) (input_507)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_509, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_509, `Seq(input_507, input_509, ((__1)::([])))), ((Trx_runtime.emptyError) (input_509))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Comment (_filename) (_text) (input_507)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_508, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_508, `Seq(input_507, input_508, ((__1)::([])))), ((Trx_runtime.emptyError) (input_508)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)))) (input)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_506, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_506, `Seq(input, input_506, ((__1)::([])))), ((Trx_runtime.emptyError) (input_506))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Spacing", Some(("spacing")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<spacing>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Spacing_err) (input) (res)) ; res)
)
and try_Trxparse_Comment = 
#247 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Comment_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('#'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "#"))) ) else ( None )) (input) ("\"#\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_744, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_749 -> (match (try_Trxparse_EOL (_filename) (_text) (input_749)) with
Trx_runtime.Fail ( ( err ) ) -> let input_750 = input_749 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_750) (_len)) ) then ( let c = ((_get_char) (input_750)) in
Some((((succ) (input_750)), `Class(c))) ) else ( None )) (input_750) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_751, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_751, `Seq(input_749, input_751, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_751)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_744)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_745, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Trxparse_EOL (_filename) (_text) (input_745)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_748, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_748, `Seq(input_745, input_748, ((__1)::([])))), ((Trx_runtime.emptyError) (input_748))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_EOF (_filename) (_text) (input_745)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_747, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_747, `Seq(input_745, input_747, ((__1)::([])))), ((Trx_runtime.emptyError) (input_747)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_746, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_746, `Seq(input, input_746, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_746))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_mlcomment (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_743, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_743, `Seq(input, input_743, ((__1)::([])))), ((Trx_runtime.emptyError) (input_743)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Comment", Some(("a comment")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<a comment>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Comment_err) (input) (res)) ; res)
)
and try_Trxparse_mlCOMMENTSTART = 
#251 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_mlCOMMENTSTART_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('('))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "(*"))) ) else ( None )) (input) ("\"(*\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_423, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_423)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_424, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_424, `Seq(input, input_424, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_424)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_mlCOMMENTSTART", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_mlCOMMENTSTART_err) (input) (res)) ; res)
)
let rec try_Trxparse_AND = 
#228 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_AND_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('&')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'&'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_792, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_792)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_793, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_793, `Seq(input, input_793, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_793)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_AND", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_AND_err) (input) (res)) ; res)
)
let rec try_Trxparse_NOT = 
#229 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_NOT_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('!')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'!'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_572, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_572)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_573, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_573, `Seq(input, input_573, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_573)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_NOT", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_NOT_err) (input) (res)) ; res)
)
let rec try_Trxparse_PrefixElement = 
#172 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_PrefixElement_err) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_AND (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_547, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_547, `Seq(input, input_547, ((__1)::([])))), ((Trx_runtime.emptyError) (input_547))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_NOT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_546, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_546, `Seq(input, input_546, ((__1)::([])))), ((Trx_runtime.emptyError) (input_546)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_PrefixElement", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_PrefixElement_err) (input) (res)) ; res)
)
let rec try_Trxparse_Char = 
#212 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Char_err) (input))
) with
Not_found -> let res = (match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('\\'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "\\"))) ) else ( None )) (input) ("\"\\\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_780, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_780) (_len)) ) then ( let c = ((_get_char) (input_780)) in
if ( (((||)) ((((=)) (c) ('n'))) ((((||)) ((((=)) (c) ('r'))) ((((||)) ((((=)) (c) ('t'))) ((((||)) ((((=)) (c) ('\''))) ((((||)) ((((=)) (c) ('"'))) ((((||)) ((((=)) (c) ('\\'))) ((((||)) ((((=)) (c) ('['))) ((((||)) ((((=)) (c) (']'))) ((((=)) (c) ('-')))))))))))))))))) ) then ( Some((((succ) (input_780)), `Class(c))) ) else ( None ) ) else ( None )) (input_780) ([ Trx_runtime.Expected(("'\"'")) ; Trx_runtime.Expected(("'''")) ; Trx_runtime.Expected(("'-'")) ; Trx_runtime.Expected(("'['")) ; Trx_runtime.Expected(("'\\'")) ; Trx_runtime.Expected(("']'")) ; Trx_runtime.Expected(("'n'")) ; Trx_runtime.Expected(("'r'")) ; Trx_runtime.Expected(("'t'")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_781, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_781, `Seq(input, input_781, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_781)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('\\'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "\\"))) ) else ( None )) (input) ("\"\\\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_777, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (true) ((fun input_779 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_779) (_len)) ) then ( let c = ((_get_char) (input_779)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_779)), `Class(c))) ) else ( None ) ) else ( None )) (input_779) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_777)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Plus(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_778, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_778, `Seq(input, input_778, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_778)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('\\'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "\\"))) ) else ( None )) (input) ("\"\\\"")) with
Trx_runtime.Fail ( ( err ) ) -> let input_775 = input in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_775) (_len)) ) then ( let c = ((_get_char) (input_775)) in
Some((((succ) (input_775)), `Class(c))) ) else ( None )) (input_775) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_776, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_776, `Seq(input, input_776, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_776)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Char", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Char_err) (input) (res)) ; res)
)
let rec try_Trxparse_Literal = 
#203 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Literal_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_585, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_589 -> (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_589) (_len)) ) then ( let c = ((_get_char) (input_589)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input_589)), `Class(c))) ) else ( None ) ) else ( None )) (input_589) (((Trx_runtime.Expected(("'''")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_590 = input_589 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Char (_filename) (_text) (input_590)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_591, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_591, `Seq(input_589, input_591, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_591)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_585)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_586, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_586) (_len)) ) then ( let c = ((_get_char) (input_586)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input_586)), `Class(c))) ) else ( None ) ) else ( None )) (input_586) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_587, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_587)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_588, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_588, `Seq(input, input_588, [ __1 ; __2 ; __3 ; __4 ])), ((Trx_runtime.emptyError) (input_588)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\"'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_578, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_582 -> (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_582) (_len)) ) then ( let c = ((_get_char) (input_582)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input_582)), `Class(c))) ) else ( None ) ) else ( None )) (input_582) (((Trx_runtime.Expected(("'\"'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_583 = input_582 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Char (_filename) (_text) (input_583)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_584, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_584, `Seq(input_582, input_584, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_584)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_578)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_579, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_579) (_len)) ) then ( let c = ((_get_char) (input_579)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input_579)), `Class(c))) ) else ( None ) ) else ( None )) (input_579) (((Trx_runtime.Expected(("'\"'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_580, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_580)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_581, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_581, `Seq(input, input_581, [ __1 ; __2 ; __3 ; __4 ])), ((Trx_runtime.emptyError) (input_581))))))))))))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Literal", Some(("literal")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<literal>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Literal_err) (input) (res)) ; res)
)
let rec try_Trxparse_Filename = 
#131 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Filename_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (try_Trxparse_Literal (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_651, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_651, `Seq(input, input_651, ((__1)::([])))), ((Trx_runtime.emptyError) (input_651))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (true) ((fun input_648 -> (match (try_Trxparse_Space (_filename) (_text) (input_648)) with
Trx_runtime.Fail ( ( err ) ) -> let input_649 = input_648 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_649) (_len)) ) then ( let c = ((_get_char) (input_649)) in
Some((((succ) (input_649)), `Class(c))) ) else ( None )) (input_649) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_650, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_650, `Seq(input_648, input_650, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_650)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Plus(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_647, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_647, `Seq(input, input_647, ((__1)::([])))), ((Trx_runtime.emptyError) (input_647)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Filename", Some(("file name")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<file name>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Filename_err) (input) (res)) ; res)
)
let rec try_Trxparse_LBRACE = 
#219 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_LBRACE_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('{'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "{"))) ) else ( None )) (input) ("\"{\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_596, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_596)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_597, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_597, `Seq(input, input_597, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_597)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_LBRACE", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_LBRACE_err) (input) (res)) ; res)
)
let rec try_Trxparse_RBRACE = 
#220 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_RBRACE_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('}'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "}"))) ) else ( None )) (input) ("\"}\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_527, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_527)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_528, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_528, `Seq(input, input_528, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_528)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_RBRACE", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_RBRACE_err) (input) (res)) ; res)
)
let rec try_Trxparse_Type = 
#119 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Type_err) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_Spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_484, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_484) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_484) (0))))) (':'))) (true)))) ) then ( Some(((((+)) (input_484) (1)), `Literal(input_484, ":"))) ) else ( None )) (input_484) ("\":\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_485, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_485)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_486, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_LBRACE (_filename) (_text) (input_486)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_487, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.while_primary (false) ((fun input_492 -> (match (try_Trxparse_RBRACE (_filename) (_text) (input_492)) with
Trx_runtime.Fail ( ( err ) ) -> let input_493 = input_492 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_493) (_len)) ) then ( let c = ((_get_char) (input_493)) in
Some((((succ) (input_493)), `Class(c))) ) else ( None )) (input_493) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_494, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_494, `Seq(input_492, input_494, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_494)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_487)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_491, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_491, `Seq(input_487, input_491, ((__1)::([])))), ((Trx_runtime.emptyError) (input_491))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_488, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_RBRACE (_filename) (_text) (input_488)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_489, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_489)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_490, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_490, `Seq(input, input_490, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ; __7 ])), ((Trx_runtime.emptyError) (input_490))))))))))))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Type", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Type_err) (input) (res)) ; res)
)
let rec try_Trxparse_mlvar = 
#127 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_mlvar_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((=)) (c) ('_')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['a'-'z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_410, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_412 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_412) (_len)) ) then ( let c = ((_get_char) (input_412)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input_412)), `Class(c))) ) else ( None ) ) else ( None )) (input_412) ([ Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])))) (input_410)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_411, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_411, `Seq(input, input_411, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_411)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_mlvar", Some(("element name")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<element name>")))::([])))) in
(Hashtbl.add (memo_Trxparse_mlvar_err) (input) (res)) ; res)
)
let rec try_Trxparse_Extra = 
#121 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Extra_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('x'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('a'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), `Literal(input, "extra"))) ) else ( None )) (input) ("\"extra\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_652, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Space (_filename) (_text) (input_652)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_653, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_653)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_654, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_mlvar (_filename) (_text) (input_654)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_655, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Type (_filename) (_text) (input_655)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_656, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_656, `Seq(input, input_656, [ __1 ; __2 ; __3 ; __4 ; __5 ])), ((Trx_runtime.emptyError) (input_656))))))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Extra", Some(("extra directive")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<extra directive>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Extra_err) (input) (res)) ; res)
)
let rec try_Trxparse_MARK_noerr = 
#216 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('+')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_180, __1 ) ) -> Some((input_180, `Seq(input, input_180, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_MARK", None, res)))
| ( None ) as __pat_var -> __pat_var))
let rec try_Trxparse_memo_opt = 
#87 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_memo_opt_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('{'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('$'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "{$"))) ) else ( None )) (input) ("\"{$\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_425, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((<)) ((((+)) (input_425) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input_425) (0)))) with
'S' -> Some(((((+)) (input_425) (1)), `Literal((((+)) (input_425) (1)), "S")))
| 'F' -> Some(((((+)) (input_425) (1)), `Literal((((+)) (input_425) (1)), "F")))
| '1' -> Some(((((+)) (input_425) (1)), `Literal((((+)) (input_425) (1)), "1")))
| '0' -> Some(((((+)) (input_425) (1)), `Literal((((+)) (input_425) (1)), "0")))
| _ -> None) ) else ( None )) (input_425) ("\"1\" or \"S\" or \"F\" or \"0\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_426, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_426) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_426) (0))))) ('}'))) (true)))) ) then ( Some(((((+)) (input_426) (1)), `Literal(input_426, "}"))) ) else ( None )) (input_426) ("\"}\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_427, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_427)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_428, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_428, `Seq(input, input_428, [ __1 ; __2 ; __3 ; __4 ])), ((Trx_runtime.emptyError) (input_428)))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_memo_opt", Some(("memoization annotation")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<memoization annotation>")))::([])))) in
(Hashtbl.add (memo_Trxparse_memo_opt_err) (input) (res)) ; res)
)
let rec try_Trxparse_Filename_noerr = 
#131 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Filename) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_Literal_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_254, __1 ) ) -> Some((input_254, `Seq(input, input_254, ((__1)::([])))))) with
None -> (match (match (Trx_runtime.while_primary_noerr (true) ((fun input_251 -> (match (try_Trxparse_Space_noerr (_filename) (_text) (input_251)) with
None -> let input_252 = input_251 in
let __1 = `Not in
(match if ( (((<)) (input_252) (_len)) ) then ( let c = ((_get_char) (input_252)) in
Some((((succ) (input_252)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_253, __2 ) ) -> Some((input_253, `Seq(input_251, input_253, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input)) with
Some ( ( pos, res ) ) -> Some((pos, `Plus(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_250, __1 ) ) -> Some((input_250, `Seq(input, input_250, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Filename", Some(("file name")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Filename) (input) (res)) ; res)
)
let rec try_Trxparse_Names_noerr = 
#196 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Names) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_OPEN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_164, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_167 -> (match (try_Trxparse_Name_noerr (_filename) (_text) (input_167)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_168, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_168)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_169, __2 ) ) -> (match (match (try_Trxparse_COMMA_noerr (_filename) (_text) (input_169)) with
None -> Some((input_169, `Option(None)))
| Some ( ( input_171, r ) ) -> Some((input_171, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_170, __3 ) ) -> Some((input_170, `Seq(input_167, input_170, [ __1 ; __2 ; __3 ])))))))) (input_164)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_165, __2 ) ) -> (match (try_Trxparse_CLOSE_noerr (_filename) (_text) (input_165)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_166, __3 ) ) -> Some((input_166, `Seq(input, input_166, [ __1 ; __2 ; __3 ])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Names", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Names) (input) (res)) ; res)
)
let rec try_Trxparse_IncludeRead_noerr = 
#115 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_IncludeRead) (input))
) with
Not_found -> let res = (match (match if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'r' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (4)), `Literal((((+)) (input) (4)), "read"))) ) else ( None )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (7)), `Literal((((+)) (input) (7)), "include"))) ) else ( None )
| _ -> None) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_203, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_203)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_204, __2 ) ) -> (match (try_Trxparse_Filename_noerr (_filename) (_text) (input_204)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_205, __3 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_205)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_206, __4 ) ) -> (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input_206) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_206) (0))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_206) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_206) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_206) (3))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_206) (4))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_206) (5))))) ('l'))) (true)))))))))))))) ) then ( Some(((((+)) (input_206) (6)), `Literal(input_206, "global"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_208, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_208)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_209, __2 ) ) -> (match (try_Trxparse_Names_noerr (_filename) (_text) (input_209)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_210, __3 ) ) -> Some((input_210, `Seq(input_206, input_210, [ __1 ; __2 ; __3 ])))))) with
None -> Some((input_206, `Option(None)))
| Some ( ( input_211, r ) ) -> Some((input_211, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_207, __5 ) ) -> Some((input_207, `Seq(input, input_207, [ __1 ; __2 ; __3 ; __4 ; __5 ])))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_IncludeRead", Some(("include directive")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_IncludeRead) (input) (res)) ; res)
)
let rec try_Trxparse_construct_name_primary = 
#80 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_construct_name_primary_err) (input))
) with
Not_found -> let res = (match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('*'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), `Literal(input, "/**"))) ) else ( None )) (input) ("\"/**\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_481, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_481, `Seq(input, input_481, ((__1)::([])))), ((Trx_runtime.emptyError) (input_481))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_467, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_467)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_468, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.while_primary (false) ((fun input_475 -> (match (match (try_Trxparse_Spacing (_filename) (_text) (input_475)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_478, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_478) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_478) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_478) (1))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_478) (2))))) ('/'))) (true)))))))) ) then ( Some(((((+)) (input_478) (3)), `Literal(input_478, "**/"))) ) else ( None )) (input_478) ("\"**/\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_480, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_480, `Seq(input_478, input_480, ((__1)::([])))), ((Trx_runtime.emptyError) (input_480))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_479, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_479, `Seq(input_475, input_479, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_479)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_476 = input_475 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_476) (_len)) ) then ( let c = ((_get_char) (input_476)) in
Some((((succ) (input_476)), `Class(c))) ) else ( None )) (input_476) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_477, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_477, `Seq(input_475, input_477, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_477)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_468)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_474, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_474, `Seq(input_468, input_474, ((__1)::([])))), ((Trx_runtime.emptyError) (input_474))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_469, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_469)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_470, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_470) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_470) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_470) (1))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_470) (2))))) ('/'))) (true)))))))) ) then ( Some(((((+)) (input_470) (3)), `Literal(input_470, "**/"))) ) else ( None )) (input_470) ("\"**/\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_473, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_473, `Seq(input_470, input_473, ((__1)::([])))), ((Trx_runtime.emptyError) (input_473))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_471, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_471)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_472, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_472, `Seq(input, input_472, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ])), ((Trx_runtime.emptyError) (input_472)))))))))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_construct_name_primary", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_construct_name_primary_err) (input) (res)) ; res)
)
let rec try_Trxparse_KEEP_CACHE_noerr = 
#217 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_KEEP_CACHE) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('>'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (8)), `Literal(input, "<icache>"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_201, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_201)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_202, __2 ) ) -> Some((input_202, `Seq(input, input_202, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_KEEP_CACHE", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_KEEP_CACHE) (input) (res)) ; res)
)
let rec try_Trxparse_EQUAL = 
#238 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_EQUAL_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('=')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'='")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_673, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_673)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_674, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_674, `Seq(input, input_674, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_674)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_EQUAL", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_EQUAL_err) (input) (res)) ; res)
)
let rec try_Trxparse_SLASH = 
#227 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_SLASH_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('/')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'/'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_517, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_517)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_518, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_518, `Seq(input, input_518, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_518)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_SLASH", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_SLASH_err) (input) (res)) ; res)
)
let rec try_Trxparse_CodeRange = 
#157 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_CodeRange_err) (input))
) with
Not_found -> let res = (match (match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('_'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, ":_"))) ) else ( None )) (input) ("\":_\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_753, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_753)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_754, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_754, `Seq(input, input_754, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_754)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_755, r ), err ) ) -> Trx_runtime.Ok(((input_755, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_752, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_752, `Seq(input, input_752, ((__1)::([])))), ((Trx_runtime.emptyError) (input_752))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_CodeRange", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_CodeRange_err) (input) (res)) ; res)
)
let rec try_Trxparse_DOLLAR = 
#236 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DOLLAR_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('$')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'$'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_740, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_740)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_741, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_741, `Seq(input, input_741, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_741)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_DOLLAR", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DOLLAR_err) (input) (res)) ; res)
)
let rec try_Trxparse_BEGIN = 
#221 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('{'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('{'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "{{"))) ) else ( None )) (input) ("\"{{\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_791, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_791, `Seq(input, input_791, ((__1)::([])))), ((Trx_runtime.emptyError) (input_791))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_BEGIN", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))
let rec try_Trxparse_BEGIn = 
#223 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('{'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('|'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "{|"))) ) else ( None )) (input) ("\"{|\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_790, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_790, `Seq(input, input_790, ((__1)::([])))), ((Trx_runtime.emptyError) (input_790))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_BEGIn", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))
let rec try_Trxparse_END = 
#222 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_END_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('}'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('}'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "}}"))) ) else ( None )) (input) ("\"}}\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_681, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_681)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_682, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_682, `Seq(input, input_682, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_682)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_END", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_END_err) (input) (res)) ; res)
)
let rec try_Trxparse_ENd = 
#224 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_ENd_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('|'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('}'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "|}"))) ) else ( None )) (input) ("\"|}\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_679, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_679)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_680, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_680, `Seq(input, input_680, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_680)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_ENd", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_ENd_err) (input) (res)) ; res)
)
let rec try_Trxparse_StoppableCode = 
#158 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_StoppableCode_err) (input))
) with
Not_found -> let res = (match (match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('!'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "!!"))) ) else ( None )) (input) ("\"!!\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_503, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_503)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_504, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_504, `Seq(input, input_504, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_504)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_505, r ), err ) ) -> Trx_runtime.Ok(((input_505, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_502, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_502, `Seq(input, input_502, ((__1)::([])))), ((Trx_runtime.emptyError) (input_502))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_StoppableCode", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_StoppableCode_err) (input) (res)) ; res)
)
let rec try_Trxparse_DefaultCode = 
#163 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DefaultCode_err) (input))
) with
Not_found -> let res = (match (match (match (match (match (try_Trxparse_BEGIn (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_732, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_732, `Seq(input, input_732, ((__1)::([])))), ((Trx_runtime.emptyError) (input_732))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_720, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_720)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_721, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_StoppableCode (_filename) (_text) (input_721)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_722, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_CodeRange (_filename) (_text) (input_722)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_723, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.while_primary (false) ((fun input_728 -> (match (match (try_Trxparse_ENd (_filename) (_text) (input_728)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_731, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_731, `Seq(input_728, input_731, ((__1)::([])))), ((Trx_runtime.emptyError) (input_731))))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_729 = input_728 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_729) (_len)) ) then ( let c = ((_get_char) (input_729)) in
Some((((succ) (input_729)), `Class(c))) ) else ( None )) (input_729) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_730, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_730, `Seq(input_728, input_730, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_730)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_723)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_727, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_727, `Seq(input_723, input_727, ((__1)::([])))), ((Trx_runtime.emptyError) (input_727))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_724, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_ENd (_filename) (_text) (input_724)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_726, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_726, `Seq(input_724, input_726, ((__1)::([])))), ((Trx_runtime.emptyError) (input_726))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_725, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_725, `Seq(input, input_725, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ])), ((Trx_runtime.emptyError) (input_725)))))))))))))))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_719, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_719, `Seq(input, input_719, ((__1)::([])))), ((Trx_runtime.emptyError) (input_719))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Trxparse_BEGIN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_718, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_718, `Seq(input, input_718, ((__1)::([])))), ((Trx_runtime.emptyError) (input_718))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_706, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_706)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_707, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_StoppableCode (_filename) (_text) (input_707)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_708, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_CodeRange (_filename) (_text) (input_708)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_709, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.while_primary (false) ((fun input_714 -> (match (match (try_Trxparse_END (_filename) (_text) (input_714)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_717, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_717, `Seq(input_714, input_717, ((__1)::([])))), ((Trx_runtime.emptyError) (input_717))))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_715 = input_714 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_715) (_len)) ) then ( let c = ((_get_char) (input_715)) in
Some((((succ) (input_715)), `Class(c))) ) else ( None )) (input_715) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_716, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_716, `Seq(input_714, input_716, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_716)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_709)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_713, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_713, `Seq(input_709, input_713, ((__1)::([])))), ((Trx_runtime.emptyError) (input_713))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_710, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_END (_filename) (_text) (input_710)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_712, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_712, `Seq(input_710, input_712, ((__1)::([])))), ((Trx_runtime.emptyError) (input_712))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_711, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_711, `Seq(input, input_711, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ])), ((Trx_runtime.emptyError) (input_711)))))))))))))))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_705, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_705, `Seq(input, input_705, ((__1)::([])))), ((Trx_runtime.emptyError) (input_705)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_DefaultCode", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DefaultCode_err) (input) (res)) ; res)
)
let rec try_Trxparse_Code = 
#167 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Code_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (try_Trxparse_DefaultCode (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_765, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_765, `Seq(input, input_765, ((__1)::([])))), ((Trx_runtime.emptyError) (input_765))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('$'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('_'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "$_"))) ) else ( None )) (input) ("\"$_\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_762, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_CodeRange (_filename) (_text) (input_762)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_763, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_763)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_764, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_764, `Seq(input, input_764, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_764))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('$'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "$:"))) ) else ( None )) (input) ("\"$:\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_757, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.while_primary (true) ((fun input_761 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_761) (_len)) ) then ( let c = ((_get_char) (input_761)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_761)), `Class(c))) ) else ( None ) ) else ( None )) (input_761) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_757)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Plus(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_760, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_760, `Seq(input_757, input_760, ((__1)::([])))), ((Trx_runtime.emptyError) (input_760))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_758, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_758)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_759, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_759, `Seq(input, input_759, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_759))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_DOLLAR (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_756, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_756, `Seq(input, input_756, ((__1)::([])))), ((Trx_runtime.emptyError) (input_756)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Code", Some(("rule production")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<rule production>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Code_err) (input) (res)) ; res)
)
let rec try_Trxparse_Prefix = 
#174 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Prefix_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (try_Trxparse_PrefixElement (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_549, r ), err ) ) -> Trx_runtime.Ok(((input_549, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_548, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_548, `Seq(input, input_548, ((__1)::([])))), ((Trx_runtime.emptyError) (input_548))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Prefix", Some(("element's prefix")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<element's prefix>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Prefix_err) (input) (res)) ; res)
)
let rec try_Trxparse_CLOSE = 
#234 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_CLOSE_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (')')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("')'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_786, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_786)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_787, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_787, `Seq(input, input_787, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_787)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_CLOSE", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_CLOSE_err) (input) (res)) ; res)
)
let rec try_Trxparse_Range = 
#210 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Range_err) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_Char (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_522, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_522) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_522) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input_522) (1)), `Literal(input_522, "-"))) ) else ( None )) (input_522) ("\"-\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_523, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Char (_filename) (_text) (input_523)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_524, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_524, `Seq(input, input_524, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_524))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Char (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_521, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_521, `Seq(input, input_521, ((__1)::([])))), ((Trx_runtime.emptyError) (input_521)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Range", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Range_err) (input) (res)) ; res)
)
let rec try_Trxparse_Class = 
#206 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Class_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('['))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "["))) ) else ( None )) (input) ("\"[\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_766, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_766) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_766) (0))))) ('^'))) (true)))) ) then ( Some(((((+)) (input_766) (1)), `Literal(input_766, "^"))) ) else ( None )) (input_766) ("\"^\"")) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_766, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_774, r ), err ) ) -> Trx_runtime.Ok(((input_774, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_767, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_771 -> (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_771) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_771) (0))))) (']'))) (true)))) ) then ( Some(((((+)) (input_771) (1)), `Literal(input_771, "]"))) ) else ( None )) (input_771) ("\"]\"")) with
Trx_runtime.Fail ( ( err ) ) -> let input_772 = input_771 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Range (_filename) (_text) (input_772)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_773, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_773, `Seq(input_771, input_773, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_773)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_767)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_768, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_768) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_768) (0))))) (']'))) (true)))) ) then ( Some(((((+)) (input_768) (1)), `Literal(input_768, "]"))) ) else ( None )) (input_768) ("\"]\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_769, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_769)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_770, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_770, `Seq(input, input_770, [ __1 ; __2 ; __3 ; __4 ; __5 ])), ((Trx_runtime.emptyError) (input_770))))))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Class", Some(("class of symbols")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<class of symbols>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Class_err) (input) (res)) ; res)
)
let rec try_Trxparse_DOT = 
#235 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DOT_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_738, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_738)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_739, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_739, `Seq(input, input_739, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_739)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_DOT", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DOT_err) (input) (res)) ; res)
)
let rec try_Trxparse_COMMA = 
#239 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_COMMA_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (',')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("','")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_782, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_782)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_783, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_783, `Seq(input, input_783, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_783)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_COMMA", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_COMMA_err) (input) (res)) ; res)
)
let rec try_Trxparse_OPEN = 
#233 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_OPEN_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('(')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'('")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_559, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_559)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_560, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_560, `Seq(input, input_560, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_560)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_OPEN", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_OPEN_err) (input) (res)) ; res)
)
let rec try_Trxparse_Module = 
#194 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Module_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("['A'-'Z']")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_574, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_576 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_576) (_len)) ) then ( let c = ((_get_char) (input_576)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input_576)), `Class(c))) ) else ( None ) ) else ( None )) (input_576) ([ Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])))) (input_574)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_575, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_575, `Seq(input, input_575, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_575)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Module", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Module_err) (input) (res)) ; res)
)
let rec try_Trxparse_Name = 
#195 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Name_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((=)) (c) ('_')))))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_569, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_571 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_571) (_len)) ) then ( let c = ((_get_char) (input_571)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input_571)), `Class(c))) ) else ( None ) ) else ( None )) (input_571) ([ Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])))) (input_569)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_570, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_570, `Seq(input, input_570, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_570)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Name", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Name_err) (input) (res)) ; res)
)
let rec try_Trxparse_Identifier = 
#198 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Identifier_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (match (try_Trxparse_Module (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_612, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_612) (_len)) ) then ( let c = ((_get_char) (input_612)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_612)), `Class(c))) ) else ( None ) ) else ( None )) (input_612) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_613, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Name (_filename) (_text) (input_613)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_614, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_614, `Seq(input, input_614, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_614))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Name (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_611, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_611, `Seq(input, input_611, ((__1)::([])))), ((Trx_runtime.emptyError) (input_611)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_609, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_609)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_610, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_610, `Seq(input, input_610, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_610)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Identifier", Some(("identifier")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<identifier>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Identifier_err) (input) (res)) ; res)
)
let rec try_Trxparse_LEFTARROW = 
#225 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_LEFTARROW_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "<-"))) ) else ( None )) (input) ("\"<-\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_594, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_594)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_595, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_595, `Seq(input, input_595, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_595)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_LEFTARROW", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_LEFTARROW_err) (input) (res)) ; res)
)
let rec try_Trxparse_TILDE = 
#237 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_TILDE_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('~')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'~'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_495, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_495)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_496, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_496, `Seq(input, input_496, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_496)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_TILDE", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_TILDE_err) (input) (res)) ; res)
)
let rec try_Trxparse_PLUS = 
#232 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_PLUS_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('+')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'+'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_550, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_550)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_551, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_551, `Seq(input, input_551, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_551)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_PLUS", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_PLUS_err) (input) (res)) ; res)
)
let rec try_Trxparse_QUESTION = 
#230 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_QUESTION_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('?')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'?'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_529, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_529)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_530, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_530, `Seq(input, input_530, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_530)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_QUESTION", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_QUESTION_err) (input) (res)) ; res)
)
let rec try_Trxparse_STAR = 
#231 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_STAR_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('*')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'*'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_515, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_515)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_516, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_516, `Seq(input, input_516, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_516)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_STAR", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_STAR_err) (input) (res)) ; res)
)
let rec try_Trxparse_SuffixElement = 
#173 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_SuffixElement_err) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_QUESTION (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_499, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_499, `Seq(input, input_499, ((__1)::([])))), ((Trx_runtime.emptyError) (input_499))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_STAR (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_498, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_498, `Seq(input, input_498, ((__1)::([])))), ((Trx_runtime.emptyError) (input_498))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_PLUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_497, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_497, `Seq(input, input_497, ((__1)::([])))), ((Trx_runtime.emptyError) (input_497)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_SuffixElement", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_SuffixElement_err) (input) (res)) ; res)
)
let rec try_Trxparse_Suffix = 
#176 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Suffix_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (try_Trxparse_SuffixElement (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_501, r ), err ) ) -> Trx_runtime.Ok(((input_501, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_500, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_500, `Seq(input, input_500, ((__1)::([])))), ((Trx_runtime.emptyError) (input_500))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Suffix", Some(("element's suffix")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<element's suffix>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Suffix_err) (input) (res)) ; res)
)
let rec try_Trxparse_Expression = 
#134 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Expression_err) (input))
) with
Not_found -> let res = (Trx_runtime.setMainConstruct ((match (match (match (try_Trxparse_SLASH (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_672, r ), err ) ) -> Trx_runtime.Ok(((input_672, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_666, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Sequence (_filename) (_text) (input_666)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_667, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_669 -> (match (try_Trxparse_SLASH (_filename) (_text) (input_669)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_670, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Sequence (_filename) (_text) (input_670)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_671, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_671, `Seq(input_669, input_671, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_671)))))))))))) (input_667)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_668, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_668, `Seq(input, input_668, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_668))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Expression", Some(("rule body")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (Trx_runtime.Expected(("<rule body>")))) in
(Hashtbl.add (memo_Trxparse_Expression_err) (input) (res)) ; res)
)
and try_Trxparse_Sequence = 
#145 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Sequence_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (try_Trxparse_item_list (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_512, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_Code (_filename) (_text) (input_512)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_512, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_514, r ), err ) ) -> Trx_runtime.Ok(((input_514, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_513, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_513, `Seq(input, input_513, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_513)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Sequence", Some(("a sequence of parsing expressions")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<a sequence of parsing expressions>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Sequence_err) (input) (res)) ; res)
)
and try_Trxparse_Primary = 
#178 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Primary_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (try_Trxparse_Identifier (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_544, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_LEFTARROW (_filename) (_text) (input_544)) with
Trx_runtime.Fail ( ( err ) ) -> let input_545 = input_544 in
let __2 = `Not in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_545, `Seq(input, input_545, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_545))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_OPEN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_539, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_EQUAL (_filename) (_text) (input_539)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_540, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Identifier (_filename) (_text) (input_540)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_541, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Exprs (_filename) (_text) (input_541)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_542, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_CLOSE (_filename) (_text) (input_542)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_543, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_543, `Seq(input, input_543, [ __1 ; __2 ; __3 ; __4 ; __5 ])), ((Trx_runtime.emptyError) (input_543))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_OPEN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_536, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Expression (_filename) (_text) (input_536)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_537, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_CLOSE (_filename) (_text) (input_537)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_538, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_538, `Seq(input, input_538, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_538))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_Literal (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_533, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_TILDE (_filename) (_text) (input_533)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_533, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_535, r ), err ) ) -> Trx_runtime.Ok(((input_535, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_534, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_534, `Seq(input, input_534, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_534)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_Class (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_532, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_532, `Seq(input, input_532, ((__1)::([])))), ((Trx_runtime.emptyError) (input_532))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_DOT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_531, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_531, `Seq(input, input_531, ((__1)::([])))), ((Trx_runtime.emptyError) (input_531)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Primary", Some(("parsing element")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<parsing element>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Primary_err) (input) (res)) ; res)
)
and try_Trxparse_Exprs = 
#106 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Exprs_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (try_Trxparse_OPEN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_659, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Expression (_filename) (_text) (input_659)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_660, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_663 -> (match (try_Trxparse_COMMA (_filename) (_text) (input_663)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_664, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Expression (_filename) (_text) (input_664)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_665, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_665, `Seq(input_663, input_665, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_665)))))))))))) (input_660)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_661, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_CLOSE (_filename) (_text) (input_661)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_662, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_662, `Seq(input, input_662, [ __1 ; __2 ; __3 ; __4 ])), ((Trx_runtime.emptyError) (input_662)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_OPEN (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> let input_657 = input in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Expression (_filename) (_text) (input_657)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_658, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_658, `Seq(input, input_658, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_658)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Exprs", Some(("list of expressions")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<list of expressions>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Exprs_err) (input) (res)) ; res)
)
and try_Trxparse_item_list = 
#137 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_item_list_err) (input))
) with
Not_found -> let res = (match (match (match (Trx_runtime.while_primary (true) ((fun input_439 -> (match (try_Trxparse_Prefix (_filename) (_text) (input_439)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_440, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Primary (_filename) (_text) (input_440)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_441, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Suffix (_filename) (_text) (input_441)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_442, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Trxparse_Spacing (_filename) (_text) (input_442)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_444, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_444) (_len)) ) then ( let c = ((_get_char) (input_444)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input_444)), `Class(c))) ) else ( None ) ) else ( None )) (input_444) (((Trx_runtime.Expected(("':'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_445, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_445) (_len)) ) then ( let c = ((_get_char) (input_445)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input_445)), `Class(c))) ) else ( None ) ) else ( None )) (input_445) (((Trx_runtime.Expected(("'_'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_445, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_450, r ), err ) ) -> Trx_runtime.Ok(((input_450, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_446, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_446)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_447, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_mlvar (_filename) (_text) (input_447)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_448, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_448)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_449, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_449, `Seq(input_442, input_449, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ])), ((Trx_runtime.emptyError) (input_449)))))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_442, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_451, r ), err ) ) -> Trx_runtime.Ok(((input_451, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_443, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_443, `Seq(input_439, input_443, [ __1 ; __2 ; __3 ; __4 ])), ((Trx_runtime.emptyError) (input_443)))))))))))))))))) (input)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Plus(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_438, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_438, `Seq(input, input_438, ((__1)::([])))), ((Trx_runtime.emptyError) (input_438))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_item_list", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_item_list_err) (input) (res)) ; res)
)
let rec try_Trxparse_LET = 
#243 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_LET_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), `Literal(input, "let"))) ) else ( None )) (input) ("\"let\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_592, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_592)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_593, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_593, `Seq(input, input_593, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_593)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_LET", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_LET_err) (input) (res)) ; res)
)
let rec try_Trxparse_SEMI = 
#240 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_SEMI_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (';')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("';'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_519, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_519)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_520, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_520, `Seq(input, input_520, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_520)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_SEMI", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_SEMI_err) (input) (res)) ; res)
)
let rec try_Trxparse_construct_name_secondary = 
#81 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_construct_name_secondary_err) (input))
) with
Not_found -> let res = (match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "/*"))) ) else ( None )) (input) ("\"/*\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_466, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_466, `Seq(input, input_466, ((__1)::([])))), ((Trx_runtime.emptyError) (input_466))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_452, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_452)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_453, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.while_primary (false) ((fun input_460 -> (match (match (try_Trxparse_Spacing (_filename) (_text) (input_460)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_463, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_463) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_463) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_463) (1))))) ('/'))) (true)))))) ) then ( Some(((((+)) (input_463) (2)), `Literal(input_463, "*/"))) ) else ( None )) (input_463) ("\"*/\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_465, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_465, `Seq(input_463, input_465, ((__1)::([])))), ((Trx_runtime.emptyError) (input_465))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_464, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_464, `Seq(input_460, input_464, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_464)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_461 = input_460 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_461) (_len)) ) then ( let c = ((_get_char) (input_461)) in
Some((((succ) (input_461)), `Class(c))) ) else ( None )) (input_461) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_462, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_462, `Seq(input_460, input_462, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_462)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_453)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_459, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_459, `Seq(input_453, input_459, ((__1)::([])))), ((Trx_runtime.emptyError) (input_459))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_454, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_454)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_455, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_455) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_455) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_455) (1))))) ('/'))) (true)))))) ) then ( Some(((((+)) (input_455) (2)), `Literal(input_455, "*/"))) ) else ( None )) (input_455) ("\"*/\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_458, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_458, `Seq(input_455, input_458, ((__1)::([])))), ((Trx_runtime.emptyError) (input_458))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_456, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_456)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_457, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_457, `Seq(input, input_457, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ])), ((Trx_runtime.emptyError) (input_457)))))))))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_construct_name_secondary", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_construct_name_secondary_err) (input) (res)) ; res)
)
let rec try_Trxparse_construct_name_opt = 
#83 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_construct_name_opt_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (try_Trxparse_construct_name_primary (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_483, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_483, `Seq(input, input_483, ((__1)::([])))), ((Trx_runtime.emptyError) (input_483))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_construct_name_secondary (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_482, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_482, `Seq(input, input_482, ((__1)::([])))), ((Trx_runtime.emptyError) (input_482)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_construct_name_opt", Some(("optional rule name")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<optional rule name>")))::([])))) in
(Hashtbl.add (memo_Trxparse_construct_name_opt_err) (input) (res)) ; res)
)
let rec try_Trxparse_rule_annots = 
#96 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_rule_annots_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (match (try_Trxparse_construct_name_opt (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_406, r ), err ) ) -> Trx_runtime.Ok(((input_406, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_403, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_memo_opt (_filename) (_text) (input_403)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_403, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_405, r ), err ) ) -> Trx_runtime.Ok(((input_405, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_404, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_404, `Seq(input, input_404, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_404)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_rule_annots", Some(("rule annotations")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<rule annotations>")))::([])))) in
(Hashtbl.add (memo_Trxparse_rule_annots_err) (input) (res)) ; res)
)
let rec try_Trxparse_Function = 
#110 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Function_err) (input))
) with
Not_found -> let res = (Trx_runtime.setMainConstruct ((match (match (try_Trxparse_rule_annots (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_638, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_LET (_filename) (_text) (input_638)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_639, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Identifier (_filename) (_text) (input_639)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_640, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (true) ((fun input_646 -> (try_Trxparse_Identifier (_filename) (_text) (input_646)))) (input_640)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Plus(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_641, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_EQUAL (_filename) (_text) (input_641)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_642, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Expression (_filename) (_text) (input_642)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_643, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_SEMI (_filename) (_text) (input_643)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_643, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_645, r ), err ) ) -> Trx_runtime.Ok(((input_645, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_644, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_644, `Seq(input, input_644, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ; __7 ])), ((Trx_runtime.emptyError) (input_644))))))))))))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Function", Some(("TRX function")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (Trx_runtime.Expected(("<TRX function>")))) in
(Hashtbl.add (memo_Trxparse_Function_err) (input) (res)) ; res)
)
let rec try_Trxparse_KEEP_CACHE = 
#217 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_KEEP_CACHE_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('>'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (8)), `Literal(input, "<icache>"))) ) else ( None )) (input) ("\"<icache>\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_598, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_598)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_599, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_599, `Seq(input, input_599, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_599)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_KEEP_CACHE", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_KEEP_CACHE_err) (input) (res)) ; res)
)
let rec try_Trxparse_LBRACE_noerr = 
#219 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_LBRACE) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('{'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "{"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_199, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_199)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_200, __2 ) ) -> Some((input_200, `Seq(input, input_200, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_LBRACE", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_LBRACE) (input) (res)) ; res)
)
let rec try_Trxparse_DefaultCodeNoStop_noerr = 
#165 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DefaultCodeNoStop) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_BEGIN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_301, __1 ) ) -> (match (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_305 -> (match (try_Trxparse_END_noerr (_filename) (_text) (input_305)) with
None -> let input_306 = input_305 in
let __1 = `Not in
(match if ( (((<)) (input_306) (_len)) ) then ( let c = ((_get_char) (input_306)) in
Some((((succ) (input_306)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_307, __2 ) ) -> Some((input_307, `Seq(input_305, input_307, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_301)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_304, __1 ) ) -> Some((input_304, `Seq(input_301, input_304, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_302, __2 ) ) -> (match (try_Trxparse_END_noerr (_filename) (_text) (input_302)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_303, __3 ) ) -> Some((input_303, `Seq(input, input_303, [ __1 ; __2 ; __3 ])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_DefaultCodeNoStop", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DefaultCodeNoStop) (input) (res)) ; res)
)
let rec try_Trxparse_HeaderCode_noerr = 
#150 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_HeaderCode) (input))
) with
Not_found -> let res = (match (match if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('y'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) (':'))) (true)))))))))))) ) then ( Some(((((+)) (input) (6)), `Literal((((+)) (input) (6)), "types:"))) ) else ( Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), ""))) )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) (':'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (7)), `Literal((((+)) (input) (7)), "inside:"))) ) else ( Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), ""))) )
| 'd' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) (':'))) (true)))))))))))) ) then ( Some(((((+)) (input) (6)), `Literal((((+)) (input) (6)), "decls:"))) ) else ( Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), ""))) )
| _ -> Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), "")))) ) else ( Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), ""))) ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_218, __1 ) ) -> (match (try_Trxparse_DefaultCodeNoStop_noerr (_filename) (_text) (input_218)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_219, __2 ) ) -> Some((input_219, `Seq(input, input_219, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_HeaderCode", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_HeaderCode) (input) (res)) ; res)
)
let rec try_Trxparse_LET_noerr = 
#243 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_LET) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), `Literal(input, "let"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_195, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_195)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_196, __2 ) ) -> Some((input_196, `Seq(input, input_196, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_LET", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_LET) (input) (res)) ; res)
)
let rec try_Trxparse_construct_name_primary_noerr = 
#80 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_construct_name_primary) (input))
) with
Not_found -> let res = (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('*'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), `Literal(input, "/**"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_84, __1 ) ) -> Some((input_84, `Seq(input, input_84, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_70, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_70)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_71, __2 ) ) -> (match (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_78 -> (match (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_78)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_81, __1 ) ) -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_81) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_81) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_81) (1))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_81) (2))))) ('/'))) (true)))))))) ) then ( Some(((((+)) (input_81) (3)), `Literal(input_81, "**/"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_83, __1 ) ) -> Some((input_83, `Seq(input_81, input_83, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_82, __2 ) ) -> Some((input_82, `Seq(input_78, input_82, [ __1 ; __2 ]))))) with
None -> let input_79 = input_78 in
let __1 = `Not in
(match if ( (((<)) (input_79) (_len)) ) then ( let c = ((_get_char) (input_79)) in
Some((((succ) (input_79)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_80, __2 ) ) -> Some((input_80, `Seq(input_78, input_80, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_71)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_77, __1 ) ) -> Some((input_77, `Seq(input_71, input_77, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_72, __3 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_72)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_73, __4 ) ) -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_73) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_73) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_73) (1))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_73) (2))))) ('/'))) (true)))))))) ) then ( Some(((((+)) (input_73) (3)), `Literal(input_73, "**/"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_76, __1 ) ) -> Some((input_76, `Seq(input_73, input_76, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_74, __5 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_74)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_75, __6 ) ) -> Some((input_75, `Seq(input, input_75, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ]))))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_construct_name_primary", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_construct_name_primary) (input) (res)) ; res)
)
let rec try_Trxparse_construct_name_secondary_noerr = 
#81 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_construct_name_secondary) (input))
) with
Not_found -> let res = (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "/*"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_69, __1 ) ) -> Some((input_69, `Seq(input, input_69, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_55, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_55)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_56, __2 ) ) -> (match (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_63 -> (match (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_63)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_66, __1 ) ) -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_66) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_66) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_66) (1))))) ('/'))) (true)))))) ) then ( Some(((((+)) (input_66) (2)), `Literal(input_66, "*/"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_68, __1 ) ) -> Some((input_68, `Seq(input_66, input_68, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_67, __2 ) ) -> Some((input_67, `Seq(input_63, input_67, [ __1 ; __2 ]))))) with
None -> let input_64 = input_63 in
let __1 = `Not in
(match if ( (((<)) (input_64) (_len)) ) then ( let c = ((_get_char) (input_64)) in
Some((((succ) (input_64)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_65, __2 ) ) -> Some((input_65, `Seq(input_63, input_65, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_56)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_62, __1 ) ) -> Some((input_62, `Seq(input_56, input_62, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_57, __3 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_57)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_58, __4 ) ) -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_58) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_58) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_58) (1))))) ('/'))) (true)))))) ) then ( Some(((((+)) (input_58) (2)), `Literal(input_58, "*/"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_61, __1 ) ) -> Some((input_61, `Seq(input_58, input_61, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_59, __5 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_59)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_60, __6 ) ) -> Some((input_60, `Seq(input, input_60, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ]))))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_construct_name_secondary", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_construct_name_secondary) (input) (res)) ; res)
)
let rec try_Trxparse_construct_name_opt_noerr = 
#83 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_construct_name_opt) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_construct_name_primary_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_86, __1 ) ) -> Some((input_86, `Seq(input, input_86, ((__1)::([])))))) with
None -> (match (try_Trxparse_construct_name_secondary_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_85, __1 ) ) -> Some((input_85, `Seq(input, input_85, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_construct_name_opt", Some(("optional rule name")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_construct_name_opt) (input) (res)) ; res)
)
let rec try_Trxparse_DEBUG = 
#218 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('%')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'%'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_742, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_742, `Seq(input, input_742, ((__1)::([])))), ((Trx_runtime.emptyError) (input_742))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_DEBUG", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))
let rec try_Trxparse_DefExpr = 
#103 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DefExpr_err) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_LEFTARROW (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_736, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Expression (_filename) (_text) (input_736)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_737, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_737, `Seq(input, input_737, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_737)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_EQUAL (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_733, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Identifier (_filename) (_text) (input_733)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_734, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Exprs (_filename) (_text) (input_734)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_735, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_735, `Seq(input, input_735, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_735)))))))))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_DefExpr", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DefExpr_err) (input) (res)) ; res)
)
let rec try_Trxparse_MARK = 
#216 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('+')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'+'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_577, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_577, `Seq(input, input_577, ((__1)::([])))), ((Trx_runtime.emptyError) (input_577))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_MARK", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))
let rec try_Trxparse_Definition = 
#62 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Definition_err) (input))
) with
Not_found -> let res = (Trx_runtime.setMainConstruct ((match (match (match (try_Trxparse_SEMI (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_697, r ), err ) ) -> Trx_runtime.Ok(((input_697, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_683, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_rule_annots (_filename) (_text) (input_683)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_684, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_KEEP_CACHE (_filename) (_text) (input_684)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_684, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_696, r ), err ) ) -> Trx_runtime.Ok(((input_696, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_685, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_DEBUG (_filename) (_text) (input_685)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_685, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_695, r ), err ) ) -> Trx_runtime.Ok(((input_695, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_686, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_MARK (_filename) (_text) (input_686)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_686, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_694, r ), err ) ) -> Trx_runtime.Ok(((input_694, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_687, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Identifier (_filename) (_text) (input_687)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_688, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_Type (_filename) (_text) (input_688)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_688, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_693, r ), err ) ) -> Trx_runtime.Ok(((input_693, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_689, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_DefExpr (_filename) (_text) (input_689)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_690, __8 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_SEMI (_filename) (_text) (input_690)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_690, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_692, r ), err ) ) -> Trx_runtime.Ok(((input_692, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_691, __9 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_691, `Seq(input, input_691, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ; __7 ; __8 ; __9 ])), ((Trx_runtime.emptyError) (input_691))))))))))))))))))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Definition", Some(("TRX rule")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (Trx_runtime.Expected(("<TRX rule>")))) in
(Hashtbl.add (memo_Trxparse_Definition_err) (input) (res)) ; res)
)
let rec try_Trxparse_DefaultCodeNoStop = 
#165 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DefaultCodeNoStop_err) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_BEGIN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_698, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.while_primary (false) ((fun input_702 -> (match (try_Trxparse_END (_filename) (_text) (input_702)) with
Trx_runtime.Fail ( ( err ) ) -> let input_703 = input_702 in
let __1 = `Not in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_703) (_len)) ) then ( let c = ((_get_char) (input_703)) in
Some((((succ) (input_703)), `Class(c))) ) else ( None )) (input_703) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_704, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_704, `Seq(input_702, input_704, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_704)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_698)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_701, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_701, `Seq(input_698, input_701, ((__1)::([])))), ((Trx_runtime.emptyError) (input_701))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_699, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_END (_filename) (_text) (input_699)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_700, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_700, `Seq(input, input_700, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_700))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_DefaultCodeNoStop", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DefaultCodeNoStop_err) (input) (res)) ; res)
)
let rec try_Trxparse_HeaderCode = 
#150 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_HeaderCode_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_msg (if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('y'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) (':'))) (true)))))))))))) ) then ( Some(((((+)) (input) (6)), `Literal((((+)) (input) (6)), "types:"))) ) else ( Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), ""))) )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) (':'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (7)), `Literal((((+)) (input) (7)), "inside:"))) ) else ( Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), ""))) )
| 'd' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) (':'))) (true)))))))))))) ) then ( Some(((((+)) (input) (6)), `Literal((((+)) (input) (6)), "decls:"))) ) else ( Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), ""))) )
| _ -> Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), "")))) ) else ( Some(((((+)) (input) (0)), `Literal((((+)) (input) (0)), ""))) )) (input) ("\"\" or \"decls:\" or \"types:\" or \"inside:\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_615, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_DefaultCodeNoStop (_filename) (_text) (input_615)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_616, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_616, `Seq(input, input_616, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_616)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_HeaderCode", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_HeaderCode_err) (input) (res)) ; res)
)
let rec try_Trxparse_Names = 
#196 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Names_err) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_OPEN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_561, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_564 -> (match (try_Trxparse_Name (_filename) (_text) (input_564)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_565, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_565)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_566, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_COMMA (_filename) (_text) (input_566)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_566, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_568, r ), err ) ) -> Trx_runtime.Ok(((input_568, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_567, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_567, `Seq(input_564, input_567, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_567))))))))))))))) (input_561)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_562, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_CLOSE (_filename) (_text) (input_562)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_563, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_563, `Seq(input, input_563, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_563))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Names", None, res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Names_err) (input) (res)) ; res)
)
let rec try_Trxparse_IncludeRead = 
#115 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_IncludeRead_err) (input))
) with
Not_found -> let res = (Trx_runtime.setMainConstruct ((match (match (Trx_runtime.option_to_res_msg (if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'r' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (4)), `Literal((((+)) (input) (4)), "read"))) ) else ( None )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (7)), `Literal((((+)) (input) (7)), "include"))) ) else ( None )
| _ -> None) ) else ( None )) (input) ("\"read\" or \"include\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_600, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_600)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_601, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Filename (_filename) (_text) (input_601)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_602, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_602)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_603, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_603) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_603) (0))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_603) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_603) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_603) (3))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_603) (4))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_603) (5))))) ('l'))) (true)))))))))))))) ) then ( Some(((((+)) (input_603) (6)), `Literal(input_603, "global"))) ) else ( None )) (input_603) ("\"global\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_605, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_605)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_606, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Names (_filename) (_text) (input_606)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_607, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_607, `Seq(input_603, input_607, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_607))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_603, `Option(None)), err))
| Trx_runtime.Ok ( ( ( input_608, r ), err ) ) -> Trx_runtime.Ok(((input_608, `Option(Some((r)))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_604, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_604, `Seq(input, input_604, [ __1 ; __2 ; __3 ; __4 ; __5 ])), ((Trx_runtime.emptyError) (input_604))))))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_IncludeRead", Some(("include directive")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (Trx_runtime.Expected(("<include directive>")))) in
(Hashtbl.add (memo_Trxparse_IncludeRead_err) (input) (res)) ; res)
)
let rec try_Trxparse_optionType = 
#129 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_optionType_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("['a'-'z']")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_407, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_409 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_409) (_len)) ) then ( let c = ((_get_char) (input_409)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((||)) ((((=)) (c) ('_'))) ((((=)) (c) ('-')))))))))) ) then ( Some((((succ) (input_409)), `Class(c))) ) else ( None ) ) else ( None )) (input_409) ([ Trx_runtime.Expected(("'-'")) ; Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])))) (input_407)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Star(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_408, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_408, `Seq(input, input_408, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_408)))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_optionType", Some(("TRX option name")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<TRX option name>")))::([])))) in
(Hashtbl.add (memo_Trxparse_optionType_err) (input) (res)) ; res)
)
let rec try_Trxparse_Option = 
#124 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Option_err) (input))
) with
Not_found -> let res = (Trx_runtime.decorateConstruct ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('%'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('%'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "%%"))) ) else ( None )) (input) ("\"%%\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_552, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_optionType (_filename) (_text) (input_552)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_553, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_553)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_554, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_554) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_554) (0))))) ('='))) (true)))) ) then ( Some(((((+)) (input_554) (1)), `Literal(input_554, "="))) ) else ( None )) (input_554) ("\"=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_555, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_555)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_556, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_mlvar (_filename) (_text) (input_556)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_557, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input_557)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_558, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_558, `Seq(input, input_558, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ; __7 ])), ((Trx_runtime.emptyError) (input_558))))))))))))))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Option", Some(("TRX option")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (((Trx_runtime.Expected(("<TRX option>")))::([])))) in
(Hashtbl.add (memo_Trxparse_Option_err) (input) (res)) ; res)
)
let rec try_Trxparse_GElems = 
#35 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_GElems_err) (input))
) with
Not_found -> let res = (Trx_runtime.setMainConstruct ((match (match (match (try_Trxparse_IncludeRead (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_631, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_GElems (_filename) (_text) (input_631)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_632, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_632, `Seq(input, input_632, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_632)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_Extra (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_629, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_GElems (_filename) (_text) (input_629)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_630, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_630, `Seq(input, input_630, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_630)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_Option (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_627, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_GElems (_filename) (_text) (input_627)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_628, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_628, `Seq(input, input_628, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_628)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_HeaderCode (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_625, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_GElems (_filename) (_text) (input_625)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_626, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_626, `Seq(input, input_626, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_626)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_Function (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_623, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_GElems (_filename) (_text) (input_623)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_624, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_624, `Seq(input, input_624, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_624)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Trxparse_Definition (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_621, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_GElems (_filename) (_text) (input_621)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_622, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_622, `Seq(input, input_622, [ __1 ; __2 ])), ((Trx_runtime.emptyError) (input_622)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_Spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_620, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_620, `Seq(input, input_620, ((__1)::([])))), ((Trx_runtime.emptyError) (input_620)))))))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var))))
| ok -> (match ok with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Choice(res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_GElems", Some(("list of TRX elements")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (Trx_runtime.Expected(("<list of TRX elements>")))) in
(Hashtbl.add (memo_Trxparse_GElems_err) (input) (res)) ; res)
)
let rec try_Trxparse_Grammar = 
#32 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Grammar_err) (input))
) with
Not_found -> let res = (Trx_runtime.setMainConstruct ((match (match (try_Trxparse_Spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_617, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_GElems (_filename) (_text) (input_617)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_618, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Trxparse_EOF (_filename) (_text) (input_618)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_619, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_619, `Seq(input, input_619, [ __1 ; __2 ; __3 ])), ((Trx_runtime.emptyError) (input_619))))))))))))) with
Trx_runtime.Ok ( ( ( pos, res ), err ) ) -> Trx_runtime.Ok(((pos, `Rule(input, pos, "Trxparse_Grammar", Some(("TRX grammar")), res)), err))
| ( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var)) (input) (Trx_runtime.Expected(("<TRX grammar>")))) in
(Hashtbl.add (memo_Trxparse_Grammar_err) (input) (res)) ; res)
)
let rec try_Trxparse_RBRACE_noerr = 
#220 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_RBRACE) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('}'))) (true)))) ) then ( Some(((((+)) (input) (1)), `Literal(input, "}"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_130, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_130)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_131, __2 ) ) -> Some((input_131, `Seq(input, input_131, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_RBRACE", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_RBRACE) (input) (res)) ; res)
)
let rec try_Trxparse_Type_noerr = 
#119 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Type) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_87, __1 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_87) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_87) (0))))) (':'))) (true)))) ) then ( Some(((((+)) (input_87) (1)), `Literal(input_87, ":"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_88, __2 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_88)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_89, __3 ) ) -> (match (try_Trxparse_LBRACE_noerr (_filename) (_text) (input_89)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_90, __4 ) ) -> (match (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_95 -> (match (try_Trxparse_RBRACE_noerr (_filename) (_text) (input_95)) with
None -> let input_96 = input_95 in
let __1 = `Not in
(match if ( (((<)) (input_96) (_len)) ) then ( let c = ((_get_char) (input_96)) in
Some((((succ) (input_96)), `Class(c))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_97, __2 ) ) -> Some((input_97, `Seq(input_95, input_97, [ __1 ; __2 ]))))
| Some ( ( _, _ ) ) -> None))) (input_90)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_94, __1 ) ) -> Some((input_94, `Seq(input_90, input_94, ((__1)::([])))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_91, __5 ) ) -> (match (try_Trxparse_RBRACE_noerr (_filename) (_text) (input_91)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_92, __6 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_92)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_93, __7 ) ) -> Some((input_93, `Seq(input, input_93, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ; __7 ])))))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Type", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Type) (input) (res)) ; res)
)
let rec try_Trxparse_memo_opt_noerr = 
#87 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_memo_opt) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('{'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('$'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "{$"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_28, __1 ) ) -> (match if ( (((<)) ((((+)) (input_28) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input_28) (0)))) with
'S' -> Some(((((+)) (input_28) (1)), `Literal((((+)) (input_28) (1)), "S")))
| 'F' -> Some(((((+)) (input_28) (1)), `Literal((((+)) (input_28) (1)), "F")))
| '1' -> Some(((((+)) (input_28) (1)), `Literal((((+)) (input_28) (1)), "1")))
| '0' -> Some(((((+)) (input_28) (1)), `Literal((((+)) (input_28) (1)), "0")))
| _ -> None) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_29, __2 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_29) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_29) (0))))) ('}'))) (true)))) ) then ( Some(((((+)) (input_29) (1)), `Literal(input_29, "}"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_30, __3 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_30)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_31, __4 ) ) -> Some((input_31, `Seq(input, input_31, [ __1 ; __2 ; __3 ; __4 ]))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_memo_opt", Some(("memoization annotation")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_memo_opt) (input) (res)) ; res)
)
let rec try_Trxparse_rule_annots_noerr = 
#96 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_rule_annots) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_construct_name_opt_noerr (_filename) (_text) (input)) with
None -> Some((input, `Option(None)))
| Some ( ( input_9, r ) ) -> Some((input_9, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_6, __1 ) ) -> (match (match (try_Trxparse_memo_opt_noerr (_filename) (_text) (input_6)) with
None -> Some((input_6, `Option(None)))
| Some ( ( input_8, r ) ) -> Some((input_8, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_7, __2 ) ) -> Some((input_7, `Seq(input, input_7, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_rule_annots", Some(("rule annotations")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_rule_annots) (input) (res)) ; res)
)
let rec try_Trxparse_SEMI_noerr = 
#240 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_SEMI) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (';')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_122, __1 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_122)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_123, __2 ) ) -> Some((input_123, `Seq(input, input_123, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_SEMI", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_SEMI) (input) (res)) ; res)
)
let rec try_Trxparse_Function_noerr = 
#110 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Function) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_rule_annots_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_241, __1 ) ) -> (match (try_Trxparse_LET_noerr (_filename) (_text) (input_241)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_242, __2 ) ) -> (match (try_Trxparse_Identifier_noerr (_filename) (_text) (input_242)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_243, __3 ) ) -> (match (match (Trx_runtime.while_primary_noerr (true) ((fun input_249 -> (try_Trxparse_Identifier_noerr (_filename) (_text) (input_249)))) (input_243)) with
Some ( ( pos, res ) ) -> Some((pos, `Plus(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_244, __4 ) ) -> (match (try_Trxparse_EQUAL_noerr (_filename) (_text) (input_244)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_245, __5 ) ) -> (match (try_Trxparse_Expression_noerr (_filename) (_text) (input_245)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_246, __6 ) ) -> (match (match (try_Trxparse_SEMI_noerr (_filename) (_text) (input_246)) with
None -> Some((input_246, `Option(None)))
| Some ( ( input_248, r ) ) -> Some((input_248, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_247, __7 ) ) -> Some((input_247, `Seq(input, input_247, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ; __7 ])))))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Function", Some(("TRX function")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Function) (input) (res)) ; res)
)
let rec try_Trxparse_DEBUG_noerr = 
#218 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('%')) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_345, __1 ) ) -> Some((input_345, `Seq(input, input_345, ((__1)::([])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_DEBUG", None, res)))
| ( None ) as __pat_var -> __pat_var))
let rec try_Trxparse_Extra_noerr = 
#121 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Extra) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('x'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('a'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), `Literal(input, "extra"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_255, __1 ) ) -> (match (try_Trxparse_Space_noerr (_filename) (_text) (input_255)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_256, __2 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_256)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_257, __3 ) ) -> (match (try_Trxparse_mlvar_noerr (_filename) (_text) (input_257)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_258, __4 ) ) -> (match (try_Trxparse_Type_noerr (_filename) (_text) (input_258)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_259, __5 ) ) -> Some((input_259, `Seq(input, input_259, [ __1 ; __2 ; __3 ; __4 ; __5 ])))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Extra", Some(("extra directive")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Extra) (input) (res)) ; res)
)
let rec try_Trxparse_optionType_noerr = 
#129 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_optionType) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z')))) ) then ( Some((((succ) (input)), `Class(c))) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_10, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_12 -> if ( (((<)) (input_12) (_len)) ) then ( let c = ((_get_char) (input_12)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((||)) ((((=)) (c) ('_'))) ((((=)) (c) ('-')))))))))) ) then ( Some((((succ) (input_12)), `Class(c))) ) else ( None ) ) else ( None ))) (input_10)) with
Some ( ( pos, res ) ) -> Some((pos, `Star(res)))
| ( None ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_11, __2 ) ) -> Some((input_11, `Seq(input, input_11, [ __1 ; __2 ]))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_optionType", Some(("TRX option name")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_optionType) (input) (res)) ; res)
)
let rec try_Trxparse_Option_noerr = 
#124 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Option) (input))
) with
Not_found -> let res = (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('%'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('%'))) (true)))))) ) then ( Some(((((+)) (input) (2)), `Literal(input, "%%"))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_155, __1 ) ) -> (match (try_Trxparse_optionType_noerr (_filename) (_text) (input_155)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_156, __2 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_156)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_157, __3 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_157) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_157) (0))))) ('='))) (true)))) ) then ( Some(((((+)) (input_157) (1)), `Literal(input_157, "="))) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_158, __4 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_158)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_159, __5 ) ) -> (match (try_Trxparse_mlvar_noerr (_filename) (_text) (input_159)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_160, __6 ) ) -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input_160)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_161, __7 ) ) -> Some((input_161, `Seq(input, input_161, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ; __7 ])))))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Option", Some(("TRX option")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Option) (input) (res)) ; res)
)
let rec try_Trxparse_DefExpr_noerr = 
#103 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_DefExpr) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_LEFTARROW_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_339, __1 ) ) -> (match (try_Trxparse_Expression_noerr (_filename) (_text) (input_339)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_340, __2 ) ) -> Some((input_340, `Seq(input, input_340, [ __1 ; __2 ]))))) with
None -> (match (try_Trxparse_EQUAL_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_336, __1 ) ) -> (match (try_Trxparse_Identifier_noerr (_filename) (_text) (input_336)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_337, __2 ) ) -> (match (try_Trxparse_Exprs_noerr (_filename) (_text) (input_337)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_338, __3 ) ) -> Some((input_338, `Seq(input, input_338, [ __1 ; __2 ; __3 ]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_DefExpr", None, res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_DefExpr) (input) (res)) ; res)
)
let rec try_Trxparse_Definition_noerr = 
#62 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Definition) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_SEMI_noerr (_filename) (_text) (input)) with
None -> Some((input, `Option(None)))
| Some ( ( input_300, r ) ) -> Some((input_300, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_286, __1 ) ) -> (match (try_Trxparse_rule_annots_noerr (_filename) (_text) (input_286)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_287, __2 ) ) -> (match (match (try_Trxparse_KEEP_CACHE_noerr (_filename) (_text) (input_287)) with
None -> Some((input_287, `Option(None)))
| Some ( ( input_299, r ) ) -> Some((input_299, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_288, __3 ) ) -> (match (match (try_Trxparse_DEBUG_noerr (_filename) (_text) (input_288)) with
None -> Some((input_288, `Option(None)))
| Some ( ( input_298, r ) ) -> Some((input_298, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_289, __4 ) ) -> (match (match (try_Trxparse_MARK_noerr (_filename) (_text) (input_289)) with
None -> Some((input_289, `Option(None)))
| Some ( ( input_297, r ) ) -> Some((input_297, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_290, __5 ) ) -> (match (try_Trxparse_Identifier_noerr (_filename) (_text) (input_290)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_291, __6 ) ) -> (match (match (try_Trxparse_Type_noerr (_filename) (_text) (input_291)) with
None -> Some((input_291, `Option(None)))
| Some ( ( input_296, r ) ) -> Some((input_296, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_292, __7 ) ) -> (match (try_Trxparse_DefExpr_noerr (_filename) (_text) (input_292)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_293, __8 ) ) -> (match (match (try_Trxparse_SEMI_noerr (_filename) (_text) (input_293)) with
None -> Some((input_293, `Option(None)))
| Some ( ( input_295, r ) ) -> Some((input_295, `Option(Some((r)))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_294, __9 ) ) -> Some((input_294, `Seq(input, input_294, [ __1 ; __2 ; __3 ; __4 ; __5 ; __6 ; __7 ; __8 ; __9 ])))))))))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Definition", Some(("TRX rule")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Definition) (input) (res)) ; res)
)
let rec try_Trxparse_GElems_noerr = 
#35 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_GElems) (input))
) with
Not_found -> let res = (match (match (match (try_Trxparse_IncludeRead_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_234, __1 ) ) -> (match (try_Trxparse_GElems_noerr (_filename) (_text) (input_234)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_235, __2 ) ) -> Some((input_235, `Seq(input, input_235, [ __1 ; __2 ]))))) with
None -> (match (match (try_Trxparse_Extra_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_232, __1 ) ) -> (match (try_Trxparse_GElems_noerr (_filename) (_text) (input_232)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_233, __2 ) ) -> Some((input_233, `Seq(input, input_233, [ __1 ; __2 ]))))) with
None -> (match (match (try_Trxparse_Option_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_230, __1 ) ) -> (match (try_Trxparse_GElems_noerr (_filename) (_text) (input_230)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_231, __2 ) ) -> Some((input_231, `Seq(input, input_231, [ __1 ; __2 ]))))) with
None -> (match (match (try_Trxparse_HeaderCode_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_228, __1 ) ) -> (match (try_Trxparse_GElems_noerr (_filename) (_text) (input_228)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_229, __2 ) ) -> Some((input_229, `Seq(input, input_229, [ __1 ; __2 ]))))) with
None -> (match (match (try_Trxparse_Function_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_226, __1 ) ) -> (match (try_Trxparse_GElems_noerr (_filename) (_text) (input_226)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_227, __2 ) ) -> Some((input_227, `Seq(input, input_227, [ __1 ; __2 ]))))) with
None -> (match (match (try_Trxparse_Definition_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_224, __1 ) ) -> (match (try_Trxparse_GElems_noerr (_filename) (_text) (input_224)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_225, __2 ) ) -> Some((input_225, `Seq(input, input_225, [ __1 ; __2 ]))))) with
None -> (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_223, __1 ) ) -> Some((input_223, `Seq(input, input_223, ((__1)::([]))))))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var))
| ok -> (match ok with
Some ( ( pos, res ) ) -> Some((pos, `Choice(res)))
| ( None ) as __pat_var -> __pat_var)) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_GElems", Some(("list of TRX elements")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_GElems) (input) (res)) ; res)
)
let rec try_Trxparse_Grammar_noerr = 
#32 "trxparse.trx"
(fun _filename _text input -> let _len = ((R_.length) (_text))
and _get_char = ((R_.get) (_text))
and _get_sub = ((R_.sub) (_text)) in
(try (
(Hashtbl.find (memo_Trxparse_Grammar) (input))
) with
Not_found -> let res = (match (match (try_Trxparse_Spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_220, __1 ) ) -> (match (try_Trxparse_GElems_noerr (_filename) (_text) (input_220)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_221, __2 ) ) -> (match (try_Trxparse_EOF_noerr (_filename) (_text) (input_221)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_222, __3 ) ) -> Some((input_222, `Seq(input, input_222, [ __1 ; __2 ; __3 ])))))) with
Some ( ( pos, res ) ) -> Some((pos, `Rule(input, pos, "Trxparse_Grammar", Some(("TRX grammar")), res)))
| ( None ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Trxparse_Grammar) (input) (res)) ; res)
)
let parse_trxparse_grammar ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Trxparse_Grammar_noerr) (_filename))) (((try_Trxparse_Grammar) (_filename))) (((R_.make) (_text))) (_start))
end
