open Base

#20 "xparse.trx"
 
open Base
open Xml 

let _grammar_rules = [ ("Xparse_value", None) ; ("Xparse_underscore", None) ; ("Xparse_times", None) ; ("Xparse_tilde_", None) ; ("Xparse_text", None) ; ("Xparse_strint64", None) ; ("Xparse_strint", None) ; ("Xparse_stringsinglequote", None) ; ("Xparse_stringsinglechar", None) ; ("Xparse_stringquote", None) ; ("Xparse_stringnosp", None) ; ("Xparse_stringcharspecial", None) ; ("Xparse_stringchar", None) ; ("Xparse_string", None) ; ("Xparse_strfloat", None) ; ("Xparse_strbool", None) ; ("Xparse_str_ipaddr", None) ; ("Xparse_spacing", None) ; ("Xparse_space", None) ; ("Xparse_slash", None) ; ("Xparse_singlequotechar_", None) ; ("Xparse_sharpcomment", None) ; ("Xparse_sharp", None) ; ("Xparse_sglexpr", None) ; ("Xparse_semi", None) ; ("Xparse_rparen", None) ; ("Xparse_rightarrow", None) ; ("Xparse_rbracket", None) ; ("Xparse_raccol", None) ; ("Xparse_quote", None) ; ("Xparse_question_", None) ; ("Xparse_question", None) ; ("Xparse_plus", None) ; ("Xparse_parexprnosp", None) ; ("Xparse_parexprexcluded", None) ; ("Xparse_parexpr", None) ; ("Xparse_option", None) ; ("Xparse_open", None) ; ("Xparse_nsname", None) ; ("Xparse_name", None) ; ("Xparse_mlcomment", None) ; ("Xparse_mlCOMMENTSTOP", None) ; ("Xparse_mlCOMMENTSTART", None) ; ("Xparse_lparen", None) ; ("Xparse_leftarrow", None) ; ("Xparse_lbracket", None) ; ("Xparse_laccol", None) ; ("Xparse_int64", None) ; ("Xparse_int3", None) ; ("Xparse_int", None) ; ("Xparse_humanint", None) ; ("Xparse_hexa", None) ; ("Xparse_header", None) ; ("Xparse_function", None) ; ("Xparse_funclist", None) ; ("Xparse_float", None) ; ("Xparse_file", None) ; ("Xparse_extra_header", None) ; ("Xparse_equal", None) ; ("Xparse_eol", None) ; ("Xparse_eof", None) ; ("Xparse_element", None) ; ("Xparse_dot", None) ; ("Xparse_dblq", None) ; ("Xparse_dblexpr", None) ; ("Xparse_content_item", None) ; ("Xparse_content", None) ; ("Xparse_commentstop", None) ; ("Xparse_commentstart", None) ; ("Xparse_comment", None) ; ("Xparse_comma", None) ; ("Xparse_colon", None) ; ("Xparse_close", None) ; ("Xparse_charsinglequote", None) ; ("Xparse_char", None) ; ("Xparse_cdata", None) ; ("Xparse_bracketexprcontent", None) ; ("Xparse_bracketexpr", None) ; ("Xparse_bool", None) ; ("Xparse_bar", None) ; ("Xparse_bang", None) ; ("Xparse_at", None) ; ("Xparse_accolexprcontent", None) ; ("Xparse_accolexpr", None) ]
let parse_with f_noerr f_err _text _start = let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (f_noerr (_text) (_start)) with
Some ( ( pos, res ) ) -> (pos, res)
| None -> (match (f_err (_text) (_start)) with
Trx_runtime.Ok ( ( ( _, _ ), _ ) ) -> (assert false)
| Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.gen_syntax_error (((FilePos.get_pos_no_cache) (_text))) (err))))
let memo_Xparse_cdata = ((Hashtbl.create) (128))
let memo_Xparse_cdata_err = ((Hashtbl.create) (128))
let memo_Xparse_char = ((Hashtbl.create) (128))
let memo_Xparse_char_err = ((Hashtbl.create) (128))
let memo_Xparse_close = ((Hashtbl.create) (128))
let memo_Xparse_close_err = ((Hashtbl.create) (128))
let memo_Xparse_comment = ((Hashtbl.create) (128))
let memo_Xparse_comment_err = ((Hashtbl.create) (128))
let memo_Xparse_content = ((Hashtbl.create) (128))
let memo_Xparse_content_err = ((Hashtbl.create) (128))
let memo_Xparse_content_item = ((Hashtbl.create) (128))
let memo_Xparse_content_item_err = ((Hashtbl.create) (128))
let memo_Xparse_dblexpr = ((Hashtbl.create) (128))
let memo_Xparse_dblexpr_err = ((Hashtbl.create) (128))
let memo_Xparse_element = ((Hashtbl.create) (128))
let memo_Xparse_element_err = ((Hashtbl.create) (128))
let memo_Xparse_equal = ((Hashtbl.create) (128))
let memo_Xparse_equal_err = ((Hashtbl.create) (128))
let memo_Xparse_extra_header = ((Hashtbl.create) (128))
let memo_Xparse_extra_header_err = ((Hashtbl.create) (128))
let memo_Xparse_file = ((Hashtbl.create) (128))
let memo_Xparse_file_err = ((Hashtbl.create) (128))
let memo_Xparse_function = ((Hashtbl.create) (128))
let memo_Xparse_function_err = ((Hashtbl.create) (128))
let memo_Xparse_header = ((Hashtbl.create) (128))
let memo_Xparse_header_err = ((Hashtbl.create) (128))
let memo_Xparse_int = ((Hashtbl.create) (128))
let memo_Xparse_int_err = ((Hashtbl.create) (128))
let memo_Xparse_lparen = ((Hashtbl.create) (128))
let memo_Xparse_lparen_err = ((Hashtbl.create) (128))
let memo_Xparse_name = ((Hashtbl.create) (128))
let memo_Xparse_name_err = ((Hashtbl.create) (128))
let memo_Xparse_nsname = ((Hashtbl.create) (128))
let memo_Xparse_nsname_err = ((Hashtbl.create) (128))
let memo_Xparse_open = ((Hashtbl.create) (128))
let memo_Xparse_open_err = ((Hashtbl.create) (128))
let memo_Xparse_option = ((Hashtbl.create) (128))
let memo_Xparse_option_err = ((Hashtbl.create) (128))
let memo_Xparse_rparen = ((Hashtbl.create) (128))
let memo_Xparse_rparen_err = ((Hashtbl.create) (128))
let memo_Xparse_sglexpr = ((Hashtbl.create) (128))
let memo_Xparse_sglexpr_err = ((Hashtbl.create) (128))
let memo_Xparse_slash = ((Hashtbl.create) (128))
let memo_Xparse_slash_err = ((Hashtbl.create) (128))
let memo_Xparse_spacing = ((Hashtbl.create) (128))
let memo_Xparse_spacing_err = ((Hashtbl.create) (128))
let memo_Xparse_strint = ((Hashtbl.create) (128))
let memo_Xparse_strint_err = ((Hashtbl.create) (128))
let memo_Xparse_text = ((Hashtbl.create) (128))
let memo_Xparse_text_err = ((Hashtbl.create) (128))
let memo_Xparse_value = ((Hashtbl.create) (128))
let memo_Xparse_value_err = ((Hashtbl.create) (128))
let prepare_cache () = ((Hashtbl.clear) (memo_Xparse_cdata)) ; ((Hashtbl.clear) (memo_Xparse_cdata_err)) ; ((Hashtbl.clear) (memo_Xparse_char)) ; ((Hashtbl.clear) (memo_Xparse_char_err)) ; ((Hashtbl.clear) (memo_Xparse_close)) ; ((Hashtbl.clear) (memo_Xparse_close_err)) ; ((Hashtbl.clear) (memo_Xparse_comment)) ; ((Hashtbl.clear) (memo_Xparse_comment_err)) ; ((Hashtbl.clear) (memo_Xparse_content)) ; ((Hashtbl.clear) (memo_Xparse_content_err)) ; ((Hashtbl.clear) (memo_Xparse_content_item)) ; ((Hashtbl.clear) (memo_Xparse_content_item_err)) ; ((Hashtbl.clear) (memo_Xparse_dblexpr)) ; ((Hashtbl.clear) (memo_Xparse_dblexpr_err)) ; ((Hashtbl.clear) (memo_Xparse_element)) ; ((Hashtbl.clear) (memo_Xparse_element_err)) ; ((Hashtbl.clear) (memo_Xparse_equal)) ; ((Hashtbl.clear) (memo_Xparse_equal_err)) ; ((Hashtbl.clear) (memo_Xparse_extra_header)) ; ((Hashtbl.clear) (memo_Xparse_extra_header_err)) ; ((Hashtbl.clear) (memo_Xparse_file)) ; ((Hashtbl.clear) (memo_Xparse_file_err)) ; ((Hashtbl.clear) (memo_Xparse_function)) ; ((Hashtbl.clear) (memo_Xparse_function_err)) ; ((Hashtbl.clear) (memo_Xparse_header)) ; ((Hashtbl.clear) (memo_Xparse_header_err)) ; ((Hashtbl.clear) (memo_Xparse_int)) ; ((Hashtbl.clear) (memo_Xparse_int_err)) ; ((Hashtbl.clear) (memo_Xparse_lparen)) ; ((Hashtbl.clear) (memo_Xparse_lparen_err)) ; ((Hashtbl.clear) (memo_Xparse_name)) ; ((Hashtbl.clear) (memo_Xparse_name_err)) ; ((Hashtbl.clear) (memo_Xparse_nsname)) ; ((Hashtbl.clear) (memo_Xparse_nsname_err)) ; ((Hashtbl.clear) (memo_Xparse_open)) ; ((Hashtbl.clear) (memo_Xparse_open_err)) ; ((Hashtbl.clear) (memo_Xparse_option)) ; ((Hashtbl.clear) (memo_Xparse_option_err)) ; ((Hashtbl.clear) (memo_Xparse_rparen)) ; ((Hashtbl.clear) (memo_Xparse_rparen_err)) ; ((Hashtbl.clear) (memo_Xparse_sglexpr)) ; ((Hashtbl.clear) (memo_Xparse_sglexpr_err)) ; ((Hashtbl.clear) (memo_Xparse_slash)) ; ((Hashtbl.clear) (memo_Xparse_slash_err)) ; ((Hashtbl.clear) (memo_Xparse_spacing)) ; ((Hashtbl.clear) (memo_Xparse_spacing_err)) ; ((Hashtbl.clear) (memo_Xparse_strint)) ; ((Hashtbl.clear) (memo_Xparse_strint_err)) ; ((Hashtbl.clear) (memo_Xparse_text)) ; ((Hashtbl.clear) (memo_Xparse_text_err)) ; ((Hashtbl.clear) (memo_Xparse_value)) ; ((Hashtbl.clear) (memo_Xparse_value_err))
let rec try_Xparse_commentstart = 
#83 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('-'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "<!--")) ) else ( None )) (input) ("\"<!--\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_573, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_573, __1), ((Trx_runtime.emptyError) (input_573))))))))
let rec try_Xparse_commentstop = 
#84 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('>'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "-->")) ) else ( None )) (input) ("\"-->\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_572, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_572, __1), ((Trx_runtime.emptyError) (input_572))))))))
let rec try_Xparse_comment = 
#82 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_comment_err) (input))
) with
Not_found -> let res = (match (try_Xparse_commentstart (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_574, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_577 -> (match (try_Xparse_commentstop (_filename) (_text) (input_577)) with
Trx_runtime.Fail ( ( err ) ) -> let input_578 = input_577 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_578) (_len)) ) then ( let c = ((_get_char) (input_578)) in
Some((((succ) (input_578)), c)) ) else ( None )) (input_578) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_579, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_579, __2), ((Trx_runtime.emptyError) (input_579)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_574)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_575, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_commentstop (_filename) (_text) (input_575)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_576, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_576, ( () )), ((Trx_runtime.emptyError) (input_576))))))))))))) in
(Hashtbl.add (memo_Xparse_comment_err) (input) (res)) ; res)
)
let rec try_Xparse_space = 
#20 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) (' '))) ((((||)) ((((=)) (c) ('\n'))) ((((||)) ((((=)) (c) ('\r'))) ((((=)) (c) ('\t')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'\t'")) ; Trx_runtime.Expected(("'\n'")) ; Trx_runtime.Expected(("'\r'")) ; Trx_runtime.Expected(("' '")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_391, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_391, __1), ((Trx_runtime.emptyError) (input_391))))))))
let rec try_Xparse_spacing = 
#85 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_spacing_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_388 -> (match (match (try_Xparse_space (_filename) (_text) (input_388)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_390, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_390, ( () )), ((Trx_runtime.emptyError) (input_390))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_comment (_filename) (_text) (input_388)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_389, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_389, __1), ((Trx_runtime.emptyError) (input_389)))))))))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_387, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_387, ( () )), ((Trx_runtime.emptyError) (input_387))))))) in
(Hashtbl.add (memo_Xparse_spacing_err) (input) (res)) ; res)
)
let rec try_Xparse_equal = 
#62 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_equal_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('=')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'='")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_533, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_533)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_534, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_534, ( () )), ((Trx_runtime.emptyError) (input_534)))))))))) in
(Hashtbl.add (memo_Xparse_equal_err) (input) (res)) ; res)
)
let rec try_Xparse_dblq = 
#79 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\"'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_556, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_556, __1), ((Trx_runtime.emptyError) (input_556))))))))
let rec try_Xparse_dblexpr = 
#67 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_dblexpr_err) (input))
) with
Not_found -> let res = (match (try_Xparse_dblq (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_557, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_561 -> (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_561) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_561) (0))))) ('\\'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_561) (1))))) ('"'))) (true)))))) ) then ( Some(((((+)) (input_561) (2)), "\\\"")) ) else ( None )) (input_561) ("\"\\\"\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_564, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_564, 
#67 "xparse.trx"
( '\"'  )), ((Trx_runtime.emptyError) (input_564))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_dblq (_filename) (_text) (input_561)) with
Trx_runtime.Fail ( ( err ) ) -> let input_562 = input_561 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_562) (_len)) ) then ( let c = ((_get_char) (input_562)) in
Some((((succ) (input_562)), c)) ) else ( None )) (input_562) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_563, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_563, __2), ((Trx_runtime.emptyError) (input_563)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| ( _ok ) as __pat_var -> __pat_var))) (input_557)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_558, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_dblq (_filename) (_text) (input_558)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_559, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_559)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_560, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_560, 
#67 "xparse.trx"
( Tgrammar.string_of_chars __2  )), ((Trx_runtime.emptyError) (input_560)))))))))))))))) in
(Hashtbl.add (memo_Xparse_dblexpr_err) (input) (res)) ; res)
)
let rec try_Xparse_name = 
#55 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_name_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary (true) ((fun input_471 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_471) (_len)) ) then ( let c = ((_get_char) (input_471)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((||)) ((((=)) (c) ('_'))) ((((=)) (c) ('-')))))))))) ) then ( Some((((succ) (input_471)), c)) ) else ( None ) ) else ( None )) (input_471) ([ Trx_runtime.Expected(("'-'")) ; Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_469, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_469)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_470, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_470, 
#55 "xparse.trx"
( Tgrammar.string_of_chars __1  )), ((Trx_runtime.emptyError) (input_470)))))))))) in
(Hashtbl.add (memo_Xparse_name_err) (input) (res)) ; res)
)
let rec try_Xparse_quote = 
#80 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_423, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_423, __1), ((Trx_runtime.emptyError) (input_423))))))))
let rec try_Xparse_sglexpr = 
#68 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_sglexpr_err) (input))
) with
Not_found -> let res = (match (try_Xparse_quote (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_405, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_409 -> (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_409) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_409) (0))))) ('\\'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_409) (1))))) ('\''))) (true)))))) ) then ( Some(((((+)) (input_409) (2)), "\\'")) ) else ( None )) (input_409) ("\"\\'\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_412, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_412, 
#68 "xparse.trx"
( '\''  )), ((Trx_runtime.emptyError) (input_412))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_quote (_filename) (_text) (input_409)) with
Trx_runtime.Fail ( ( err ) ) -> let input_410 = input_409 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_410) (_len)) ) then ( let c = ((_get_char) (input_410)) in
Some((((succ) (input_410)), c)) ) else ( None )) (input_410) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_411, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_411, __2), ((Trx_runtime.emptyError) (input_411)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| ( _ok ) as __pat_var -> __pat_var))) (input_405)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_406, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_quote (_filename) (_text) (input_406)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_407, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_407)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_408, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_408, 
#68 "xparse.trx"
( Tgrammar.string_of_chars __2  )), ((Trx_runtime.emptyError) (input_408)))))))))))))))) in
(Hashtbl.add (memo_Xparse_sglexpr_err) (input) (res)) ; res)
)
let rec try_Xparse_value = 
#66 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_value_err) (input))
) with
Not_found -> let res = (match (match (try_Xparse_dblexpr (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_319, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_319, __1), ((Trx_runtime.emptyError) (input_319))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Xparse_sglexpr (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_318, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_318, __1), ((Trx_runtime.emptyError) (input_318))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_name (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_317, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_317, __1), ((Trx_runtime.emptyError) (input_317)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_value_err) (input) (res)) ; res)
)
let rec try_Xparse_function = 
#74 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_function_err) (input))
) with
Not_found -> let res = (match (try_Xparse_value (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_514, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_514, 
#75 "xparse.trx"
( Value __1  )), ((Trx_runtime.emptyError) (input_514))))))) in
(Hashtbl.add (memo_Xparse_function_err) (input) (res)) ; res)
)
let rec try_Xparse_lparen = 
#69 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_lparen_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('(')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'('")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_482, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_482)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_483, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_483, ( () )), ((Trx_runtime.emptyError) (input_483)))))))))) in
(Hashtbl.add (memo_Xparse_lparen_err) (input) (res)) ; res)
)
let rec try_Xparse_nsname = 
#64 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_nsname_err) (input))
) with
Not_found -> let res = (match (try_Xparse_name (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_464, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_464) (_len)) ) then ( let c = ((_get_char) (input_464)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input_464)), c)) ) else ( None ) ) else ( None )) (input_464) (((Trx_runtime.Expected(("':'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_466, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_name (_filename) (_text) (input_466)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_467, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_467, ()), ((Trx_runtime.emptyError) (input_467)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_464, None), err))
| Trx_runtime.Ok ( ( ( input_468, r ), err ) ) -> Trx_runtime.Ok(((input_468, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_465, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_465, 
#64 "xparse.trx"
( __1 (* FIXME *)  )), ((Trx_runtime.emptyError) (input_465)))))))))) in
(Hashtbl.add (memo_Xparse_nsname_err) (input) (res)) ; res)
)
let rec try_Xparse_rparen = 
#70 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_rparen_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (')')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("')'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_415, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_415)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_416, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_416, ( () )), ((Trx_runtime.emptyError) (input_416)))))))))) in
(Hashtbl.add (memo_Xparse_rparen_err) (input) (res)) ; res)
)
let rec try_Xparse_option = 
#59 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_option_err) (input))
) with
Not_found -> let res = (match (match (try_Xparse_nsname (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_457, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Xparse_equal (_filename) (_text) (input_457)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_459, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_function (_filename) (_text) (input_459)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_460, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_460, 
#60 "xparse.trx"
( __2  )), ((Trx_runtime.emptyError) (input_460)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_457, None), err))
| Trx_runtime.Ok ( ( ( input_461, r ), err ) ) -> Trx_runtime.Ok(((input_461, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_458, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_458, 
#60 "xparse.trx"
( __1, match __2 with Some r -> r | None -> Value "true"  )), ((Trx_runtime.emptyError) (input_458)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('$')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'$'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_451, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_name (_filename) (_text) (input_451)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_452, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_452) (_len)) ) then ( let c = ((_get_char) (input_452)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input_452)), c)) ) else ( None ) ) else ( None )) (input_452) (((Trx_runtime.Expected(("':'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_453, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_lparen (_filename) (_text) (input_453)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_454, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_option (_filename) (_text) (input_454)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_455, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_rparen (_filename) (_text) (input_455)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_456, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_456, 
#61 "xparse.trx"
( __5  )), ((Trx_runtime.emptyError) (input_456))))))))))))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_option_err) (input) (res)) ; res)
)
let rec try_Xparse_cdata_noerr = 
#30 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_cdata) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('['))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('C'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('D'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('A'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('T'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('A'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('['))) (true)))))))))))))))))))) ) then ( Some(((((+)) (input) (9)), "<![CDATA[")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_287, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_291 -> (match if ( (((&&)) ((((<=)) ((((+)) (input_291) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_291) (0))))) (']'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_291) (1))))) (']'))) (true)))))) ) then ( Some(((((+)) (input_291) (2)), "]]")) ) else ( None ) with
None -> let input_292 = input_291 in
let __1 = () in
if ( (((<)) (input_292) (_len)) ) then ( let c = ((_get_char) (input_292)) in
Some((((succ) (input_292)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None))) (input_287)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_290, __1 ) ) -> Some((input_290, (_get_sub (input_287) ((((-)) (input_290) (input_287))))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_288, __2 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_288) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_288) (0))))) (']'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_288) (1))))) (']'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_288) (2))))) ('>'))) (true)))))))) ) then ( Some(((((+)) (input_288) (3)), "]]>")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_289, __3 ) ) -> Some((input_289, 
#30 "xparse.trx"
( `text __2  )))))) in
(Hashtbl.add (memo_Xparse_cdata) (input) (res)) ; res)
)
let rec try_Xparse_extra_header_noerr = 
#31 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_extra_header) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('!'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<!")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_209, __1 ) ) -> (match if ( (((<)) (input_209) (_len)) ) then ( let c = ((_get_char) (input_209)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input_209)), c)) ) else ( None ) ) else ( None ) with
None -> let input_210 = input_209 in
let __2 = () in
(match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_213 -> (match if ( (((<)) (input_213) (_len)) ) then ( let c = ((_get_char) (input_213)) in
if ( (((=)) (c) ('>')) ) then ( Some((((succ) (input_213)), c)) ) else ( None ) ) else ( None ) with
None -> let input_214 = input_213 in
let __1 = () in
if ( (((<)) (input_214) (_len)) ) then ( let c = ((_get_char) (input_214)) in
Some((((succ) (input_214)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None))) (input_210)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_211, __3 ) ) -> (match if ( (((<)) (input_211) (_len)) ) then ( let c = ((_get_char) (input_211)) in
if ( (((=)) (c) ('>')) ) then ( Some((((succ) (input_211)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_212, __4 ) ) -> Some((input_212, ( () )))))
| Some ( ( _, _ ) ) -> None)) in
(Hashtbl.add (memo_Xparse_extra_header) (input) (res)) ; res)
)
let rec try_Xparse_commentstart_noerr = 
#83 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('-'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "<!--")) ) else ( None ))
let rec try_Xparse_commentstop_noerr = 
#84 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('>'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "-->")) ) else ( None ))
let rec try_Xparse_comment_noerr = 
#82 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_comment) (input))
) with
Not_found -> let res = (match (try_Xparse_commentstart_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_257, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_260 -> (match (try_Xparse_commentstop_noerr (_filename) (_text) (input_260)) with
None -> let input_261 = input_260 in
let __1 = () in
if ( (((<)) (input_261) (_len)) ) then ( let c = ((_get_char) (input_261)) in
Some((((succ) (input_261)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None))) (input_257)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_258, __2 ) ) -> (match (try_Xparse_commentstop_noerr (_filename) (_text) (input_258)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_259, __3 ) ) -> Some((input_259, ( () )))))) in
(Hashtbl.add (memo_Xparse_comment) (input) (res)) ; res)
)
let rec try_Xparse_space_noerr = 
#20 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) (' '))) ((((||)) ((((=)) (c) ('\n'))) ((((||)) ((((=)) (c) ('\r'))) ((((=)) (c) ('\t')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let rec try_Xparse_spacing_noerr = 
#85 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_spacing) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_71 -> (match (match (try_Xparse_space_noerr (_filename) (_text) (input_71)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_73, __1 ) ) -> Some((input_73, ( () )))) with
None -> (try_Xparse_comment_noerr (_filename) (_text) (input_71))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_70, __1 ) ) -> Some((input_70, ( () )))) in
(Hashtbl.add (memo_Xparse_spacing) (input) (res)) ; res)
)
let rec try_Xparse_close_noerr = 
#78 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_close) (input))
) with
Not_found -> let res = (match (try_Xparse_spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_267, __1 ) ) -> (match if ( (((<)) (input_267) (_len)) ) then ( let c = ((_get_char) (input_267)) in
if ( (((=)) (c) ('>')) ) then ( Some((((succ) (input_267)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_268, __2 ) ) -> Some((input_268, ())))) in
(Hashtbl.add (memo_Xparse_close) (input) (res)) ; res)
)
let rec try_Xparse_name_noerr = 
#55 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_name) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr (true) ((fun input_154 -> if ( (((<)) (input_154) (_len)) ) then ( let c = ((_get_char) (input_154)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((||)) ((((=)) (c) ('_'))) ((((=)) (c) ('-')))))))))) ) then ( Some((((succ) (input_154)), c)) ) else ( None ) ) else ( None ))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_152, __1 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_152)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_153, __2 ) ) -> Some((input_153, 
#55 "xparse.trx"
( Tgrammar.string_of_chars __1  ))))) in
(Hashtbl.add (memo_Xparse_name) (input) (res)) ; res)
)
let rec try_Xparse_nsname_noerr = 
#64 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_nsname) (input))
) with
Not_found -> let res = (match (try_Xparse_name_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_147, __1 ) ) -> (match (match (match if ( (((<)) (input_147) (_len)) ) then ( let c = ((_get_char) (input_147)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input_147)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_149, __1 ) ) -> (match (try_Xparse_name_noerr (_filename) (_text) (input_149)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_150, __2 ) ) -> Some((input_150, ())))) with
None -> Some((input_147, None))
| Some ( ( input_151, r ) ) -> Some((input_151, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_148, __2 ) ) -> Some((input_148, 
#64 "xparse.trx"
( __1 (* FIXME *)  ))))) in
(Hashtbl.add (memo_Xparse_nsname) (input) (res)) ; res)
)
let rec try_Xparse_open_noerr = 
#77 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_open) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('<')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_145, __1 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_145)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_146, __2 ) ) -> Some((input_146, ())))) in
(Hashtbl.add (memo_Xparse_open) (input) (res)) ; res)
)
let rec try_Xparse_equal_noerr = 
#62 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_equal) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('=')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_216, __1 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_216)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_217, __2 ) ) -> Some((input_217, ( () ))))) in
(Hashtbl.add (memo_Xparse_equal) (input) (res)) ; res)
)
let rec try_Xparse_dblq_noerr = 
#79 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let rec try_Xparse_dblexpr_noerr = 
#67 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_dblexpr) (input))
) with
Not_found -> let res = (match (try_Xparse_dblq_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_240, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_244 -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_244) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_244) (0))))) ('\\'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_244) (1))))) ('"'))) (true)))))) ) then ( Some(((((+)) (input_244) (2)), "\\\"")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_247, __1 ) ) -> Some((input_247, 
#67 "xparse.trx"
( '\"'  )))) with
None -> (match (try_Xparse_dblq_noerr (_filename) (_text) (input_244)) with
None -> let input_245 = input_244 in
let __1 = () in
if ( (((<)) (input_245) (_len)) ) then ( let c = ((_get_char) (input_245)) in
Some((((succ) (input_245)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None)
| ( _ok ) as __pat_var -> __pat_var))) (input_240)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_241, __2 ) ) -> (match (try_Xparse_dblq_noerr (_filename) (_text) (input_241)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_242, __3 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_242)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_243, __4 ) ) -> Some((input_243, 
#67 "xparse.trx"
( Tgrammar.string_of_chars __2  ))))))) in
(Hashtbl.add (memo_Xparse_dblexpr) (input) (res)) ; res)
)
let rec try_Xparse_quote_noerr = 
#80 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let rec try_Xparse_sglexpr_noerr = 
#68 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_sglexpr) (input))
) with
Not_found -> let res = (match (try_Xparse_quote_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_88, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_92 -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_92) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_92) (0))))) ('\\'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_92) (1))))) ('\''))) (true)))))) ) then ( Some(((((+)) (input_92) (2)), "\\'")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_95, __1 ) ) -> Some((input_95, 
#68 "xparse.trx"
( '\''  )))) with
None -> (match (try_Xparse_quote_noerr (_filename) (_text) (input_92)) with
None -> let input_93 = input_92 in
let __1 = () in
if ( (((<)) (input_93) (_len)) ) then ( let c = ((_get_char) (input_93)) in
Some((((succ) (input_93)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None)
| ( _ok ) as __pat_var -> __pat_var))) (input_88)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_89, __2 ) ) -> (match (try_Xparse_quote_noerr (_filename) (_text) (input_89)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_90, __3 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_90)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_91, __4 ) ) -> Some((input_91, 
#68 "xparse.trx"
( Tgrammar.string_of_chars __2  ))))))) in
(Hashtbl.add (memo_Xparse_sglexpr) (input) (res)) ; res)
)
let rec try_Xparse_value_noerr = 
#66 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_value) (input))
) with
Not_found -> let res = (match (try_Xparse_dblexpr_noerr (_filename) (_text) (input)) with
None -> (match (try_Xparse_sglexpr_noerr (_filename) (_text) (input)) with
None -> (try_Xparse_name_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_value) (input) (res)) ; res)
)
let rec try_Xparse_function_noerr = 
#74 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_function) (input))
) with
Not_found -> let res = (match (try_Xparse_value_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_197, __1 ) ) -> Some((input_197, 
#75 "xparse.trx"
( Value __1  )))) in
(Hashtbl.add (memo_Xparse_function) (input) (res)) ; res)
)
let rec try_Xparse_lparen_noerr = 
#69 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_lparen) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('(')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_165, __1 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_165)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_166, __2 ) ) -> Some((input_166, ( () ))))) in
(Hashtbl.add (memo_Xparse_lparen) (input) (res)) ; res)
)
let rec try_Xparse_rparen_noerr = 
#70 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_rparen) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (')')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_98, __1 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_98)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_99, __2 ) ) -> Some((input_99, ( () ))))) in
(Hashtbl.add (memo_Xparse_rparen) (input) (res)) ; res)
)
let rec try_Xparse_option_noerr = 
#59 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_option) (input))
) with
Not_found -> let res = (match (match (try_Xparse_nsname_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_140, __1 ) ) -> (match (match (match (try_Xparse_equal_noerr (_filename) (_text) (input_140)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_142, __1 ) ) -> (match (try_Xparse_function_noerr (_filename) (_text) (input_142)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_143, __2 ) ) -> Some((input_143, 
#60 "xparse.trx"
( __2  ))))) with
None -> Some((input_140, None))
| Some ( ( input_144, r ) ) -> Some((input_144, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_141, __2 ) ) -> Some((input_141, 
#60 "xparse.trx"
( __1, match __2 with Some r -> r | None -> Value "true"  ))))) with
None -> (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('$')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_134, __1 ) ) -> (match (try_Xparse_name_noerr (_filename) (_text) (input_134)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_135, __2 ) ) -> (match if ( (((<)) (input_135) (_len)) ) then ( let c = ((_get_char) (input_135)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input_135)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_136, __3 ) ) -> (match (try_Xparse_lparen_noerr (_filename) (_text) (input_136)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_137, __4 ) ) -> (match (try_Xparse_option_noerr (_filename) (_text) (input_137)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_138, __5 ) ) -> (match (try_Xparse_rparen_noerr (_filename) (_text) (input_138)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_139, __6 ) ) -> Some((input_139, 
#61 "xparse.trx"
( __5  )))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_option) (input) (res)) ; res)
)
let rec try_Xparse_slash_noerr = 
#61 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_slash) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('/')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_75, __1 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_75)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_76, __2 ) ) -> Some((input_76, ( () ))))) in
(Hashtbl.add (memo_Xparse_slash) (input) (res)) ; res)
)
let rec try_Xparse_element_noerr = 
#36 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_element) (input))
) with
Not_found -> let res = (match (try_Xparse_open_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_221, __1 ) ) -> (match (match (match (try_Xparse_slash_noerr (_filename) (_text) (input_221)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_235, __1 ) ) -> (match (try_Xparse_nsname_noerr (_filename) (_text) (input_235)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_236, __2 ) ) -> Some((input_236, 
#38 "xparse.trx"
( `stop __2  ))))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_221) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_221) (0))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_221) (1))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_221) (2))))) ('-'))) (true)))))))) ) then ( Some(((((+)) (input_221) (3)), "!--")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_229, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_232 -> (match (try_Xparse_commentstop_noerr (_filename) (_text) (input_232)) with
None -> let input_233 = input_232 in
let __1 = () in
if ( (((<)) (input_233) (_len)) ) then ( let c = ((_get_char) (input_233)) in
Some((((succ) (input_233)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None))) (input_229)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_230, __2 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_230) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_230) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_230) (1))))) ('-'))) (true)))))) ) then ( Some(((((+)) (input_230) (2)), "--")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_231, __3 ) ) -> Some((input_231, 
#39 "xparse.trx"
( `nothing  )))))) with
None -> (match (try_Xparse_nsname_noerr (_filename) (_text) (input_221)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_224, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_228 -> (try_Xparse_option_noerr (_filename) (_text) (input_228)))) (input_224)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_225, __2 ) ) -> (match (match (try_Xparse_slash_noerr (_filename) (_text) (input_225)) with
None -> Some((input_225, None))
| Some ( ( input_227, r ) ) -> Some((input_227, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_226, __3 ) ) -> Some((input_226, 
#40 "xparse.trx"
( match __3 with Some _ -> `one (__1, __2) | _ -> `start (__1, __2)  ))))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_222, __2 ) ) -> (match (try_Xparse_close_noerr (_filename) (_text) (input_222)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_223, __3 ) ) -> Some((input_223, 
#41 "xparse.trx"
( __2  )))))) in
(Hashtbl.add (memo_Xparse_element) (input) (res)) ; res)
)
let rec try_Xparse_hexa_noerr = 
#19 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('F'))))) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('f')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let rec try_Xparse_strint_noerr = 
#94 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_strint) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> Some((input, None))
| Some ( ( input_19, r ) ) -> Some((input_19, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_16, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_18 -> if ( (((<)) (input_18) (_len)) ) then ( let c = ((_get_char) (input_18)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_18)), c)) ) else ( None ) ) else ( None ))) (input_16)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_17, __2 ) ) -> Some((input_17, (_get_sub (input) ((((-)) (input_17) (input)))))))) in
(Hashtbl.add (memo_Xparse_strint) (input) (res)) ; res)
)
let rec try_Xparse_int_noerr = 
#95 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_int) (input))
) with
Not_found -> let res = (match (try_Xparse_strint_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_186, __1 ) ) -> Some((input_186, 
#95 "default.trx"
( int_of_string __1  )))) in
(Hashtbl.add (memo_Xparse_int) (input) (res)) ; res)
)
let rec try_Xparse_char_noerr = 
#49 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_char) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('%')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_284, __1 ) ) -> (match (try_Xparse_hexa_noerr (_filename) (_text) (input_284)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_285, __2 ) ) -> (match (try_Xparse_hexa_noerr (_filename) (_text) (input_285)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_286, __3 ) ) -> Some((input_286, 
#49 "xparse.trx"
( char_of_int (16 * Char.hexa_value __2 + Char.hexa_value __3)  )))))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('&')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_274, __1 ) ) -> (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input_274) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (0))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (2))))) (';'))) (true)))))))) ) then ( Some(((((+)) (input_274) (3)), "gt;")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_283, __1 ) ) -> Some((input_283, 
#50 "xparse.trx"
( '>'  )))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_274) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (0))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (2))))) (';'))) (true)))))))) ) then ( Some(((((+)) (input_274) (3)), "lt;")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_282, __1 ) ) -> Some((input_282, 
#50 "xparse.trx"
( '<'  )))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_274) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (1))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (3))))) (';'))) (true)))))))))) ) then ( Some(((((+)) (input_274) (4)), "amp;")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_281, __1 ) ) -> Some((input_281, 
#50 "xparse.trx"
( '&'  )))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_274) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (0))))) ('q'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (4))))) (';'))) (true)))))))))))) ) then ( Some(((((+)) (input_274) (5)), "quot;")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_280, __1 ) ) -> Some((input_280, 
#50 "xparse.trx"
( '"'  )))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input_274) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (1))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_274) (4))))) (';'))) (true)))))))))))) ) then ( Some(((((+)) (input_274) (5)), "apos;")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_279, __1 ) ) -> Some((input_279, 
#50 "xparse.trx"
( '\''  )))) with
None -> (match if ( (((<)) (input_274) (_len)) ) then ( let c = ((_get_char) (input_274)) in
if ( (((=)) (c) ('#')) ) then ( Some((((succ) (input_274)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_276, __1 ) ) -> (match (try_Xparse_int_noerr (_filename) (_text) (input_276)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_277, __2 ) ) -> (match if ( (((<)) (input_277) (_len)) ) then ( let c = ((_get_char) (input_277)) in
if ( (((=)) (c) (';')) ) then ( Some((((succ) (input_277)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_278, __3 ) ) -> Some((input_278, 
#51 "xparse.trx"
( char_of_int __2  ))))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_275, __2 ) ) -> Some((input_275, 
#51 "xparse.trx"
( __2  ))))) with
None -> (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('<')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> let input_272 = input in
let __1 = () in
(match if ( (((<)) (input_272) (_len)) ) then ( let c = ((_get_char) (input_272)) in
Some((((succ) (input_272)), c)) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_273, __2 ) ) -> Some((input_273, 
#52 "xparse.trx"
( __2  ))))
| Some ( ( _, _ ) ) -> None)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_char) (input) (res)) ; res)
)
let rec try_Xparse_text_noerr = 
#44 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_text) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_11 -> (try_Xparse_space_noerr (_filename) (_text) (input_11)))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_10, __1 ) ) -> Some((input_10, 
#45 "xparse.trx"
( `space  )))) with
None -> (match (Trx_runtime.while_primary_noerr (true) ((fun input_9 -> (try_Xparse_char_noerr (_filename) (_text) (input_9)))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_8, __1 ) ) -> Some((input_8, 
#46 "xparse.trx"
( `text (Tgrammar.string_of_chars __1)  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_text) (input) (res)) ; res)
)
let rec try_Xparse_content_item_noerr = 
#34 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_content_item) (input))
) with
Not_found -> let res = (match (try_Xparse_element_noerr (_filename) (_text) (input)) with
None -> (match (try_Xparse_text_noerr (_filename) (_text) (input)) with
None -> (match (try_Xparse_cdata_noerr (_filename) (_text) (input)) with
None -> (match (try_Xparse_extra_header_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_248, __1 ) ) -> (match (try_Xparse_content_item_noerr (_filename) (_text) (input_248)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_249, __2 ) ) -> Some((input_249, 
#34 "xparse.trx"
( __2  )))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_content_item) (input) (res)) ; res)
)
let rec try_Xparse_content_noerr = 
#33 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_content) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr (false) ((fun input_254 -> (try_Xparse_content_item_noerr (_filename) (_text) (input_254)))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_253, __1 ) ) -> Some((input_253, 
#33 "xparse.trx"
( rewrite __1  )))) in
(Hashtbl.add (memo_Xparse_content) (input) (res)) ; res)
)
let rec try_Xparse_eof_noerr = 
#24 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
Some((((succ) (input)), c)) ) else ( None ) with
None -> let input_220 = input in
let __1 = () in
Some((input_220, ()))
| Some ( ( _, _ ) ) -> None))
let rec try_Xparse_header_noerr = 
#28 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_header) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('?'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('x'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "<?xml")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_191, __1 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_191)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_192, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_196 -> (try_Xparse_option_noerr (_filename) (_text) (input_196)))) (input_192)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_193, __3 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_193) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_193) (0))))) ('?'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_193) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input_193) (2)), "?>")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_194, __4 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_194)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_195, __5 ) ) -> Some((input_195, 
#28 "xparse.trx"
( __3  )))))))) in
(Hashtbl.add (memo_Xparse_header) (input) (res)) ; res)
)
let rec try_Xparse_file_noerr = 
#25 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_file) (input))
) with
Not_found -> let res = (match (match (try_Xparse_header_noerr (_filename) (_text) (input)) with
None -> Some((input, None))
| Some ( ( input_208, r ) ) -> Some((input_208, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_204, __1 ) ) -> (match (try_Xparse_content_noerr (_filename) (_text) (input_204)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_205, __2 ) ) -> (match (try_Xparse_spacing_noerr (_filename) (_text) (input_205)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_206, __3 ) ) -> (match (try_Xparse_eof_noerr (_filename) (_text) (input_206)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_207, __4 ) ) -> Some((input_207, 
#26 "xparse.trx"
( let head = match __1 with Some h -> h | None -> [] in 
     let xml, ok = __2 in { xml with header = head }, ok  ))))))) in
(Hashtbl.add (memo_Xparse_file) (input) (res)) ; res)
)
let rec try_Xparse_close = 
#78 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_close_err) (input))
) with
Not_found -> let res = (match (try_Xparse_spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_584, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_584) (_len)) ) then ( let c = ((_get_char) (input_584)) in
if ( (((=)) (c) ('>')) ) then ( Some((((succ) (input_584)), c)) ) else ( None ) ) else ( None )) (input_584) (((Trx_runtime.Expected(("'>'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_585, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_585, ()), ((Trx_runtime.emptyError) (input_585)))))))))) in
(Hashtbl.add (memo_Xparse_close_err) (input) (res)) ; res)
)
let rec try_Xparse_hexa = 
#19 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('F'))))) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('f')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'F']")) ; Trx_runtime.Expected(("['a'-'f']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_507, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_507, __1), ((Trx_runtime.emptyError) (input_507))))))))
let rec try_Xparse_strint = 
#94 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_strint_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'-'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_336, r ), err ) ) -> Trx_runtime.Ok(((input_336, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_333, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (true) ((fun input_335 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_335) (_len)) ) then ( let c = ((_get_char) (input_335)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_335)), c)) ) else ( None ) ) else ( None )) (input_335) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_333)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_334, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_334, (_get_sub (input) ((((-)) (input_334) (input))))), ((Trx_runtime.emptyError) (input_334)))))))))) in
(Hashtbl.add (memo_Xparse_strint_err) (input) (res)) ; res)
)
let rec try_Xparse_int = 
#95 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_int_err) (input))
) with
Not_found -> let res = (match (try_Xparse_strint (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_503, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_503, 
#95 "default.trx"
( int_of_string __1  )), ((Trx_runtime.emptyError) (input_503))))))) in
(Hashtbl.add (memo_Xparse_int_err) (input) (res)) ; res)
)
let rec try_Xparse_char = 
#49 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_char_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('%')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'%'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_601, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_hexa (_filename) (_text) (input_601)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_602, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_hexa (_filename) (_text) (input_602)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_603, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_603, 
#49 "xparse.trx"
( char_of_int (16 * Char.hexa_value __2 + Char.hexa_value __3)  )), ((Trx_runtime.emptyError) (input_603))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('&')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'&'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_591, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_591) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (0))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (2))))) (';'))) (true)))))))) ) then ( Some(((((+)) (input_591) (3)), "gt;")) ) else ( None )) (input_591) ("\"gt;\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_600, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_600, 
#50 "xparse.trx"
( '>'  )), ((Trx_runtime.emptyError) (input_600))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_591) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (0))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (2))))) (';'))) (true)))))))) ) then ( Some(((((+)) (input_591) (3)), "lt;")) ) else ( None )) (input_591) ("\"lt;\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_599, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_599, 
#50 "xparse.trx"
( '<'  )), ((Trx_runtime.emptyError) (input_599))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_591) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (1))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (3))))) (';'))) (true)))))))))) ) then ( Some(((((+)) (input_591) (4)), "amp;")) ) else ( None )) (input_591) ("\"amp;\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_598, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_598, 
#50 "xparse.trx"
( '&'  )), ((Trx_runtime.emptyError) (input_598))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_591) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (0))))) ('q'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (4))))) (';'))) (true)))))))))))) ) then ( Some(((((+)) (input_591) (5)), "quot;")) ) else ( None )) (input_591) ("\"quot;\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_597, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_597, 
#50 "xparse.trx"
( '"'  )), ((Trx_runtime.emptyError) (input_597))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_591) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (1))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_591) (4))))) (';'))) (true)))))))))))) ) then ( Some(((((+)) (input_591) (5)), "apos;")) ) else ( None )) (input_591) ("\"apos;\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_596, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_596, 
#50 "xparse.trx"
( '\''  )), ((Trx_runtime.emptyError) (input_596))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_591) (_len)) ) then ( let c = ((_get_char) (input_591)) in
if ( (((=)) (c) ('#')) ) then ( Some((((succ) (input_591)), c)) ) else ( None ) ) else ( None )) (input_591) (((Trx_runtime.Expected(("'#'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_593, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_int (_filename) (_text) (input_593)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_594, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_594) (_len)) ) then ( let c = ((_get_char) (input_594)) in
if ( (((=)) (c) (';')) ) then ( Some((((succ) (input_594)), c)) ) else ( None ) ) else ( None )) (input_594) (((Trx_runtime.Expected(("';'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_595, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_595, 
#51 "xparse.trx"
( char_of_int __2  )), ((Trx_runtime.emptyError) (input_595)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_592, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_592, 
#51 "xparse.trx"
( __2  )), ((Trx_runtime.emptyError) (input_592)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('<')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'<'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_589 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_589) (_len)) ) then ( let c = ((_get_char) (input_589)) in
Some((((succ) (input_589)), c)) ) else ( None )) (input_589) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_590, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_590, 
#52 "xparse.trx"
( __2  )), ((Trx_runtime.emptyError) (input_590)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_char_err) (input) (res)) ; res)
)
let rec try_Xparse_text = 
#44 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_text_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.while_primary_nores (true) ((fun input_328 -> (try_Xparse_space (_filename) (_text) (input_328)))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_327, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_327, 
#45 "xparse.trx"
( `space  )), ((Trx_runtime.emptyError) (input_327))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (true) ((fun input_326 -> (try_Xparse_char (_filename) (_text) (input_326)))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_325, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_325, 
#46 "xparse.trx"
( `text (Tgrammar.string_of_chars __1)  )), ((Trx_runtime.emptyError) (input_325)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_text_err) (input) (res)) ; res)
)
let rec try_Xparse_slash = 
#61 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_slash_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('/')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'/'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_392, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_392)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_393, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_393, ( () )), ((Trx_runtime.emptyError) (input_393)))))))))) in
(Hashtbl.add (memo_Xparse_slash_err) (input) (res)) ; res)
)
let rec try_Xparse_eof = 
#24 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
Some((((succ) (input)), c)) ) else ( None )) (input) (((Trx_runtime.Expected(("any character")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_537 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_537, ()), ((Trx_runtime.emptyError) (input_537))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))
let rec try_Xparse_cdata = 
#30 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_cdata_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('['))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('C'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('D'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('A'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('T'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('A'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('['))) (true)))))))))))))))))))) ) then ( Some(((((+)) (input) (9)), "<![CDATA[")) ) else ( None )) (input) ("\"<![CDATA[\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_604, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary_nores (false) ((fun input_608 -> (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_608) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_608) (0))))) (']'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_608) (1))))) (']'))) (true)))))) ) then ( Some(((((+)) (input_608) (2)), "]]")) ) else ( None )) (input_608) ("\"]]\"")) with
Trx_runtime.Fail ( ( err ) ) -> let input_609 = input_608 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_609) (_len)) ) then ( let c = ((_get_char) (input_609)) in
Some((((succ) (input_609)), c)) ) else ( None )) (input_609) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_610, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_610, __2), ((Trx_runtime.emptyError) (input_610)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_604)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_607, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_607, (_get_sub (input_604) ((((-)) (input_607) (input_604))))), ((Trx_runtime.emptyError) (input_607))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_605, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_605) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_605) (0))))) (']'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_605) (1))))) (']'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_605) (2))))) ('>'))) (true)))))))) ) then ( Some(((((+)) (input_605) (3)), "]]>")) ) else ( None )) (input_605) ("\"]]>\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_606, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_606, 
#30 "xparse.trx"
( `text __2  )), ((Trx_runtime.emptyError) (input_606))))))))))))) in
(Hashtbl.add (memo_Xparse_cdata_err) (input) (res)) ; res)
)
let rec try_Xparse_extra_header = 
#31 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_extra_header_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('!'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<!")) ) else ( None )) (input) ("\"<!\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_526, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_526) (_len)) ) then ( let c = ((_get_char) (input_526)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input_526)), c)) ) else ( None ) ) else ( None )) (input_526) (((Trx_runtime.Expected(("'-'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_527 = input_526 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_530 -> (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_530) (_len)) ) then ( let c = ((_get_char) (input_530)) in
if ( (((=)) (c) ('>')) ) then ( Some((((succ) (input_530)), c)) ) else ( None ) ) else ( None )) (input_530) (((Trx_runtime.Expected(("'>'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_531 = input_530 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_531) (_len)) ) then ( let c = ((_get_char) (input_531)) in
Some((((succ) (input_531)), c)) ) else ( None )) (input_531) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_532, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_532, __2), ((Trx_runtime.emptyError) (input_532)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_527)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_528, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_528) (_len)) ) then ( let c = ((_get_char) (input_528)) in
if ( (((=)) (c) ('>')) ) then ( Some((((succ) (input_528)), c)) ) else ( None ) ) else ( None )) (input_528) (((Trx_runtime.Expected(("'>'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_529, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_529, ( () )), ((Trx_runtime.emptyError) (input_529))))))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) in
(Hashtbl.add (memo_Xparse_extra_header_err) (input) (res)) ; res)
)
let rec try_Xparse_open = 
#77 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_open_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('<')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'<'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_462, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_462)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_463, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_463, ()), ((Trx_runtime.emptyError) (input_463)))))))))) in
(Hashtbl.add (memo_Xparse_open_err) (input) (res)) ; res)
)
let rec try_Xparse_element = 
#36 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_element_err) (input))
) with
Not_found -> let res = (match (try_Xparse_open (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_538, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Xparse_slash (_filename) (_text) (input_538)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_552, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_nsname (_filename) (_text) (input_552)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_553, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_553, 
#38 "xparse.trx"
( `stop __2  )), ((Trx_runtime.emptyError) (input_553)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_538) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_538) (0))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_538) (1))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_538) (2))))) ('-'))) (true)))))))) ) then ( Some(((((+)) (input_538) (3)), "!--")) ) else ( None )) (input_538) ("\"!--\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_546, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_549 -> (match (try_Xparse_commentstop (_filename) (_text) (input_549)) with
Trx_runtime.Fail ( ( err ) ) -> let input_550 = input_549 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_550) (_len)) ) then ( let c = ((_get_char) (input_550)) in
Some((((succ) (input_550)), c)) ) else ( None )) (input_550) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_551, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_551, __2), ((Trx_runtime.emptyError) (input_551)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_546)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_547, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_547) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_547) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_547) (1))))) ('-'))) (true)))))) ) then ( Some(((((+)) (input_547) (2)), "--")) ) else ( None )) (input_547) ("\"--\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_548, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_548, 
#39 "xparse.trx"
( `nothing  )), ((Trx_runtime.emptyError) (input_548))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_nsname (_filename) (_text) (input_538)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_541, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_545 -> (try_Xparse_option (_filename) (_text) (input_545)))) (input_541)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_542, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Xparse_slash (_filename) (_text) (input_542)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_542, None), err))
| Trx_runtime.Ok ( ( ( input_544, r ), err ) ) -> Trx_runtime.Ok(((input_544, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_543, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_543, 
#40 "xparse.trx"
( match __3 with Some _ -> `one (__1, __2) | _ -> `start (__1, __2)  )), ((Trx_runtime.emptyError) (input_543)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_539, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_close (_filename) (_text) (input_539)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_540, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_540, 
#41 "xparse.trx"
( __2  )), ((Trx_runtime.emptyError) (input_540))))))))))))) in
(Hashtbl.add (memo_Xparse_element_err) (input) (res)) ; res)
)
let rec try_Xparse_content_item = 
#34 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_content_item_err) (input))
) with
Not_found -> let res = (match (match (try_Xparse_element (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_569, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_569, __1), ((Trx_runtime.emptyError) (input_569))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Xparse_text (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_568, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_568, __1), ((Trx_runtime.emptyError) (input_568))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Xparse_cdata (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_567, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_567, __1), ((Trx_runtime.emptyError) (input_567))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_extra_header (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_565, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_content_item (_filename) (_text) (input_565)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_566, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_566, 
#34 "xparse.trx"
( __2  )), ((Trx_runtime.emptyError) (input_566))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Xparse_content_item_err) (input) (res)) ; res)
)
let rec try_Xparse_content = 
#33 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_content_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary (false) ((fun input_571 -> (try_Xparse_content_item (_filename) (_text) (input_571)))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_570, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_570, 
#33 "xparse.trx"
( rewrite __1  )), ((Trx_runtime.emptyError) (input_570))))))) in
(Hashtbl.add (memo_Xparse_content_err) (input) (res)) ; res)
)
let rec try_Xparse_header = 
#28 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_header_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('?'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('x'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "<?xml")) ) else ( None )) (input) ("\"<?xml\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_508, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_508)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_509, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_513 -> (try_Xparse_option (_filename) (_text) (input_513)))) (input_509)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_510, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_510) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_510) (0))))) ('?'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_510) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input_510) (2)), "?>")) ) else ( None )) (input_510) ("\"?>\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_511, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_511)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_512, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_512, 
#28 "xparse.trx"
( __3  )), ((Trx_runtime.emptyError) (input_512))))))))))))))))))) in
(Hashtbl.add (memo_Xparse_header_err) (input) (res)) ; res)
)
let rec try_Xparse_file = 
#25 "xparse.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Xparse_file_err) (input))
) with
Not_found -> let res = (match (match (try_Xparse_header (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_525, r ), err ) ) -> Trx_runtime.Ok(((input_525, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_521, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_content (_filename) (_text) (input_521)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_522, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_spacing (_filename) (_text) (input_522)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_523, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Xparse_eof (_filename) (_text) (input_523)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_524, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_524, 
#26 "xparse.trx"
( let head = match __1 with Some h -> h | None -> [] in 
     let xml, ok = __2 in { xml with header = head }, ok  )), ((Trx_runtime.emptyError) (input_524)))))))))))))))) in
(Hashtbl.add (memo_Xparse_file_err) (input) (res)) ; res)
)
let parse_xparse_file ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Xparse_file_noerr) (_filename))) (((try_Xparse_file) (_filename))) (_text) (_start))
let parse_xparse_content ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Xparse_content_noerr) (_filename))) (((try_Xparse_content) (_filename))) (_text) (_start))
