(*
    Copyright Â© 2011, 2012 MLstate

    This file is part of Opa.

    Opa is free software: you can redistribute it and/or modify it under the
    terms of the GNU Affero General Public License, version 3, as published by
    the Free Software Foundation.

    Opa is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
    FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for
    more details.

    You should have received a copy of the GNU Affero General Public License
    along with Opa. If not, see <http://www.gnu.org/licenses/>.
*)
(**
   Cps Transformation of QmlAst.

   + goes from qml to qmlCpsIL.IL representation
   + get back to qml
   + branch with standard back-ends

   Main : cf function {b cps_pass}

   Note for hackers :

   This pass inserts bypass calls essentially from bslCps.ml, which
   are linked with bypass defined in module QmlCpsServerLib.
   Reading the serverlib is a good point to start hacking the rewriting pass.

   @see "qmlcps/QmlCpsServerLib" for the implementation of runtime support
   @see "opabsl/mlbsl/bslCps.ml" for the registration of runtime bypass

   @author David Rajchenbach-Teller
   @author Mathieu Barbin
   @author Rudy Sicard
*)

(** {6 Error reporting} *)
(** *)
type error
exception Exception of error
val error_message : error -> string

(** {6 Bypass restriction} *)

(**
   The id used by this module for the restricted bypass generation.
   All the cps-specific bypass generated by this module are of
   the following form :

   {[Directive ( `restricted_bypass cps_id, _, Some { e = Bypass skey }, _)]}

   This id should be keeped coherent with the bsl tags used in [bslCps.ml] :

   {[##register [ restricted:$cps_id ] cps_bypass_01 : ....]}

   Other bypass production leads to normal bypass (not restricted)
*)
val cps_id : string

(** {6 Options} *)

(**
   The options of this rewriting pass.
   Any corresponding option from qml2ocaml or opaEnv should be passed consistency.

   <!> As usual to be more robust to any added option in this interface,
   any construction of options should be done with the syntax
   {[{ QmlCpsRewriter.default_options with
     ...
   }]}

   The warn_x_field is there to evoid the warning :
   this record is defined with a 'with construction'
   but no field are keeped from the original.

   Details about options :
   + {b no_assert} : the cps pass should know if assert should be keeped,
   because after the transformation, the back-end is not able to remove all
   the code corresponding to an assertion (too complex after rewriting).
   Default value is [false] : keep assertion
   + {b qml_closure} : tell the cps pass that there will be a closure pass after
   + {b toplevel_concurrency} all toplevel value of the program will be evaluated pseudo-concurrently
   if false, there is a blocking wait after each toplevel declaration.
   default value is [false], toplevel_concurrency is an experimental option.
   <!> The module may be not quiet (warnings) cf option no_warnings
   + {b warn_x_field} : see note upper:
   {[Warning X: this record is defined by a `with' expression,
   but no fields are borrowed from the original.]}
*)
type options =
    {
      no_assert : bool ;
      no_server : bool ;
      qml_closure : bool ;
      toplevel_concurrency : bool ;
      warn_x_field : unit ;
      server_side : bool ;
    }

val default_options : options

(** {6 Env} *)

(**
   The public env used by this transformation.
   This env is needed during the pass, but is not modified (read-only).
   In a further version, the cps pass may update gamma and annotmap.
   (optimisations for field access using qmlflatcompiler)

   The field bsl_bypass_typer is needed to access exactly
   the information registred in the bsl definition of the primitive.
   The field bypass_typer of typing (cf QmlTypes.env)
   may have been modified after some unifications (if the bypass is coerced),
   and may cause error during projection.
*)
type env =
    {
      options : options ;
      bsl_bypass_tags : BslKey.t -> BslTags.t ;
      bsl_bypass_cps : BslKey.t -> BslKey.t option ;
      bsl_bypass_typer : BslKey.t -> BslTypes.t ;
      typing : QmlTyper.env ;
    }

(**
   create an env from each field value.
   default value are :
   + options : [default_options]
   + bsl_bypass_typer : [fun _ -> None]
   + typing : [Typer.initial]
*)
val env_initial :
  options:options ->
  bsl_bypass_typer:(BslKey.t -> BslTypes.t) ->
  bsl_bypass_tags:(BslKey.t -> BslTags.t) ->
  bsl_bypass_cps: (BslKey.t -> BslKey.t option) ->
  typing:QmlTyper.env ->
  unit -> env

(**
   The private env used by this transformation.
   This env is updated during the transformation, and need to be passed
   consistencly to transform a code, using fold_map like functions.
   This env is functionnal.
*)
type private_env

(**
   Constructor of initial private_env, for any new indepedant transformation
*)
val private_env_initial : unit -> private_env

val private_env_get_skipped_ident : private_env -> Ident.t -> Ident.t option

(** {6 Internal traduction} *)
(**
   Exported in this interface for interaction and debugging with
   a pass doing some analysis on the IL representation.
   Nobody should really need to use this low-level functions.
   In particular, you should read the notice explaining that qml expr
   optained by this low-level function may contain unbound identifier
   introduced by the private_env. (cf private_binding)
*)

(** *)
val private_binding : private_env -> (Ident.t * QmlAst.expr) list

val il_simplification : env -> private_env -> QmlCpsIL.IL.term -> private_env * QmlCpsIL.IL.term

(** <!> the returned expr contains some unbound identifier (cf private_binding) *)
val qml_of_il :
  toplevel_cont:(Ident.t -> QmlAst.expr) -> (** toplevel return *)
  env ->
  private_env ->
  QmlCpsIL.IL.term ->
  private_env * QmlAst.expr

(** {6 Qml Traduction} *)

(** Rewriting a code_elt in cps-mode.
    a single code_elt can lead to the production of several code_elts.
    <!> same warning as in [qml_of_il] unbound identifier are in [private_binding]
*)
val code_elt : env -> private_env -> QmlAst.code_elt -> private_env * QmlAst.code

(** rewriting a full code
    <!> Beware this function insert at end a call to the scheduler if the option is set.
    The call should be added only once. If you use the function code directly with
    several pieces of code, set the insert tags only for the last one.
    Default is false (do not insert).

    <!> this function already insert as well the private_binding from the private_env.
*)
val code : env -> private_env -> QmlAst.code -> private_env * QmlAst.code

(** Sugar of interface for compilers : qmlc, opa *)

(** global pass on a full qml-code

    Some infos about what is used from env :
    + use bypass typer for bypass (bsl)
    + does not use other type informations (from Hmx)
    + annotmap is used only to produce location traces of \@assert directives.

    <!> Beware : currently this pass does not update neither gamma nor annotmap.
    Since the rewriting changes the type of every function, insering some
    arguments (continuations), this pass should be used only at end,
    just before the back-ends, or before any pass which does not need
    any type informations (after this pass, gamma is inconsistent).

    As a side effect of this, during shape analysis in qmlflat, some possible
    optimizations are lost (replacing static access by cache).

    TODO: see what we want and need
    + updating gamma during this pass seems to be a lot of work
    + qmflat use only a very small part of gamma.
    + maybe we can add some directives for record access optimization.
*)
val cps_pass : side:[`server|`client] -> env -> QmlAst.code -> private_env * QmlAst.code

val no_cps_pass : env -> QmlAst.code -> private_env * QmlAst.code

(** {6 Common tools for back-ends} *)

(**
   The name of the module of Cps Server Lib
   This module contains the implementation of low-level functions
   dealing with continuation on server side.
   It is an ocaml module taking part of the linking of any server
   compiled in the cps mode.

   Currently, this module is ["QmlCpsServerLib"]

   Nobody should really need it, because now bypass are registred
   in opabsl, this module name is inserted during bypass key resolution.

   However, the generation meta_cps [meta_cps_utils] produces a string
   of ml code containing some direct calls to this module.
*)
val serverlib_module_name : string

(**
   Generate the ocaml-code for uncps$(i) using uncps$(i-1)
   It is used to generate part of bsl_ocaml_init.ml
   TODO : rewrite in an AST (ocaml or qml) if needed.

   Type of functions :
{[
val uncps : ('a continuation -> unit) -> 'a
val uncps1 : ('a -> 'b continuation -> unit) -> 'a -> 'b
val uncps2 :
     ('a -> ('b -> 'c continuation -> unit) continuation -> unit) ->
       'a -> 'b -> 'c
val uncps3 :
     ('a ->
       ('b -> ('c -> 'd continuation -> unit) continuation -> unit)
         continuation -> unit) ->
      'a -> 'b -> 'c -> 'd
etc...
val cps  : 'a -> 'a continuation -> unit
val cps1 : ('a -> 'b) -> 'a -> 'b continuation -> unit
val cps2 :
    ('a -> 'b -> 'c) ->
    'a -> ('b -> 'c continuation -> unit) continuation -> unit
val cps3 :
    ('a -> 'b -> 'c -> 'd) ->
    'a ->
    ('b -> ('c -> 'd continuation -> unit) continuation -> unit)
      continuation -> unit
etc...
]}

   This function produces the following code when not in closure mode:
{[
let uncps  = QmlCpsServerLib.uncps
let uncps1 k f x = uncps k (f x)
let uncps2 k f x = uncps1 k (uncps k (f x))
let uncps3 k f x = uncps2 k (uncps k (f x))
etc...
let cps  f k   = QmlCpsServerLib.return k f
let cps1 f x k = QmlCpsServerLib.return k (f x)
let cps2 f x k = QmlCpsServerLib.return k (cps1 (f x))
let cps3 f x k = QmlCpsServerLib.return k (cps2 (f x))
etc...
]}

   In closure mode, the code is as follows (note that it depends on the non closure-mode cpsX functions):
{[
let export = OpabslMLRuntime.BslClosure.export
let (clos_cps1, clos_cps2, clos_cps3, clos_uncps1, clos_uncps2, clos_uncps3) = Obj.magic (
  let cps_uniq = Obj.magic (object end) in
  let can_import = ... (* written in clear in the implem *) in
  let clos_uncps1 f = (); fun x -> if x == uniq then Obj.magic f else uncps (f x)
  let clos_uncps2 f = (); fun x -> if x == uniq then Obj.magic f else clos_uncps1 (export (uncps (f x)))
  let clos_uncps3 f = (); fun x -> if x == uniq then Obj.magic f else clos_uncps2 (export (uncps (f x)))
  let clos_cps1 f = if can_import f then Obj.magic (f : _ -> _) cps_uniq else cps1 f
  let clos_cps2 f = if can_import f then Obj.magic (f : _ -> _) cps_uniq else cps2 f
  let clos_cps3 f = if can_import f then Obj.magic (f : _ -> _) cps_uniq else cps3 f in
  (clos_cps1, clos_cps2, clos_cps3, clos_uncps1, clos_uncps2, clos_uncps3)

let clos_uncps1 : ('v0,'v1) func -> 'v0 -> 'v1 = clos_uncps1
let clos_uncps2 : ('v0,('v1,'v2) func) func -> 'v0 -> 'v1 -> 'v2 = clos_uncps2
let clos_uncps3 : ('v0,('v1,('v2, 'v3) func) func) func -> 'v0 -> 'v1 -> 'v2 -> 'v3 = clos_uncps3
let clos_cps1 : ('v0 -> 'v1) -> ('v0,'v1) func = clos_cps1
let clos_cps2 : ('v0 -> 'v1 -> 'v2) -> ('v0,('v1,'v2) func) func = clos_cps2
let clos_cps3 : ('v0 -> 'v1 -> 'v2 -> 'v3) -> ('v0,('v1,('v2,'v3) func) func) func = clos_cps3
]}

   NARY-MODE (this is not the default case)

   Types
{[
val uncps : ('a continuation -> unit) -> 'a
val uncps1 : ('a -> 'b continuation -> unit) -> 'a -> 'b
val uncps2 : ('a -> 'b -> 'c continuation -> unit) -> 'a -> 'b -> 'c
val uncps3 : ('a -> 'b -> 'c -> 'd continuation -> unit) -> 'a -> 'b -> 'c -> 'd
etc...
val cps  : 'a -> 'a continuation -> unit
val cps1 : ('a -> 'b) -> 'a -> 'b continuation -> unit
val cps2 :
    ('a -> 'b -> 'c) ->
    ('a -> 'b -> 'c continuation -> unit)
val cps3 :
    ('a -> 'b -> 'c -> 'd) ->
    ('a -> 'b -> 'c -> 'd continuation -> unit)
]}

   This function produces the following code when not in closure mode:
{[
let uncps  = QmlCpsServerLib.uncps
let uncps1 f x1 = uncps (f x1)
let uncps2 f x1 x2 = uncps (f x1 x2)
let uncps3 f x1 x2 x3 = uncps (f x1 x2 x3)
etc...
let cps f k = QmlCpsServerLib.return k f
let cps1 f x1 k = QmlCpsServerLib.return k (f x1)
let cps2 f x1 x2 k = QmlCpsServerLib.return k (f x1 x2)
let cps3 f x1 x2 x3 k = QmlCpsServerLib.return k (f x1 x2 x3)
etc...
]}

   This function is called by back-ends at end of bypass projection,
   using as n value the maximum of function arity present in the projected code.

   The cps/uncps functions are used to project functional arguments of bypass,
   because after the pass, every function has changed.

   <!> uncps is based on a blocking wait for a barrier to be release,
   asynchronous call to the continuation are not yet supported.

   Since this code is generated dynamically, this function is called
   in the [BslFor$Backends] modules, using [CTrans.conversion_code] facility.
   @see "BslLib.ML_CTRANS" interface
*)
val meta_cps_utils : int -> string
