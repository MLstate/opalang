
#22 "ocaml_parser.trx"

open Ocaml
open Printf

let make_app l =
  assert(List.length l >= 2);
  let rec aux r = function
  | [] -> assert false
  | [hd] -> App (r, hd)
  | hd::tl -> aux (App (r, hd)) tl
  in aux (List.hd l) (List.tl l);;


#231 "ocaml_parser.trx"
 let make_fun e = function | [] -> e | x -> Abs (x, e) 

#38 "ocaml_types.trx"

open Base
open Ocaml


#47 "ocaml_types.trx"
 let compute_vars = function None -> [] | Some l -> List.map (function TypeVar s -> s | _ -> assert false) l
let _grammar_rules = [ ("Ocaml_types_typevars", None) ; ("Ocaml_types_typevarorname", None) ; ("Ocaml_types_typevar", None) ; ("Ocaml_types_typerecord_aux", None) ; ("Ocaml_types_typerecord", None) ; ("Ocaml_types_typeparam", None) ; ("Ocaml_types_typename", None) ; ("Ocaml_types_typefinder", None) ; ("Ocaml_types_typedeflist", None) ; ("Ocaml_types_typedef_no_arrow", None) ; ("Ocaml_types_typedef_base", None) ; ("Ocaml_types_typedef_aux", None) ; ("Ocaml_types_typedef", None) ; ("Ocaml_types_typedeclaration", None) ; ("Ocaml_types_typeconstructor", None) ; ("Ocaml_types_typeconst", None) ; ("Ocaml_types_typeSum", None) ; ("Ocaml_types_typeIdent_cont", None) ; ("Ocaml_types_typeIdent_aux", None) ; ("Ocaml_types_typeIdent", None) ; ("Ocaml_types_test", None) ; ("Ocaml_types_spacing", None) ; ("Ocaml_types_onetyperecord", None) ; ("Ocaml_types_lineskipper", None) ; ("Ocaml_types_UnitT", None) ; ("Ocaml_types_StringT", None) ; ("Ocaml_types_IntT", None) ; ("Ocaml_types_Int64T", None) ; ("Ocaml_types_FloatT", None) ; ("Ocaml_types_BoolT", None) ; ("Ocaml_parser_unit", None) ; ("Ocaml_parser_type", None) ; ("Ocaml_parser_spacing", None) ; ("Ocaml_parser_pattern_cons", None) ; ("Ocaml_parser_pattern_aux_l", None) ; ("Ocaml_parser_pattern_aux_aux", None) ; ("Ocaml_parser_pattern_aux", None) ; ("Ocaml_parser_pattern", None) ; ("Ocaml_parser_parse", None) ; ("Ocaml_parser_paramFormel", None) ; ("Ocaml_parser_paramEffectif", None) ; ("Ocaml_parser_op_special", None) ; ("Ocaml_parser_op_or", None) ; ("Ocaml_parser_op_notequal_struct", None) ; ("Ocaml_parser_op_notequal", None) ; ("Ocaml_parser_op_logic", None) ; ("Ocaml_parser_op_equal_struct", None) ; ("Ocaml_parser_op_equal", None) ; ("Ocaml_parser_op_concat", None) ; ("Ocaml_parser_op_aro", None) ; ("Ocaml_parser_op_and", None) ; ("Ocaml_parser_moduleName_", None) ; ("Ocaml_parser_moduleName", None) ; ("Ocaml_parser_mlIdent_cont", None) ; ("Ocaml_parser_mlIdent_aux_", None) ; ("Ocaml_parser_mlIdent_aux", None) ; ("Ocaml_parser_mlIdent_", None) ; ("Ocaml_parser_mlIdent", None) ; ("Ocaml_parser_matchExpr", None) ; ("Ocaml_parser_emptylist", None) ; ("Ocaml_parser_dotable", None) ; ("Ocaml_parser_constructorName", None) ; ("Ocaml_parser_const", None) ; ("Ocaml_parser_capMlIdent_", None) ; ("Ocaml_parser_capMlIdent", None) ; ("Ocaml_parser_Var", None) ; ("Ocaml_parser_Type", None) ; ("Ocaml_parser_Try", None) ; ("Ocaml_parser_SimpleExpr", None) ; ("Ocaml_parser_SetRef", None) ; ("Ocaml_parser_Record", None) ; ("Ocaml_parser_Raise", None) ; ("Ocaml_parser_RNameOpt", None) ; ("Ocaml_parser_Paren", None) ; ("Ocaml_parser_PLUS", None) ; ("Ocaml_parser_Operators", None) ; ("Ocaml_parser_Open", None) ; ("Ocaml_parser_OpLevel4", None) ; ("Ocaml_parser_OpLevel3", None) ; ("Ocaml_parser_OpLevel2", None) ; ("Ocaml_parser_OpLevel1", None) ; ("Ocaml_parser_Module", None) ; ("Ocaml_parser_Match", None) ; ("Ocaml_parser_MakeRef", None) ; ("Ocaml_parser_MULT", None) ; ("Ocaml_parser_MINUS", None) ; ("Ocaml_parser_Letin", None) ; ("Ocaml_parser_LetOrType", None) ; ("Ocaml_parser_Let", None) ; ("Ocaml_parser_LT", None) ; ("Ocaml_parser_LE", None) ; ("Ocaml_parser_InfOpLevel4", None) ; ("Ocaml_parser_InfOpLevel3", None) ; ("Ocaml_parser_InfOpLevel2", None) ; ("Ocaml_parser_InfOpLevel1", None) ; ("Ocaml_parser_IPLUS", None) ; ("Ocaml_parser_IMULT", None) ; ("Ocaml_parser_IMINUS", None) ; ("Ocaml_parser_IDIV", None) ; ("Ocaml_parser_GetRef", None) ; ("Ocaml_parser_GT", None) ; ("Ocaml_parser_GE", None) ; ("Ocaml_parser_FPLUS", None) ; ("Ocaml_parser_FMULT", None) ; ("Ocaml_parser_FMINUS", None) ; ("Ocaml_parser_FDIV", None) ; ("Ocaml_parser_Expr_without_seq_aux", None) ; ("Ocaml_parser_Expr_without_seq", None) ; ("Ocaml_parser_ExprNotApp", None) ; ("Ocaml_parser_Expr", None) ; ("Ocaml_parser_Exception", None) ; ("Ocaml_parser_EmptyList", None) ; ("Ocaml_parser_Dot", None) ; ("Ocaml_parser_DIV", None) ; ("Ocaml_parser_Constructor", None) ; ("Ocaml_parser_Const", None) ; ("Ocaml_parser_Cons", None) ; ("Ocaml_parser_Cond", None) ; ("Ocaml_parser_Assert", None) ; ("Ocaml_parser_App", None) ; ("Ocaml_parser_Abs", None) ; ("Ocaml_keywords_spacing", None) ; ("Ocaml_keywords_WITH", None) ; ("Ocaml_keywords_WHEN", None) ; ("Ocaml_keywords_VAL", None) ; ("Ocaml_keywords_TYPE", None) ; ("Ocaml_keywords_TRY", None) ; ("Ocaml_keywords_TRUE", None) ; ("Ocaml_keywords_THEN", None) ; ("Ocaml_keywords_STRUCT", None) ; ("Ocaml_keywords_SPECIALS", None) ; ("Ocaml_keywords_SIG", None) ; ("Ocaml_keywords_REF", None) ; ("Ocaml_keywords_REC", None) ; ("Ocaml_keywords_RAISE", None) ; ("Ocaml_keywords_ORL", None) ; ("Ocaml_keywords_OPEN", None) ; ("Ocaml_keywords_OF", None) ; ("Ocaml_keywords_MUTABLE", None) ; ("Ocaml_keywords_MODULE", None) ; ("Ocaml_keywords_MATCH", None) ; ("Ocaml_keywords_LET", None) ; ("Ocaml_keywords_KEYWORDS", None) ; ("Ocaml_keywords_IN", None) ; ("Ocaml_keywords_IF", None) ; ("Ocaml_keywords_GETREF", None) ; ("Ocaml_keywords_FUNCTION", None) ; ("Ocaml_keywords_FUN", None) ; ("Ocaml_keywords_FALSE", None) ; ("Ocaml_keywords_EXCEPTION", None) ; ("Ocaml_keywords_END", None) ; ("Ocaml_keywords_ELSE", None) ; ("Ocaml_keywords_CONSTRUCTOR_aux", None) ; ("Ocaml_keywords_CONSTRUCTOR", None) ; ("Ocaml_keywords_CONS", None) ; ("Ocaml_keywords_BEGIN", None) ; ("Ocaml_keywords_ASSERT", None) ; ("Ocaml_keywords_AS", None) ; ("Ocaml_keywords_ANDL", None) ; ("Ocaml_keywords_AND", None) ; ("Default_underscore", None) ; ("Default_times", None) ; ("Default_tilde_", None) ; ("Default_strint64", None) ; ("Default_strint", None) ; ("Default_stringsinglequote", None) ; ("Default_stringsinglechar", None) ; ("Default_stringquote", None) ; ("Default_stringnosp", None) ; ("Default_stringcharspecial", None) ; ("Default_stringchar", None) ; ("Default_string", None) ; ("Default_strfloat", None) ; ("Default_strbool", None) ; ("Default_str_ipaddr", None) ; ("Default_spacing", None) ; ("Default_space", None) ; ("Default_slash", None) ; ("Default_singlequotechar_", None) ; ("Default_sharpcomment", None) ; ("Default_sharp", None) ; ("Default_semi", None) ; ("Default_rparen", None) ; ("Default_rightarrow", None) ; ("Default_rbracket", None) ; ("Default_raccol", None) ; ("Default_question_", None) ; ("Default_question", None) ; ("Default_plus", None) ; ("Default_parexprnosp", None) ; ("Default_parexprexcluded", None) ; ("Default_parexpr", None) ; ("Default_mlcomment", None) ; ("Default_mlCOMMENTSTOP", None) ; ("Default_mlCOMMENTSTART", None) ; ("Default_lparen", None) ; ("Default_leftarrow", None) ; ("Default_lbracket", None) ; ("Default_laccol", None) ; ("Default_int64", None) ; ("Default_int3", None) ; ("Default_int", None) ; ("Default_humanint", None) ; ("Default_hexa", None) ; ("Default_float", None) ; ("Default_equal", None) ; ("Default_eol", None) ; ("Default_eof", None) ; ("Default_dot", None) ; ("Default_comma", None) ; ("Default_colon", None) ; ("Default_charsinglequote", None) ; ("Default_bracketexprcontent", None) ; ("Default_bracketexpr", None) ; ("Default_bool", None) ; ("Default_bar", None) ; ("Default_bang", None) ; ("Default_at", None) ; ("Default_accolexprcontent", None) ; ("Default_accolexpr", None) ]
let parse_with f_noerr f_err _text _start = let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (f_noerr (_text) (_start)) with
Some ( ( pos, res ) ) -> (pos, res)
| None -> (match (f_err (_text) (_start)) with
Trx_runtime.Ok ( ( ( _, _ ), _ ) ) -> (assert false)
| Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.gen_syntax_error (((FilePos.get_pos_no_cache) (_text))) (err))))
let memo_Default_bar = ((Hashtbl.create) (128))
let memo_Default_bar_err = ((Hashtbl.create) (128))
let memo_Default_charsinglequote = ((Hashtbl.create) (128))
let memo_Default_charsinglequote_err = ((Hashtbl.create) (128))
let memo_Default_colon = ((Hashtbl.create) (128))
let memo_Default_colon_err = ((Hashtbl.create) (128))
let memo_Default_comma = ((Hashtbl.create) (128))
let memo_Default_comma_err = ((Hashtbl.create) (128))
let memo_Default_dot = ((Hashtbl.create) (128))
let memo_Default_dot_err = ((Hashtbl.create) (128))
let memo_Default_equal = ((Hashtbl.create) (128))
let memo_Default_equal_err = ((Hashtbl.create) (128))
let memo_Default_float = ((Hashtbl.create) (128))
let memo_Default_float_err = ((Hashtbl.create) (128))
let memo_Default_int = ((Hashtbl.create) (128))
let memo_Default_int_err = ((Hashtbl.create) (128))
let memo_Default_laccol = ((Hashtbl.create) (128))
let memo_Default_laccol_err = ((Hashtbl.create) (128))
let memo_Default_lbracket = ((Hashtbl.create) (128))
let memo_Default_lbracket_err = ((Hashtbl.create) (128))
let memo_Default_leftarrow = ((Hashtbl.create) (128))
let memo_Default_leftarrow_err = ((Hashtbl.create) (128))
let memo_Default_lparen = ((Hashtbl.create) (128))
let memo_Default_lparen_err = ((Hashtbl.create) (128))
let memo_Default_mlcomment = ((Hashtbl.create) (128))
let memo_Default_mlcomment_err = ((Hashtbl.create) (128))
let memo_Default_question = ((Hashtbl.create) (128))
let memo_Default_question_err = ((Hashtbl.create) (128))
let memo_Default_raccol = ((Hashtbl.create) (128))
let memo_Default_raccol_err = ((Hashtbl.create) (128))
let memo_Default_rbracket = ((Hashtbl.create) (128))
let memo_Default_rbracket_err = ((Hashtbl.create) (128))
let memo_Default_rightarrow = ((Hashtbl.create) (128))
let memo_Default_rightarrow_err = ((Hashtbl.create) (128))
let memo_Default_rparen = ((Hashtbl.create) (128))
let memo_Default_rparen_err = ((Hashtbl.create) (128))
let memo_Default_semi = ((Hashtbl.create) (128))
let memo_Default_semi_err = ((Hashtbl.create) (128))
let memo_Default_singlequotechar_ = ((Hashtbl.create) (128))
let memo_Default_singlequotechar__err = ((Hashtbl.create) (128))
let memo_Default_spacing = ((Hashtbl.create) (128))
let memo_Default_spacing_err = ((Hashtbl.create) (128))
let memo_Default_strfloat = ((Hashtbl.create) (128))
let memo_Default_strfloat_err = ((Hashtbl.create) (128))
let memo_Default_string = ((Hashtbl.create) (128))
let memo_Default_string_err = ((Hashtbl.create) (128))
let memo_Default_stringchar = ((Hashtbl.create) (128))
let memo_Default_stringchar_err = ((Hashtbl.create) (128))
let memo_Default_stringcharspecial = ((Hashtbl.create) (128))
let memo_Default_stringcharspecial_err = ((Hashtbl.create) (128))
let memo_Default_stringnosp = ((Hashtbl.create) (128))
let memo_Default_stringnosp_err = ((Hashtbl.create) (128))
let memo_Default_strint = ((Hashtbl.create) (128))
let memo_Default_strint_err = ((Hashtbl.create) (128))
let memo_Default_underscore = ((Hashtbl.create) (128))
let memo_Default_underscore_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_AND = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_AND_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_AS = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_AS_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_ASSERT = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_ASSERT_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_BEGIN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_BEGIN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_CONS = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_CONS_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_ELSE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_ELSE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_END = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_END_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_EXCEPTION = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_EXCEPTION_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_FUN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_FUN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_FUNCTION = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_FUNCTION_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_GETREF = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_GETREF_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_IF = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_IF_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_IN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_IN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_KEYWORDS = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_KEYWORDS_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_LET = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_LET_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MATCH = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MATCH_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MODULE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MODULE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MUTABLE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_MUTABLE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_OF = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_OF_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_OPEN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_OPEN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_RAISE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_RAISE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_REC = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_REC_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_REF = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_REF_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_SPECIALS = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_SPECIALS_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_STRUCT = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_STRUCT_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_THEN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_THEN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_TRY = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_TRY_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_TYPE = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_TYPE_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_WHEN = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_WHEN_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_WITH = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_WITH_err = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_spacing = ((Hashtbl.create) (128))
let memo_Ocaml_keywords_spacing_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Abs = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Abs_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_App = ((Hashtbl.create) (128))
let memo_Ocaml_parser_App_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Assert = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Assert_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Cond = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Cond_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Cons = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Cons_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Const = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Const_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Constructor = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Constructor_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_DIV = ((Hashtbl.create) (128))
let memo_Ocaml_parser_DIV_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Dot = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Dot_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_EmptyList = ((Hashtbl.create) (128))
let memo_Ocaml_parser_EmptyList_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Exception = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Exception_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_ExprNotApp = ((Hashtbl.create) (128))
let memo_Ocaml_parser_ExprNotApp_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_without_seq = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_without_seq_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_without_seq_aux = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Expr_without_seq_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FDIV = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FDIV_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FMINUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FMINUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FMULT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FMULT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FPLUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_FPLUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GE = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GE_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GetRef = ((Hashtbl.create) (128))
let memo_Ocaml_parser_GetRef_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IDIV = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IDIV_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IMINUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IMINUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IMULT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IMULT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IPLUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_IPLUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel1 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel1_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel2 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel2_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel3 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel3_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel4 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_InfOpLevel4_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LE = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LE_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Let = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Let_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LetOrType = ((Hashtbl.create) (128))
let memo_Ocaml_parser_LetOrType_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Letin = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Letin_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MINUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MINUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MULT = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MULT_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MakeRef = ((Hashtbl.create) (128))
let memo_Ocaml_parser_MakeRef_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Match = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Match_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Module = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Module_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel1 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel1_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel2 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel2_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel3 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel3_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel4 = ((Hashtbl.create) (128))
let memo_Ocaml_parser_OpLevel4_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Open = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Open_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_PLUS = ((Hashtbl.create) (128))
let memo_Ocaml_parser_PLUS_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Paren = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Paren_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_RNameOpt = ((Hashtbl.create) (128))
let memo_Ocaml_parser_RNameOpt_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Raise = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Raise_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Record = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Record_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_SetRef = ((Hashtbl.create) (128))
let memo_Ocaml_parser_SetRef_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_SimpleExpr = ((Hashtbl.create) (128))
let memo_Ocaml_parser_SimpleExpr_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Try = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Try_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Type = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Type_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Var = ((Hashtbl.create) (128))
let memo_Ocaml_parser_Var_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_capMlIdent = ((Hashtbl.create) (128))
let memo_Ocaml_parser_capMlIdent_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_capMlIdent_ = ((Hashtbl.create) (128))
let memo_Ocaml_parser_capMlIdent__err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_const = ((Hashtbl.create) (128))
let memo_Ocaml_parser_const_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_constructorName = ((Hashtbl.create) (128))
let memo_Ocaml_parser_constructorName_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_dotable = ((Hashtbl.create) (128))
let memo_Ocaml_parser_dotable_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_emptylist = ((Hashtbl.create) (128))
let memo_Ocaml_parser_emptylist_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_matchExpr = ((Hashtbl.create) (128))
let memo_Ocaml_parser_matchExpr_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_ = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent__err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_aux = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_aux_ = ((Hashtbl.create) (128))
let memo_Ocaml_parser_mlIdent_aux__err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_moduleName = ((Hashtbl.create) (128))
let memo_Ocaml_parser_moduleName_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_moduleName_ = ((Hashtbl.create) (128))
let memo_Ocaml_parser_moduleName__err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_and = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_and_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_aro = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_aro_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_concat = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_concat_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_equal = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_equal_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_equal_struct = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_equal_struct_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_logic = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_logic_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_notequal = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_notequal_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_notequal_struct = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_notequal_struct_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_or = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_or_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_special = ((Hashtbl.create) (128))
let memo_Ocaml_parser_op_special_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_paramEffectif = ((Hashtbl.create) (128))
let memo_Ocaml_parser_paramEffectif_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_paramFormel = ((Hashtbl.create) (128))
let memo_Ocaml_parser_paramFormel_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_parse = ((Hashtbl.create) (128))
let memo_Ocaml_parser_parse_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_aux = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_l = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_aux_l_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_cons = ((Hashtbl.create) (128))
let memo_Ocaml_parser_pattern_cons_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_spacing = ((Hashtbl.create) (128))
let memo_Ocaml_parser_spacing_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_type = ((Hashtbl.create) (128))
let memo_Ocaml_parser_type_err = ((Hashtbl.create) (128))
let memo_Ocaml_parser_unit = ((Hashtbl.create) (128))
let memo_Ocaml_parser_unit_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_lineskipper = ((Hashtbl.create) (128))
let memo_Ocaml_types_lineskipper_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_onetyperecord = ((Hashtbl.create) (128))
let memo_Ocaml_types_onetyperecord_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_spacing = ((Hashtbl.create) (128))
let memo_Ocaml_types_spacing_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_test = ((Hashtbl.create) (128))
let memo_Ocaml_types_test_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeIdent = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeIdent_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeIdent_aux = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeIdent_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeSum = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeSum_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeconst = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeconst_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeconstructor = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeconstructor_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedeclaration = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedeclaration_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_aux = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_base = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_base_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_no_arrow = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedef_no_arrow_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedeflist = ((Hashtbl.create) (128))
let memo_Ocaml_types_typedeflist_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typefinder = ((Hashtbl.create) (128))
let memo_Ocaml_types_typefinder_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typename = ((Hashtbl.create) (128))
let memo_Ocaml_types_typename_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeparam = ((Hashtbl.create) (128))
let memo_Ocaml_types_typeparam_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typerecord = ((Hashtbl.create) (128))
let memo_Ocaml_types_typerecord_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typerecord_aux = ((Hashtbl.create) (128))
let memo_Ocaml_types_typerecord_aux_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevar = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevar_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevarorname = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevarorname_err = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevars = ((Hashtbl.create) (128))
let memo_Ocaml_types_typevars_err = ((Hashtbl.create) (128))
let prepare_cache () = ((Hashtbl.clear) (memo_Default_bar)) ; ((Hashtbl.clear) (memo_Default_bar_err)) ; ((Hashtbl.clear) (memo_Default_charsinglequote)) ; ((Hashtbl.clear) (memo_Default_charsinglequote_err)) ; ((Hashtbl.clear) (memo_Default_colon)) ; ((Hashtbl.clear) (memo_Default_colon_err)) ; ((Hashtbl.clear) (memo_Default_comma)) ; ((Hashtbl.clear) (memo_Default_comma_err)) ; ((Hashtbl.clear) (memo_Default_dot)) ; ((Hashtbl.clear) (memo_Default_dot_err)) ; ((Hashtbl.clear) (memo_Default_equal)) ; ((Hashtbl.clear) (memo_Default_equal_err)) ; ((Hashtbl.clear) (memo_Default_float)) ; ((Hashtbl.clear) (memo_Default_float_err)) ; ((Hashtbl.clear) (memo_Default_int)) ; ((Hashtbl.clear) (memo_Default_int_err)) ; ((Hashtbl.clear) (memo_Default_laccol)) ; ((Hashtbl.clear) (memo_Default_laccol_err)) ; ((Hashtbl.clear) (memo_Default_lbracket)) ; ((Hashtbl.clear) (memo_Default_lbracket_err)) ; ((Hashtbl.clear) (memo_Default_leftarrow)) ; ((Hashtbl.clear) (memo_Default_leftarrow_err)) ; ((Hashtbl.clear) (memo_Default_lparen)) ; ((Hashtbl.clear) (memo_Default_lparen_err)) ; ((Hashtbl.clear) (memo_Default_mlcomment)) ; ((Hashtbl.clear) (memo_Default_mlcomment_err)) ; ((Hashtbl.clear) (memo_Default_question)) ; ((Hashtbl.clear) (memo_Default_question_err)) ; ((Hashtbl.clear) (memo_Default_raccol)) ; ((Hashtbl.clear) (memo_Default_raccol_err)) ; ((Hashtbl.clear) (memo_Default_rbracket)) ; ((Hashtbl.clear) (memo_Default_rbracket_err)) ; ((Hashtbl.clear) (memo_Default_rightarrow)) ; ((Hashtbl.clear) (memo_Default_rightarrow_err)) ; ((Hashtbl.clear) (memo_Default_rparen)) ; ((Hashtbl.clear) (memo_Default_rparen_err)) ; ((Hashtbl.clear) (memo_Default_semi)) ; ((Hashtbl.clear) (memo_Default_semi_err)) ; ((Hashtbl.clear) (memo_Default_singlequotechar_)) ; ((Hashtbl.clear) (memo_Default_singlequotechar__err)) ; ((Hashtbl.clear) (memo_Default_spacing)) ; ((Hashtbl.clear) (memo_Default_spacing_err)) ; ((Hashtbl.clear) (memo_Default_strfloat)) ; ((Hashtbl.clear) (memo_Default_strfloat_err)) ; ((Hashtbl.clear) (memo_Default_string)) ; ((Hashtbl.clear) (memo_Default_string_err)) ; ((Hashtbl.clear) (memo_Default_stringchar)) ; ((Hashtbl.clear) (memo_Default_stringchar_err)) ; ((Hashtbl.clear) (memo_Default_stringcharspecial)) ; ((Hashtbl.clear) (memo_Default_stringcharspecial_err)) ; ((Hashtbl.clear) (memo_Default_stringnosp)) ; ((Hashtbl.clear) (memo_Default_stringnosp_err)) ; ((Hashtbl.clear) (memo_Default_strint)) ; ((Hashtbl.clear) (memo_Default_strint_err)) ; ((Hashtbl.clear) (memo_Default_underscore)) ; ((Hashtbl.clear) (memo_Default_underscore_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_AND)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_AND_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_AS)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_AS_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_ASSERT)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_ASSERT_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_BEGIN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_BEGIN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_CONS)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_CONS_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_ELSE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_ELSE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_END)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_END_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_EXCEPTION)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_EXCEPTION_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_FUN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_FUN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_FUNCTION)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_FUNCTION_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_GETREF)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_GETREF_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_IF)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_IF_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_IN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_IN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_KEYWORDS)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_KEYWORDS_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_LET)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_LET_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MATCH)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MATCH_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MODULE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MODULE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MUTABLE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_MUTABLE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_OF)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_OF_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_OPEN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_OPEN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_RAISE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_RAISE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_REC)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_REC_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_REF)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_REF_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_SPECIALS)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_SPECIALS_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_STRUCT)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_STRUCT_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_THEN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_THEN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_TRY)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_TRY_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_TYPE)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_TYPE_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_WHEN)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_WHEN_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_WITH)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_WITH_err)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_spacing)) ; ((Hashtbl.clear) (memo_Ocaml_keywords_spacing_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Abs)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Abs_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_App)) ; ((Hashtbl.clear) (memo_Ocaml_parser_App_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Assert)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Assert_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Cond)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Cond_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Cons)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Cons_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Const)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Const_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Constructor)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Constructor_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_DIV)) ; ((Hashtbl.clear) (memo_Ocaml_parser_DIV_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Dot)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Dot_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_EmptyList)) ; ((Hashtbl.clear) (memo_Ocaml_parser_EmptyList_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Exception)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Exception_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_ExprNotApp)) ; ((Hashtbl.clear) (memo_Ocaml_parser_ExprNotApp_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_without_seq)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_without_seq_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_without_seq_aux)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Expr_without_seq_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FDIV)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FDIV_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FMINUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FMINUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FMULT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FMULT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FPLUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_FPLUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GE)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GE_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GetRef)) ; ((Hashtbl.clear) (memo_Ocaml_parser_GetRef_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IDIV)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IDIV_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IMINUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IMINUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IMULT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IMULT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IPLUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_IPLUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel1)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel1_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel2)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel2_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel3)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel3_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel4)) ; ((Hashtbl.clear) (memo_Ocaml_parser_InfOpLevel4_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LE)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LE_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Let)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Let_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LetOrType)) ; ((Hashtbl.clear) (memo_Ocaml_parser_LetOrType_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Letin)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Letin_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MINUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MINUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MULT)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MULT_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MakeRef)) ; ((Hashtbl.clear) (memo_Ocaml_parser_MakeRef_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Match)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Match_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Module)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Module_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel1)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel1_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel2)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel2_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel3)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel3_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel4)) ; ((Hashtbl.clear) (memo_Ocaml_parser_OpLevel4_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Open)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Open_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_PLUS)) ; ((Hashtbl.clear) (memo_Ocaml_parser_PLUS_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Paren)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Paren_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_RNameOpt)) ; ((Hashtbl.clear) (memo_Ocaml_parser_RNameOpt_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Raise)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Raise_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Record)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Record_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_SetRef)) ; ((Hashtbl.clear) (memo_Ocaml_parser_SetRef_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_SimpleExpr)) ; ((Hashtbl.clear) (memo_Ocaml_parser_SimpleExpr_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Try)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Try_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Type)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Type_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Var)) ; ((Hashtbl.clear) (memo_Ocaml_parser_Var_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_capMlIdent)) ; ((Hashtbl.clear) (memo_Ocaml_parser_capMlIdent_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_capMlIdent_)) ; ((Hashtbl.clear) (memo_Ocaml_parser_capMlIdent__err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_const)) ; ((Hashtbl.clear) (memo_Ocaml_parser_const_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_constructorName)) ; ((Hashtbl.clear) (memo_Ocaml_parser_constructorName_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_dotable)) ; ((Hashtbl.clear) (memo_Ocaml_parser_dotable_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_emptylist)) ; ((Hashtbl.clear) (memo_Ocaml_parser_emptylist_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_matchExpr)) ; ((Hashtbl.clear) (memo_Ocaml_parser_matchExpr_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent__err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_aux)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_aux_)) ; ((Hashtbl.clear) (memo_Ocaml_parser_mlIdent_aux__err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_moduleName)) ; ((Hashtbl.clear) (memo_Ocaml_parser_moduleName_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_moduleName_)) ; ((Hashtbl.clear) (memo_Ocaml_parser_moduleName__err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_and)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_and_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_aro)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_aro_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_concat)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_concat_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_equal)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_equal_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_equal_struct)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_equal_struct_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_logic)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_logic_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_notequal)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_notequal_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_notequal_struct)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_notequal_struct_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_or)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_or_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_special)) ; ((Hashtbl.clear) (memo_Ocaml_parser_op_special_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_paramEffectif)) ; ((Hashtbl.clear) (memo_Ocaml_parser_paramEffectif_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_paramFormel)) ; ((Hashtbl.clear) (memo_Ocaml_parser_paramFormel_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_parse)) ; ((Hashtbl.clear) (memo_Ocaml_parser_parse_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_aux)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_l)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_aux_l_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_cons)) ; ((Hashtbl.clear) (memo_Ocaml_parser_pattern_cons_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_spacing)) ; ((Hashtbl.clear) (memo_Ocaml_parser_spacing_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_type)) ; ((Hashtbl.clear) (memo_Ocaml_parser_type_err)) ; ((Hashtbl.clear) (memo_Ocaml_parser_unit)) ; ((Hashtbl.clear) (memo_Ocaml_parser_unit_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_lineskipper)) ; ((Hashtbl.clear) (memo_Ocaml_types_lineskipper_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_onetyperecord)) ; ((Hashtbl.clear) (memo_Ocaml_types_onetyperecord_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_spacing)) ; ((Hashtbl.clear) (memo_Ocaml_types_spacing_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_test)) ; ((Hashtbl.clear) (memo_Ocaml_types_test_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeIdent)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeIdent_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeIdent_aux)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeIdent_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeSum)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeSum_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeconst)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeconst_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeconstructor)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeconstructor_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedeclaration)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedeclaration_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_aux)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_base)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_base_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_no_arrow)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedef_no_arrow_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedeflist)) ; ((Hashtbl.clear) (memo_Ocaml_types_typedeflist_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typefinder)) ; ((Hashtbl.clear) (memo_Ocaml_types_typefinder_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typename)) ; ((Hashtbl.clear) (memo_Ocaml_types_typename_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeparam)) ; ((Hashtbl.clear) (memo_Ocaml_types_typeparam_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typerecord)) ; ((Hashtbl.clear) (memo_Ocaml_types_typerecord_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typerecord_aux)) ; ((Hashtbl.clear) (memo_Ocaml_types_typerecord_aux_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevar)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevar_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevarorname)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevarorname_err)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevars)) ; ((Hashtbl.clear) (memo_Ocaml_types_typevars_err))
let try_Default_mlCOMMENTSTART_noerr = 
#102 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('('))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "(*")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_887, __1 ) ) -> Some((input_887, ( () )))))
let try_Default_mlCOMMENTSTOP_noerr = 
#103 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (')'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "*)")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_886, __1 ) ) -> Some((input_886, ( () )))))
let rec try_Default_mlcomment_noerr = 
#101 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_mlcomment) (input))
) with
Not_found -> let res = (match (try_Default_mlCOMMENTSTART_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_878, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_881 -> (match (try_Default_mlCOMMENTSTOP_noerr (_filename) (_text) (input_881)) with
None -> let input_882 = input_881 in
let __1 = () in
(match (try_Default_mlcomment_noerr (_filename) (_text) (input_882)) with
None -> (match if ( (((<)) (input_882) (_len)) ) then ( let c = ((_get_char) (input_882)) in
Some((((succ) (input_882)), c)) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_884, __1 ) ) -> Some((input_884, ( () ))))
| ( _ok ) as __pat_var -> __pat_var)
| Some ( ( _, _ ) ) -> None))) (input_878)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_879, __2 ) ) -> (match (try_Default_mlCOMMENTSTOP_noerr (_filename) (_text) (input_879)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_880, __3 ) ) -> Some((input_880, ( () )))))) in
(Hashtbl.add (memo_Default_mlcomment) (input) (res)) ; res)
)
let try_Default_space_noerr = 
#20 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) (' '))) ((((||)) ((((=)) (c) ('\n'))) ((((||)) ((((=)) (c) ('\r'))) ((((=)) (c) ('\t')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let try_Default_spacing_noerr = 
#19 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_spacing) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_824 -> (match (match (try_Default_space_noerr (_filename) (_text) (input_824)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_826, __1 ) ) -> Some((input_826, ( () )))) with
None -> (try_Default_mlcomment_noerr (_filename) (_text) (input_824))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_823, __1 ) ) -> Some((input_823, ( () )))) in
(Hashtbl.add (memo_Default_spacing) (input) (res)) ; res)
)
let try_Default_comma_noerr = 
#63 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_comma) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (',')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_922, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_922)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_923, __2 ) ) -> Some((input_923, ( () ))))) in
(Hashtbl.add (memo_Default_comma) (input) (res)) ; res)
)
let try_Ocaml_keywords_spacing_noerr = 
#20 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_spacing) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_683 -> (match (match (try_Default_space_noerr (_filename) (_text) (input_683)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_685, __1 ) ) -> Some((input_685, ( () )))) with
None -> (try_Default_mlcomment_noerr (_filename) (_text) (input_683))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_682, __1 ) ) -> Some((input_682, ( () )))) in
(Hashtbl.add (memo_Ocaml_keywords_spacing) (input) (res)) ; res)
)
let try_Ocaml_keywords_CONS_noerr = 
#79 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_CONS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "::")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_748, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_748)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_749, __2 ) ) -> Some((input_749, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_CONS) (input) (res)) ; res)
)
let try_Default_colon_noerr = 
#67 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_colon) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_924, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_924)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_925, __2 ) ) -> Some((input_925, ( () ))))) in
(Hashtbl.add (memo_Default_colon) (input) (res)) ; res)
)
let try_Default_equal_noerr = 
#62 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_equal) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('=')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_915, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_915)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_916, __2 ) ) -> Some((input_916, ( () ))))) in
(Hashtbl.add (memo_Default_equal) (input) (res)) ; res)
)
let try_Default_laccol_noerr = 
#65 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_laccol) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('{')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_894, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_894)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_895, __2 ) ) -> Some((input_895, ( () ))))) in
(Hashtbl.add (memo_Default_laccol) (input) (res)) ; res)
)
let try_Default_lbracket_noerr = 
#71 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_lbracket) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('[')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_892, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_892)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_893, __2 ) ) -> Some((input_893, ( () ))))) in
(Hashtbl.add (memo_Default_lbracket) (input) (res)) ; res)
)
let try_Default_lparen_noerr = 
#69 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_lparen) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('(')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_888, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_888)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_889, __2 ) ) -> Some((input_889, ( () ))))) in
(Hashtbl.add (memo_Default_lparen) (input) (res)) ; res)
)
let try_Default_raccol_noerr = 
#66 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_raccol) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('}')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_849, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_849)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_850, __2 ) ) -> Some((input_850, ( () ))))) in
(Hashtbl.add (memo_Default_raccol) (input) (res)) ; res)
)
let try_Default_rbracket_noerr = 
#72 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rbracket) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (']')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_847, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_847)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_848, __2 ) ) -> Some((input_848, ( () ))))) in
(Hashtbl.add (memo_Default_rbracket) (input) (res)) ; res)
)
let try_Default_rparen_noerr = 
#70 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rparen) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (')')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_843, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_843)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_844, __2 ) ) -> Some((input_844, ( () ))))) in
(Hashtbl.add (memo_Default_rparen) (input) (res)) ; res)
)
let try_Default_semi_noerr = 
#68 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_semi) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (';')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_841, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_841)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_842, __2 ) ) -> Some((input_842, ( () ))))) in
(Hashtbl.add (memo_Default_semi) (input) (res)) ; res)
)
let try_Default_underscore_noerr = 
#82 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_underscore) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_760, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_760)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_761, __2 ) ) -> Some((input_761, ( () ))))) in
(Hashtbl.add (memo_Default_underscore) (input) (res)) ; res)
)
let try_Ocaml_keywords_AS_noerr = 
#51 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_AS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "as")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_754, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_754)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_755, __2 ) ) -> Some((input_755, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_AS) (input) (res)) ; res)
)
let try_Default_stringcharspecial_noerr = 
#33 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringcharspecial) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('n')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_795, __1 ) ) -> Some((input_795, 
#34 "default.trx"
( '\n'  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('r')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_794, __1 ) ) -> Some((input_794, 
#34 "default.trx"
( '\r'  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('t')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_793, __1 ) ) -> Some((input_793, 
#34 "default.trx"
( '\t'  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_792, __1 ) ) -> Some((input_792, 
#35 "default.trx"
( '\''  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_791, __1 ) ) -> Some((input_791, 
#35 "default.trx"
( '\"'  )))) with
None -> (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_790, __1 ) ) -> Some((input_790, 
#35 "default.trx"
( '\\'  )))) with
None -> (match (Trx_runtime.while_primary_noerr (true) ((fun input_789 -> if ( (((<)) (input_789) (_len)) ) then ( let c = ((_get_char) (input_789)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_789)), c)) ) else ( None ) ) else ( None ))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_788, __1 ) ) -> Some((input_788, 
#36 "default.trx"
( char_of_int (Tgrammar.int_of_chars __1)  ))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_stringcharspecial) (input) (res)) ; res)
)
let try_Default_singlequotechar__noerr = 
#40 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_singlequotechar_) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_832, __1 ) ) -> (match (try_Default_stringcharspecial_noerr (_filename) (_text) (input_832)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_833, __2 ) ) -> Some((input_833, 
#41 "default.trx"
( __2  ))))) with
None -> (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\\'))) ((((=)) (c) ('\'')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> let input_830 = input in
let __1 = () in
if ( (((<)) (input_830) (_len)) ) then ( let c = ((_get_char) (input_830)) in
Some((((succ) (input_830)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_singlequotechar_) (input) (res)) ; res)
)
let try_Default_charsinglequote_noerr = 
#46 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_charsinglequote) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_926, __1 ) ) -> (match (try_Default_singlequotechar__noerr (_filename) (_text) (input_926)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_927, __2 ) ) -> (match if ( (((<)) (input_927) (_len)) ) then ( let c = ((_get_char) (input_927)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input_927)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_928, __3 ) ) -> Some((input_928, 
#46 "default.trx"
( __2  )))))) in
(Hashtbl.add (memo_Default_charsinglequote) (input) (res)) ; res)
)
let try_Default_strfloat_noerr = 
#97 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_strfloat) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> Some((input, None))
| Some ( ( input_814, r ) ) -> Some((input_814, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_802, __1 ) ) -> (match (match (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_813 -> if ( (((<)) (input_813) (_len)) ) then ( let c = ((_get_char) (input_813)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_813)), c)) ) else ( None ) ) else ( None ))) (input_802)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_809, __1 ) ) -> (match if ( (((<)) (input_809) (_len)) ) then ( let c = ((_get_char) (input_809)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_809)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_810, __2 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_812 -> if ( (((<)) (input_812) (_len)) ) then ( let c = ((_get_char) (input_812)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_812)), c)) ) else ( None ) ) else ( None ))) (input_810)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_811, __3 ) ) -> Some((input_811, ()))))) with
None -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_808 -> if ( (((<)) (input_808) (_len)) ) then ( let c = ((_get_char) (input_808)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_808)), c)) ) else ( None ) ) else ( None ))) (input_802)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_804, __1 ) ) -> (match if ( (((<)) (input_804) (_len)) ) then ( let c = ((_get_char) (input_804)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_804)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_805, __2 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_807 -> if ( (((<)) (input_807) (_len)) ) then ( let c = ((_get_char) (input_807)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_807)), c)) ) else ( None ) ) else ( None ))) (input_805)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_806, __3 ) ) -> Some((input_806, ())))))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_803, __2 ) ) -> Some((input_803, (_get_sub (input) ((((-)) (input_803) (input)))))))) in
(Hashtbl.add (memo_Default_strfloat) (input) (res)) ; res)
)
let try_Default_float_noerr = 
#98 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_float) (input))
) with
Not_found -> let res = (match (try_Default_strfloat_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_914, __1 ) ) -> Some((input_914, 
#98 "default.trx"
( float_of_string __1  )))) in
(Hashtbl.add (memo_Default_float) (input) (res)) ; res)
)
let try_Default_strint_noerr = 
#94 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_strint) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> Some((input, None))
| Some ( ( input_772, r ) ) -> Some((input_772, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_769, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_771 -> if ( (((<)) (input_771) (_len)) ) then ( let c = ((_get_char) (input_771)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_771)), c)) ) else ( None ) ) else ( None ))) (input_769)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_770, __2 ) ) -> Some((input_770, (_get_sub (input) ((((-)) (input_770) (input)))))))) in
(Hashtbl.add (memo_Default_strint) (input) (res)) ; res)
)
let try_Default_int_noerr = 
#95 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_int) (input))
) with
Not_found -> let res = (match (try_Default_strint_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_909, __1 ) ) -> Some((input_909, 
#95 "default.trx"
( int_of_string __1  )))) in
(Hashtbl.add (memo_Default_int) (input) (res)) ; res)
)
let try_Default_stringchar_noerr = 
#37 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringchar) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_798, __1 ) ) -> (match (try_Default_stringcharspecial_noerr (_filename) (_text) (input_798)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_799, __2 ) ) -> Some((input_799, 
#38 "default.trx"
( __2  ))))) with
None -> (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\\'))) ((((=)) (c) ('"')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
None -> let input_796 = input in
let __1 = () in
if ( (((<)) (input_796) (_len)) ) then ( let c = ((_get_char) (input_796)) in
Some((((succ) (input_796)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_stringchar) (input) (res)) ; res)
)
let try_Default_stringnosp_noerr = 
#28 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringnosp) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_784, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_787 -> (try_Default_stringchar_noerr (_filename) (_text) (input_787)))) (input_784)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_785, __2 ) ) -> (match if ( (((<)) (input_785) (_len)) ) then ( let c = ((_get_char) (input_785)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input_785)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_786, __3 ) ) -> Some((input_786, 
#28 "default.trx"
( Tgrammar.string_of_chars __2  )))))) in
(Hashtbl.add (memo_Default_stringnosp) (input) (res)) ; res)
)
let try_Default_string_noerr = 
#27 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_string) (input))
) with
Not_found -> let res = (match (try_Default_stringnosp_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_800, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_800)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_801, __2 ) ) -> Some((input_801, 
#27 "default.trx"
( __1  ))))) in
(Hashtbl.add (memo_Default_string) (input) (res)) ; res)
)
let try_Ocaml_parser_spacing_noerr = 
#35 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_spacing) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_150 -> (match (match (try_Default_space_noerr (_filename) (_text) (input_150)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_152, __1 ) ) -> Some((input_152, ( () )))) with
None -> (try_Default_mlcomment_noerr (_filename) (_text) (input_150))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_149, __1 ) ) -> Some((input_149, ( () )))) in
(Hashtbl.add (memo_Ocaml_parser_spacing) (input) (res)) ; res)
)
let try_Ocaml_parser_unit_noerr = 
#38 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_unit) (input))
) with
Not_found -> let res = (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_145, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_145)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_146, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_146)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_147, __3 ) ) -> Some((input_147, ( () )))))) in
(Hashtbl.add (memo_Ocaml_parser_unit) (input) (res)) ; res)
)
let try_Ocaml_parser_const_noerr = 
#39 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_const) (input))
) with
Not_found -> let res = (match (match (try_Default_float_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_350, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_350)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_351, __2 ) ) -> Some((input_351, 
#40 "ocaml_parser.trx"
( Float __1  ))))) with
None -> (match (match (try_Default_int_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_348, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_348)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_349, __2 ) ) -> Some((input_349, 
#41 "ocaml_parser.trx"
( Int __1  ))))) with
None -> (match (match (try_Default_string_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_346, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_346)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_347, __2 ) ) -> Some((input_347, 
#42 "ocaml_parser.trx"
( String __1  ))))) with
None -> (match (match (try_Default_charsinglequote_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_344, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_344)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_345, __2 ) ) -> Some((input_345, 
#44 "ocaml_parser.trx"
( Char (__1)  ))))) with
None -> (match (match (try_Ocaml_parser_unit_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_343, __1 ) ) -> Some((input_343, 
#45 "ocaml_parser.trx"
( Unit  )))) with
None -> (match (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "false")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_341, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_341)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_342, __2 ) ) -> Some((input_342, 
#46 "ocaml_parser.trx"
( Bool false  ))))) with
None -> (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "true")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_339, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_339)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_340, __2 ) ) -> Some((input_340, 
#47 "ocaml_parser.trx"
( Bool true  )))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_const) (input) (res)) ; res)
)
let try_Ocaml_parser_mlIdent_cont_noerr = 
#50 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((=)) (c) ('_'))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('\'')))))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let try_Ocaml_parser_capMlIdent__noerr = 
#116 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_capMlIdent_) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('`'))) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_353, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_355 -> (try_Ocaml_parser_mlIdent_cont_noerr (_filename) (_text) (input_355)))) (input_353)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_354, __2 ) ) -> Some((input_354, (_get_sub (input) ((((-)) (input_354) (input)))))))) in
(Hashtbl.add (memo_Ocaml_parser_capMlIdent_) (input) (res)) ; res)
)
let try_Ocaml_parser_constructorName_noerr = 
#121 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_constructorName) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr (false) ((fun input_336 -> (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input_336)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_337, __1 ) ) -> (match if ( (((<)) (input_337) (_len)) ) then ( let c = ((_get_char) (input_337)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_337)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_338, __2 ) ) -> Some((input_338, 
#121 "ocaml_parser.trx"
( __1 ))))))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_332, __1 ) ) -> (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input_332)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_333, __2 ) ) -> (match if ( (((<)) (input_333) (_len)) ) then ( let c = ((_get_char) (input_333)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_333)), c)) ) else ( None ) ) else ( None ) with
None -> let input_334 = input_333 in
let __3 = () in
(match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_334)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_335, __4 ) ) -> Some((input_335, 
#121 "ocaml_parser.trx"
( __1 @ [__2]  ))))
| Some ( ( _, _ ) ) -> None))) in
(Hashtbl.add (memo_Ocaml_parser_constructorName) (input) (res)) ; res)
)
let try_Ocaml_keywords_KEYWORDS_noerr = 
#22 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_KEYWORDS) (input))
) with
Not_found -> let res = if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'~' -> Some(((((+)) (input) (1)), "~"))
| '}' -> Some(((((+)) (input) (1)), "}"))
| '|' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'|' -> Some(((((+)) (input) (2)), "||"))
| ']' -> Some(((((+)) (input) (2)), "|]"))
| _ -> Some(((((+)) (input) (1)), "|"))) ) else ( Some(((((+)) (input) (1)), "|")) )
| '{' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('<'))) (true)))) ) then ( Some(((((+)) (input) (2)), "{<")) ) else ( Some(((((+)) (input) (1)), "{")) )
| 'w' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "with")) ) else ( None )
| 'h' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (5)), "while")) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))) ) then ( Some(((((+)) (input) (4)), "when")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )
| 'v' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (7)), "virtual")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) (true)))) ) then ( Some(((((+)) (input) (3)), "val")) ) else ( None )
| _ -> None) ) else ( None )
| 't' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'y' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "type")) ) else ( None )
| 'r' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'y' -> Some(((((+)) (input) (3)), "try"))
| 'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))) ) then ( Some(((((+)) (input) (4)), "true")) ) else ( None )
| _ -> None) ) else ( None )
| 'o' -> Some(((((+)) (input) (2)), "to"))
| 'h' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "then")) ) else ( None )
| _ -> None) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "struct")) ) else ( None )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) (true)))) ) then ( Some(((((+)) (input) (3)), "sig")) ) else ( None )
| _ -> None) ) else ( None )
| 'r' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "rec")) ) else ( None )
| 'p' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('v'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (7)), "private")) ) else ( None )
| 'o' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'r' -> Some(((((+)) (input) (2)), "or"))
| 'p' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "open")) ) else ( None )
| 'f' -> Some(((((+)) (input) (2)), "of"))
| 'b' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('j'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "object")) ) else ( None )
| _ -> None) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('w'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "new")) ) else ( None )
| 'm' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (7)), "mutable")) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "module")) ) else ( Some(((((+)) (input) (3)), "mod")) ) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "method")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('h'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "match")) ) else ( None )
| _ -> None) ) else ( None )
| 'l' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "lxor")) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'r' -> Some(((((+)) (input) (3)), "lsr"))
| 'l' -> Some(((((+)) (input) (3)), "lsl"))
| _ -> None) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "lor")) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))) ) then ( Some(((((+)) (input) (3)), "let")) ) else ( None )
| 'a' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'z' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('y'))) (true)))) ) then ( Some(((((+)) (input) (4)), "lazy")) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (4)), "land")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )
| 'i' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'n' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (11))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('z'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (9))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (10))))) ('r'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (11)), "initializer")) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'h' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (7)), "inherit")) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'c' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (7)), "include")) ) else ( Some(((((+)) (input) (2)), "in")) )
| _ -> Some(((((+)) (input) (2)), "in"))) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'f' -> Some(((((+)) (input) (2)), "if"))
| _ -> None) ) else ( None )
| 'f' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) (true)))) ) then ( if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) (true)))))) ) then ( if ( (((<)) ((((+)) (input) (5))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (5)))) with
'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (7)), "functor")) ) else ( Some(((((+)) (input) (3)), "fun")) )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (8)), "function")) ) else ( Some(((((+)) (input) (3)), "fun")) )
| _ -> Some(((((+)) (input) (3)), "fun"))) ) else ( Some(((((+)) (input) (3)), "fun")) ) ) else ( Some(((((+)) (input) (3)), "fun")) ) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "for")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "false")) ) else ( None )
| _ -> None) ) else ( None )
| 'e' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (8)), "external")) ) else ( None )
| 'c' -> if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (9)), "exception")) ) else ( None )
| _ -> None) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (3)), "end")) ) else ( None )
| 'l' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "else")) ) else ( None )
| _ -> None) ) else ( None )
| 'd' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) (true)))) ) then ( if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'w' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('o'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "downto")) ) else ( Some(((((+)) (input) (2)), "do")) )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))) ) then ( Some(((((+)) (input) (4)), "done")) ) else ( Some(((((+)) (input) (2)), "do")) )
| _ -> Some(((((+)) (input) (2)), "do"))) ) else ( Some(((((+)) (input) (2)), "do")) ) ) else ( None )
| 'c' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (10))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (9))))) ('t'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (10)), "constraint")) ) else ( None )
| 'l' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('s'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "class")) ) else ( None )
| _ -> None) ) else ( None )
| 'b' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (5)), "begin")) ) else ( None )
| 'a' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
's' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "assert")) ) else ( Some(((((+)) (input) (2)), "as")) )
| 'r' -> Some(((((+)) (input) (3)), "asr"))
| _ -> Some(((((+)) (input) (2)), "as"))) ) else ( Some(((((+)) (input) (2)), "as")) )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (3)), "and")) ) else ( None )
| _ -> None) ) else ( None )
| '`' -> Some(((((+)) (input) (1)), "`"))
| '_' -> Some(((((+)) (input) (1)), "_"))
| ']' -> Some(((((+)) (input) (1)), "]"))
| '[' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'|' -> Some(((((+)) (input) (2)), "[|"))
| '>' -> Some(((((+)) (input) (2)), "[>"))
| '<' -> Some(((((+)) (input) (2)), "[<"))
| _ -> Some(((((+)) (input) (1)), "["))) ) else ( Some(((((+)) (input) (1)), "[")) )
| '?' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('?'))) (true)))) ) then ( Some(((((+)) (input) (2)), "??")) ) else ( Some(((((+)) (input) (1)), "?")) )
| '>' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'}' -> Some(((((+)) (input) (2)), ">}"))
| ']' -> Some(((((+)) (input) (2)), ">]"))
| _ -> Some(((((+)) (input) (1)), ">"))) ) else ( Some(((((+)) (input) (1)), ">")) )
| '=' -> Some(((((+)) (input) (1)), "="))
| '<' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))) ) then ( Some(((((+)) (input) (2)), "<-")) ) else ( Some(((((+)) (input) (1)), "<")) )
| ';' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (';'))) (true)))) ) then ( Some(((((+)) (input) (2)), ";;")) ) else ( Some(((((+)) (input) (1)), ";")) )
| ':' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'>' -> Some(((((+)) (input) (2)), ":>"))
| '=' -> Some(((((+)) (input) (2)), ":="))
| ':' -> Some(((((+)) (input) (2)), "::"))
| _ -> Some(((((+)) (input) (1)), ":"))) ) else ( Some(((((+)) (input) (1)), ":")) )
| '.' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))) ) then ( Some(((((+)) (input) (2)), "..")) ) else ( Some(((((+)) (input) (1)), ".")) )
| '-' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'>' -> Some(((((+)) (input) (2)), "->"))
| '.' -> Some(((((+)) (input) (2)), "-."))
| _ -> Some(((((+)) (input) (1)), "-"))) ) else ( Some(((((+)) (input) (1)), "-")) )
| ',' -> Some(((((+)) (input) (1)), ","))
| '+' -> Some(((((+)) (input) (1)), "+"))
| '*' -> Some(((((+)) (input) (1)), "*"))
| ')' -> Some(((((+)) (input) (1)), ")"))
| '(' -> Some(((((+)) (input) (1)), "("))
| '\'' -> Some(((((+)) (input) (1)), "'"))
| '&' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('&'))) (true)))) ) then ( Some(((((+)) (input) (2)), "&&")) ) else ( Some(((((+)) (input) (1)), "&")) )
| '#' -> Some(((((+)) (input) (1)), "#"))
| _ -> None) ) else ( None ) in
(Hashtbl.add (memo_Ocaml_keywords_KEYWORDS) (input) (res)) ; res)
)
let try_Ocaml_parser_mlIdent_aux__noerr = 
#51 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_aux_) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((=)) (c) ('_')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_304, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_306 -> (try_Ocaml_parser_mlIdent_cont_noerr (_filename) (_text) (input_306)))) (input_304)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_305, __2 ) ) -> Some((input_305, (_get_sub (input) ((((-)) (input_305) (input)))))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_303, __1 ) ) -> Some((input_303, 
#51 "ocaml_parser.trx"
( __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_aux_) (input) (res)) ; res)
)
let try_Ocaml_parser_mlIdent_aux_noerr = 
#52 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_aux) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_mlIdent_aux__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_307, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_307)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_308, __2 ) ) -> Some((input_308, 
#52 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_aux) (input) (res)) ; res)
)
let try_Ocaml_parser_mlIdent_noerr = 
#53 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_keywords_KEYWORDS_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_321, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_cont_noerr (_filename) (_text) (input_321)) with
None -> let input_322 = input_321 in
let __2 = () in
Some((input_322, __1))
| Some ( ( _, _ ) ) -> None)) with
None -> let input_319 = input in
let __1 = () in
(match (try_Ocaml_parser_mlIdent_aux_noerr (_filename) (_text) (input_319)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_320, __2 ) ) -> Some((input_320, 
#53 "ocaml_parser.trx"
( __2  ))))
| Some ( ( _, _ ) ) -> None) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_313, __1 ) ) -> (match (match if ( (((<)) (input_313) (_len)) ) then ( let c = ((_get_char) (input_313)) in
if ( (((||)) ((((=)) (c) ('!'))) ((((||)) ((((=)) (c) ('$'))) ((((||)) ((((=)) (c) ('%'))) ((((||)) ((((=)) (c) ('&'))) ((((||)) ((((=)) (c) ('*'))) ((((||)) ((((&&)) ((((>=)) (c) ('+'))) ((((<=)) (c) ('.'))))) ((((||)) ((((=)) (c) ('/'))) ((((||)) ((((=)) (c) (':'))) ((((||)) ((((=)) (c) ('<'))) ((((||)) ((((=)) (c) ('='))) ((((||)) ((((=)) (c) ('>'))) ((((||)) ((((=)) (c) ('?'))) ((((||)) ((((=)) (c) ('@'))) ((((||)) ((((=)) (c) ('^'))) ((((||)) ((((=)) (c) ('|'))) ((((=)) (c) ('~')))))))))))))))))))))))))))))))) ) then ( Some((((succ) (input_313)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_316, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_318 -> if ( (((<)) (input_318) (_len)) ) then ( let c = ((_get_char) (input_318)) in
if ( (((||)) ((((=)) (c) ('!'))) ((((||)) ((((=)) (c) ('$'))) ((((||)) ((((=)) (c) ('%'))) ((((||)) ((((=)) (c) ('&'))) ((((||)) ((((=)) (c) ('*'))) ((((||)) ((((&&)) ((((>=)) (c) ('+'))) ((((<=)) (c) ('.'))))) ((((||)) ((((=)) (c) ('/'))) ((((||)) ((((=)) (c) (':'))) ((((||)) ((((=)) (c) ('<'))) ((((||)) ((((=)) (c) ('='))) ((((||)) ((((=)) (c) ('>'))) ((((||)) ((((=)) (c) ('?'))) ((((||)) ((((=)) (c) ('@'))) ((((||)) ((((=)) (c) ('^'))) ((((||)) ((((=)) (c) ('|'))) ((((=)) (c) ('~')))))))))))))))))))))))))))))))) ) then ( Some((((succ) (input_318)), c)) ) else ( None ) ) else ( None ))) (input_316)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_317, __2 ) ) -> Some((input_317, (_get_sub (input_313) ((((-)) (input_317) (input_313)))))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_314, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_314)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_315, __3 ) ) -> Some((input_315, 
#55 "ocaml_parser.trx"
( sprintf "(%s)" __2  ))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent) (input) (res)) ; res)
)
let try_Default_rightarrow_noerr = 
#86 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rightarrow) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "->")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_845, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_845)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_846, __2 ) ) -> Some((input_846, ( () ))))) in
(Hashtbl.add (memo_Default_rightarrow) (input) (res)) ; res)
)
let try_Ocaml_types_spacing_noerr = 
#19 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_spacing) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_123 -> (match (match (try_Default_space_noerr (_filename) (_text) (input_123)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_125, __1 ) ) -> Some((input_125, ( () )))) with
None -> (try_Default_mlcomment_noerr (_filename) (_text) (input_123))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_122, __1 ) ) -> Some((input_122, ( () )))) in
(Hashtbl.add (memo_Ocaml_types_spacing) (input) (res)) ; res)
)
let try_Ocaml_keywords_OF_noerr = 
#50 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_OF) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('f'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "of")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_714, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_714)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_715, __2 ) ) -> Some((input_715, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_OF) (input) (res)) ; res)
)
let try_Ocaml_types_typeIdent_cont_noerr = 
#30 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ))
let try_Ocaml_types_typeconstructor_noerr = 
#33 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeconstructor) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_88, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_90 -> (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_90)))) (input_88)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_89, __2 ) ) -> Some((input_89, (_get_sub (input) ((((-)) (input_89) (input)))))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_86, __1 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_86)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_87, __2 ) ) -> Some((input_87, 
#33 "ocaml_types.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_types_typeconstructor) (input) (res)) ; res)
)
let try_Ocaml_keywords_MUTABLE_noerr = 
#64 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MUTABLE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))))) ) then ( Some(((((+)) (input) (7)), "mutable")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_716, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_716)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_717, __2 ) ) -> Some((input_717, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_MUTABLE) (input) (res)) ; res)
)
let try_Ocaml_types_typeIdent_aux_noerr = 
#31 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeIdent_aux) (input))
) with
Not_found -> let res = (match (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_108, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_110 -> (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_110)))) (input_108)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_109, __2 ) ) -> Some((input_109, (_get_sub (input) ((((-)) (input_109) (input)))))))) with
None -> (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_105, __1 ) ) -> (match (Trx_runtime.while_primary_noerr_nores (true) ((fun input_107 -> (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_107)))) (input_105)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_106, __2 ) ) -> Some((input_106, (_get_sub (input) ((((-)) (input_106) (input))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typeIdent_aux) (input) (res)) ; res)
)
let try_Ocaml_types_typeIdent_noerr = 
#32 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeIdent) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_KEYWORDS_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_114, __1 ) ) -> (match (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_114)) with
None -> let input_115 = input_114 in
let __2 = () in
Some((input_115, __1))
| Some ( ( _, _ ) ) -> None)) with
None -> let input_111 = input in
let __1 = () in
(match (try_Ocaml_types_typeIdent_aux_noerr (_filename) (_text) (input_111)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_112, __2 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_112)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_113, __3 ) ) -> Some((input_113, 
#32 "ocaml_types.trx"
( __2  )))))
| Some ( ( _, _ ) ) -> None) in
(Hashtbl.add (memo_Ocaml_types_typeIdent) (input) (res)) ; res)
)
let try_Ocaml_types_BoolT_noerr = 
#28 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "bool")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_144, __1 ) ) -> Some((input_144, 
#28 "ocaml_types.trx"
( TypeBool  )))))
let try_Ocaml_types_FloatT_noerr = 
#25 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "float")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_143, __1 ) ) -> Some((input_143, 
#25 "ocaml_types.trx"
( TypeFloat  )))))
let try_Ocaml_types_Int64T_noerr = 
#24 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('6'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('4'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "int64")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_142, __1 ) ) -> Some((input_142, 
#24 "ocaml_types.trx"
( TypeInt64  )))))
let try_Ocaml_types_IntT_noerr = 
#23 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "int")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_141, __1 ) ) -> Some((input_141, 
#23 "ocaml_types.trx"
( TypeInt  )))))
let try_Ocaml_types_StringT_noerr = 
#26 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('g'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "string")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_140, __1 ) ) -> Some((input_140, 
#26 "ocaml_types.trx"
( TypeString  )))))
let try_Ocaml_types_UnitT_noerr = 
#27 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "unit")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_139, __1 ) ) -> Some((input_139, 
#27 "ocaml_types.trx"
( TypeUnit  )))))
let try_Ocaml_types_typeconst_noerr = 
#22 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeconst) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_IntT_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_Int64T_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_FloatT_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_StringT_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_UnitT_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_types_BoolT_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_91, __1 ) ) -> Some((input_91, 
#22 "ocaml_types.trx"
( TypeConst __1  )))) in
(Hashtbl.add (memo_Ocaml_types_typeconst) (input) (res)) ; res)
)
let rec try_Ocaml_types_typename_noerr = 
#35 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typename) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeconstructor_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_37, __1 ) ) -> (match if ( (((<)) (input_37) (_len)) ) then ( let c = ((_get_char) (input_37)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_37)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_38, __2 ) ) -> (match (try_Ocaml_types_typename_noerr (_filename) (_text) (input_38)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_39, __3 ) ) -> Some((input_39, 
#35 "ocaml_types.trx"
( __1 :: __3  )))))) with
None -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_36, __1 ) ) -> Some((input_36, 
#36 "ocaml_types.trx"
( [__1]  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typename) (input) (res)) ; res)
)
let try_Ocaml_types_typevar_noerr = 
#34 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevar) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_15, __1 ) ) -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input_15)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_16, __2 ) ) -> Some((input_16, 
#34 "ocaml_types.trx"
( TypeVar ("'" ^ __2)  ))))) in
(Hashtbl.add (memo_Ocaml_types_typevar) (input) (res)) ; res)
)
let try_Ocaml_types_typevarorname_noerr = 
#45 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevarorname) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typevar_noerr (_filename) (_text) (input)) with
None -> (match (match (match (try_Ocaml_types_typeconst_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_12, __1 ) ) -> (match (try_Ocaml_types_typeIdent_cont_noerr (_filename) (_text) (input_12)) with
None -> let input_13 = input_12 in
let __2 = () in
Some((input_13, __1))
| Some ( ( _, _ ) ) -> None)) with
None -> let input_10 = input in
let __1 = () in
(match (try_Ocaml_types_typename_noerr (_filename) (_text) (input_10)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_11, __2 ) ) -> Some((input_11, 
#45 "ocaml_types.trx"
( TypeName ([], __2)  ))))
| Some ( ( _, _ ) ) -> None) with
None -> (match (try_Ocaml_types_typeconst_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_8, __1 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_8)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_9, __2 ) ) -> Some((input_9, 
#45 "ocaml_types.trx"
( __1  )))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typevarorname) (input) (res)) ; res)
)
let rec try_Ocaml_types_typeSum_noerr = 
#97 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeSum) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typeconstructor_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_98, __1 ) ) -> (match if ( (((<)) (input_98) (_len)) ) then ( let c = ((_get_char) (input_98)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_98)), c)) ) else ( None ) ) else ( None ) with
None -> let input_99 = input_98 in
let __2 = () in
(match (match (match (try_Ocaml_keywords_OF_noerr (_filename) (_text) (input_99)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_101, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_101)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_102, __2 ) ) -> Some((input_102, 
#97 "ocaml_types.trx"
( __2 ))))) with
None -> Some((input_99, None))
| Some ( ( input_103, r ) ) -> Some((input_103, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_100, __3 ) ) -> Some((input_100, 
#97 "ocaml_types.trx"
( TypeConstructor [__1, __3]  ))))
| Some ( ( _, _ ) ) -> None)) in
(Hashtbl.add (memo_Ocaml_types_typeSum) (input) (res)) ; res)
)
and try_Ocaml_types_onetyperecord_noerr = 
#94 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_onetyperecord) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_MUTABLE_noerr (_filename) (_text) (input)) with
None -> Some((input, None))
| Some ( ( input_130, r ) ) -> Some((input_130, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_126, __1 ) ) -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input_126)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_127, __2 ) ) -> (match (try_Default_colon_noerr (_filename) (_text) (input_127)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_128, __3 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_128)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_129, __4 ) ) -> Some((input_129, 
#94 "ocaml_types.trx"
( (match __1 with None -> false | _ -> true), __2, __4  ))))))) in
(Hashtbl.add (memo_Ocaml_types_onetyperecord) (input) (res)) ; res)
)
and try_Ocaml_types_typerecord_aux_noerr = 
#95 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typerecord_aux) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_onetyperecord_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_17, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_21 -> (match (try_Default_semi_noerr (_filename) (_text) (input_21)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_22, __1 ) ) -> (match (try_Ocaml_types_onetyperecord_noerr (_filename) (_text) (input_22)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_23, __2 ) ) -> Some((input_23, 
#95 "ocaml_types.trx"
( __2  ))))))) (input_17)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_18, __2 ) ) -> (match (match (try_Default_semi_noerr (_filename) (_text) (input_18)) with
None -> Some((input_18, None))
| Some ( ( input_20, r ) ) -> Some((input_20, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_19, __3 ) ) -> Some((input_19, 
#95 "ocaml_types.trx"
( __1 ::__2  )))))) in
(Hashtbl.add (memo_Ocaml_types_typerecord_aux) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_aux_noerr = 
#72 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_aux) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeparam_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_65, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (true) ((fun input_67 -> (try_Ocaml_types_typename_noerr (_filename) (_text) (input_67)))) (input_65)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_66, __2 ) ) -> Some((input_66, 
#73 "ocaml_types.trx"
( match __2 with
| hd :: tl -> 
  List.fold_left (fun acc x -> TypeName ([acc], x)) (TypeName (__1, hd)) tl 
| _ -> assert false
 ))))) with
None -> (try_Ocaml_types_typedef_base_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_aux) (input) (res)) ; res)
)
and try_Ocaml_types_typeparam_noerr = 
#68 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeparam) (input))
) with
Not_found -> let res = (match (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_29, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_29)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_30, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_33 -> (match (try_Default_comma_noerr (_filename) (_text) (input_33)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_34, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_34)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_35, __2 ) ) -> Some((input_35, 
#69 "ocaml_types.trx"
( __2 ))))))) (input_30)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_31, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_31)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_32, __4 ) ) -> Some((input_32, 
#69 "ocaml_types.trx"
( __2 :: __3  ))))))) with
None -> (match (try_Ocaml_types_typedef_base_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_28, __1 ) ) -> Some((input_28, 
#70 "ocaml_types.trx"
( [__1]  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typeparam) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_noerr = 
#88 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typedef_no_arrow_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_69, __1 ) ) -> (match (try_Default_rightarrow_noerr (_filename) (_text) (input_69)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_70, __2 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_70)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_71, __3 ) ) -> Some((input_71, 
#89 "ocaml_types.trx"
( TypeArrow ( __1, __3)  )))))) with
None -> (match (try_Ocaml_types_typedef_no_arrow_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_68, __1 ) ) -> Some((input_68, 
#90 "ocaml_types.trx"
( __1  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_base_noerr = 
#64 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_base) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typeSum_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_typerecord_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_types_typevarorname_noerr (_filename) (_text) (input)) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_58, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_58)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_59, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_59)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_60, __3 ) ) -> Some((input_60, 
#66 "ocaml_types.trx"
( __2  ))))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_base) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_no_arrow_noerr = 
#81 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_no_arrow) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedef_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_52, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_54 -> (match if ( (((<)) (input_54) (_len)) ) then ( let c = ((_get_char) (input_54)) in
if ( (((=)) (c) ('*')) ) then ( Some((((succ) (input_54)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_55, __1 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_55)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_56, __2 ) ) -> (match (try_Ocaml_types_typedef_aux_noerr (_filename) (_text) (input_56)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_57, __3 ) ) -> Some((input_57, 
#81 "ocaml_types.trx"
( __3 )))))))) (input_52)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_53, __2 ) ) -> Some((input_53, 
#81 "ocaml_types.trx"
( match (__1::__2) with
    | [] -> failwith "@Ocaml_types.typedef_no_arrow : empty type tuple"
    | [td] -> td
    | tdl -> TypeTuple tdl
 ))))) in
(Hashtbl.add (memo_Ocaml_types_typedef_no_arrow) (input) (res)) ; res)
)
and try_Ocaml_types_typerecord_noerr = 
#101 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typerecord) (input))
) with
Not_found -> let res = (match (try_Default_laccol_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_24, __1 ) ) -> (match (match (try_Ocaml_types_typerecord_aux_noerr (_filename) (_text) (input_24)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_27, __1 ) ) -> Some((input_27, 
#101 "ocaml_types.trx"
( TypeRecord __1  )))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_25, __2 ) ) -> (match (try_Default_raccol_noerr (_filename) (_text) (input_25)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_26, __3 ) ) -> Some((input_26, 
#100 "ocaml_types.trx"
( __2  )))))) in
(Hashtbl.add (memo_Ocaml_types_typerecord) (input) (res)) ; res)
)
let try_Ocaml_parser_type_noerr = 
#123 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_type) (input))
) with
Not_found -> let res = (try_Ocaml_types_typedef_noerr (_filename) (_text) (input)) in
(Hashtbl.add (memo_Ocaml_parser_type) (input) (res)) ; res)
)
let rec try_Ocaml_parser_pattern_aux_noerr = 
#178 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_l_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_211, __1 ) ) -> Some((input_211, 
#179 "ocaml_parser.trx"
( match __1 with
     | [t] -> t
     | _ -> PatTuple __1
   )))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_aux_aux_noerr = 
#127 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_aux) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_210, __1 ) ) -> Some((input_210, 
#129 "ocaml_parser.trx"
( PatVar (Ident.source __1)  )))) with
None -> (match (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_203, __1 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_203)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_204, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_204)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_207, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_207)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_208, __2 ) ) -> Some((input_208, ())))) with
None -> Some((input_204, None))
| Some ( ( input_209, r ) ) -> Some((input_209, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_205, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_205)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_206, __4 ) ) -> Some((input_206, 
#131 "ocaml_parser.trx"
( __2  ))))))) with
None -> (match (match (try_Default_underscore_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_202, __1 ) ) -> Some((input_202, 
#133 "ocaml_parser.trx"
( PatAny  )))) with
None -> (match (match (try_Ocaml_parser_const_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_201, __1 ) ) -> Some((input_201, 
#135 "ocaml_parser.trx"
( PatConst __1  )))) with
None -> (match (match (try_Default_laccol_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_188, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_188)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_189, __2 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_189)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_190, __3 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_190)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_191, __4 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_196 -> (match (try_Default_semi_noerr (_filename) (_text) (input_196)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_197, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_197)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_198, __2 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_198)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_199, __3 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_199)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_200, __4 ) ) -> Some((input_200, 
#137 "ocaml_parser.trx"
( __2, __4 ))))))))) (input_191)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_192, __5 ) ) -> (match (match (try_Default_semi_noerr (_filename) (_text) (input_192)) with
None -> Some((input_192, None))
| Some ( ( input_195, r ) ) -> Some((input_195, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_193, __6 ) ) -> (match (try_Default_raccol_noerr (_filename) (_text) (input_193)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_194, __7 ) ) -> Some((input_194, 
#138 "ocaml_parser.trx"
( PatRecord ((__2, __4)::__5)
     )))))))))) with
None -> (match (match (try_Default_lbracket_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_179, __1 ) ) -> (match (match (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_179)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_182, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_184 -> (match (try_Default_semi_noerr (_filename) (_text) (input_184)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_185, __1 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_185)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_186, __2 ) ) -> Some((input_186, 
#142 "ocaml_parser.trx"
( __2 ))))))) (input_182)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_183, __2 ) ) -> Some((input_183, 
#142 "ocaml_parser.trx"
( __1, __2 ))))) with
None -> Some((input_179, None))
| Some ( ( input_187, r ) ) -> Some((input_187, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_180, __2 ) ) -> (match (try_Default_rbracket_noerr (_filename) (_text) (input_180)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_181, __3 ) ) -> Some((input_181, 
#143 "ocaml_parser.trx"
( match __2 with
       | None -> PatEmptyList
       | Some (a, l) ->
           PatList (a, List.fold_right (fun e accu -> PatList (e, accu)) l PatEmptyList)
     )))))) with
None -> (match (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_171, __1 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_171)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_172, __2 ) ) -> (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input_172)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_173, __3 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_176 -> (match (try_Default_comma_noerr (_filename) (_text) (input_176)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_177, __1 ) ) -> (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input_177)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_178, __2 ) ) -> Some((input_178, 
#150 "ocaml_parser.trx"
( __2 ))))))) (input_173)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_174, __4 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_174)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_175, __5 ) ) -> Some((input_175, 
#151 "ocaml_parser.trx"
( PatConstructor (List.map Ident.source __1, __3::__4)
     )))))))) with
None -> (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_168, __1 ) ) -> (match (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input_168)) with
None -> Some((input_168, None))
| Some ( ( input_170, r ) ) -> Some((input_170, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_169, __2 ) ) -> Some((input_169, 
#156 "ocaml_parser.trx"
( PatConstructor (List.map Ident.source __1, match __2 with Some x -> [x] | None -> [])
     )))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_163, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_165 -> (match (try_Ocaml_keywords_AS_noerr (_filename) (_text) (input_165)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_166, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_166)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_167, __2 ) ) -> Some((input_167, 
#159 "ocaml_parser.trx"
( __2 ))))))) (input_163)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_164, __2 ) ) -> Some((input_164, 
#160 "ocaml_parser.trx"
( List.fold_left (fun accu e -> PatAs (accu, Ident.source e)) __1 __2
   ))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_aux) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_cons_noerr = 
#164 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_cons) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_153, __1 ) ) -> (match (match (match (try_Ocaml_keywords_CONS_noerr (_filename) (_text) (input_153)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_155, __1 ) ) -> (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input_155)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_156, __2 ) ) -> Some((input_156, 
#164 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_153, None))
| Some ( ( input_157, r ) ) -> Some((input_157, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_154, __2 ) ) -> Some((input_154, 
#165 "ocaml_parser.trx"
( match __2 with
     | None -> __1
     | Some x -> PatList (__1, x)
   ))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_cons) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_aux_l_noerr = 
#171 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_l) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_cons_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_158, __1 ) ) -> (match (match (match (try_Default_comma_noerr (_filename) (_text) (input_158)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_160, __1 ) ) -> (match (try_Ocaml_parser_pattern_aux_l_noerr (_filename) (_text) (input_160)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_161, __2 ) ) -> Some((input_161, 
#171 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_158, None))
| Some ( ( input_162, r ) ) -> Some((input_162, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_159, __2 ) ) -> Some((input_159, 
#172 "ocaml_parser.trx"
( match __2 with
     | None -> [__1]
     | Some s -> __1::s
   ))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_l) (input) (res)) ; res)
)
let try_Default_mlCOMMENTSTART = 
#102 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('('))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('*'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "(*")) ) else ( None )) (input) ("\"(*\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1839, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1839, ( () )), ((Trx_runtime.emptyError) (input_1839))))))))
let try_Default_mlCOMMENTSTOP = 
#103 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (')'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "*)")) ) else ( None )) (input) ("\"*)\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1838, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1838, ( () )), ((Trx_runtime.emptyError) (input_1838))))))))
let rec try_Default_mlcomment = 
#101 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_mlcomment_err) (input))
) with
Not_found -> let res = (match (try_Default_mlCOMMENTSTART (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1830, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1833 -> (match (try_Default_mlCOMMENTSTOP (_filename) (_text) (input_1833)) with
Trx_runtime.Fail ( ( err ) ) -> let input_1834 = input_1833 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_mlcomment (_filename) (_text) (input_1834)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1837, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1837, __1), ((Trx_runtime.emptyError) (input_1837))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1834) (_len)) ) then ( let c = ((_get_char) (input_1834)) in
Some((((succ) (input_1834)), c)) ) else ( None )) (input_1834) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1836, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1836, ( () )), ((Trx_runtime.emptyError) (input_1836)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1835, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1835, __2), ((Trx_runtime.emptyError) (input_1835)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_1830)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1831, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlCOMMENTSTOP (_filename) (_text) (input_1831)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1832, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1832, ( () )), ((Trx_runtime.emptyError) (input_1832))))))))))))) in
(Hashtbl.add (memo_Default_mlcomment_err) (input) (res)) ; res)
)
let try_Default_space = 
#20 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) (' '))) ((((||)) ((((=)) (c) ('\n'))) ((((||)) ((((=)) (c) ('\r'))) ((((=)) (c) ('\t')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'\t'")) ; Trx_runtime.Expected(("'\n'")) ; Trx_runtime.Expected(("'\r'")) ; Trx_runtime.Expected(("' '")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1779, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1779, __1), ((Trx_runtime.emptyError) (input_1779))))))))
let try_Ocaml_parser_spacing = 
#35 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_spacing_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_1102 -> (match (match (try_Default_space (_filename) (_text) (input_1102)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1104, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1104, ( () )), ((Trx_runtime.emptyError) (input_1104))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlcomment (_filename) (_text) (input_1102)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1103, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1103, __1), ((Trx_runtime.emptyError) (input_1103)))))))))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1101, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1101, ( () )), ((Trx_runtime.emptyError) (input_1101))))))) in
(Hashtbl.add (memo_Ocaml_parser_spacing_err) (input) (res)) ; res)
)
let try_Ocaml_parser_FMINUS = 
#409 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FMINUS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "-.")) ) else ( None )) (input) ("\"-.\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1533, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1533)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1534, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1534, 
#409 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1534)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_FMINUS_err) (input) (res)) ; res)
)
let try_Ocaml_parser_IMINUS = 
#404 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IMINUS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input) (1)), "-")) ) else ( None )) (input) ("\"-\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1519, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1519)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1520, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1520, 
#404 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1520)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_IMINUS_err) (input) (res)) ; res)
)
let try_Ocaml_parser_MINUS = 
#399 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MINUS_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_FMINUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1444, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1444, __1), ((Trx_runtime.emptyError) (input_1444))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_IMINUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1443, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1443, __1), ((Trx_runtime.emptyError) (input_1443)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_MINUS_err) (input) (res)) ; res)
)
let try_Ocaml_parser_FPLUS = 
#408 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FPLUS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('+'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "+.")) ) else ( None )) (input) ("\"+.\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1529, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1529)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1530, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1530, 
#408 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1530)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_FPLUS_err) (input) (res)) ; res)
)
let try_Ocaml_parser_IPLUS = 
#403 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IPLUS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('+'))) (true)))) ) then ( Some(((((+)) (input) (1)), "+")) ) else ( None )) (input) ("\"+\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1515, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1515)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1516, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1516, 
#403 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1516)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_IPLUS_err) (input) (res)) ; res)
)
let try_Ocaml_parser_PLUS = 
#398 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_PLUS_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_FPLUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1372, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1372, __1), ((Trx_runtime.emptyError) (input_1372))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_IPLUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1371, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1371, __1), ((Trx_runtime.emptyError) (input_1371)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_PLUS_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_aro = 
#388 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_aro_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('@'))) (true)))) ) then ( Some(((((+)) (input) (1)), "@")) ) else ( None )) (input) ("\"@\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1248, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1248)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1249, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1249, 
#388 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1249)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_aro_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_concat = 
#387 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_concat_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('^'))) (true)))) ) then ( Some(((((+)) (input) (1)), "^")) ) else ( None )) (input) ("\"^\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1246, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1246)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1247, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1247, 
#387 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1247)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_concat_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_logic = 
#389 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_logic_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "asr")) ) else ( None )) (input) ("\"asr\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1240, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1240)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1241, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1241, 
#389 "ocaml_parser.trx"
( "asr"  )), ((Trx_runtime.emptyError) (input_1241)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_logic_err) (input) (res)) ; res)
)
let try_Ocaml_parser_InfOpLevel3 = 
#370 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel3_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_PLUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1501, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1501, __1), ((Trx_runtime.emptyError) (input_1501))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_MINUS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1500, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1500, __1), ((Trx_runtime.emptyError) (input_1500))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_concat (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1499, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1499, __1), ((Trx_runtime.emptyError) (input_1499))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_aro (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1498, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1498, __1), ((Trx_runtime.emptyError) (input_1498))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_op_logic (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1497, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1497, __1), ((Trx_runtime.emptyError) (input_1497)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1496, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1496, 
#371 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )), ((Trx_runtime.emptyError) (input_1496))))))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel3_err) (input) (res)) ; res)
)
let try_Default_spacing = 
#19 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_spacing_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_1776 -> (match (match (try_Default_space (_filename) (_text) (input_1776)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1778, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1778, ( () )), ((Trx_runtime.emptyError) (input_1778))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlcomment (_filename) (_text) (input_1776)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1777, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1777, __1), ((Trx_runtime.emptyError) (input_1777)))))))))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1775, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1775, ( () )), ((Trx_runtime.emptyError) (input_1775))))))) in
(Hashtbl.add (memo_Default_spacing_err) (input) (res)) ; res)
)
let try_Default_colon = 
#67 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_colon_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (':')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("':'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1876, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1876)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1877, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1877, ( () )), ((Trx_runtime.emptyError) (input_1877)))))))))) in
(Hashtbl.add (memo_Default_colon_err) (input) (res)) ; res)
)
let try_Default_comma = 
#63 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_comma_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (',')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("','")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1874, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1874)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1875, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1875, ( () )), ((Trx_runtime.emptyError) (input_1875)))))))))) in
(Hashtbl.add (memo_Default_comma_err) (input) (res)) ; res)
)
let try_Default_equal = 
#62 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_equal_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('=')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'='")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1867, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1867)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1868, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1868, ( () )), ((Trx_runtime.emptyError) (input_1868)))))))))) in
(Hashtbl.add (memo_Default_equal_err) (input) (res)) ; res)
)
let try_Default_laccol = 
#65 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_laccol_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('{')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'{'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1846, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1846)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1847, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1847, ( () )), ((Trx_runtime.emptyError) (input_1847)))))))))) in
(Hashtbl.add (memo_Default_laccol_err) (input) (res)) ; res)
)
let try_Default_lbracket = 
#71 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_lbracket_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('[')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'['")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1844, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1844)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1845, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1845, ( () )), ((Trx_runtime.emptyError) (input_1845)))))))))) in
(Hashtbl.add (memo_Default_lbracket_err) (input) (res)) ; res)
)
let try_Default_lparen = 
#69 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_lparen_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('(')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'('")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1840, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1840)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1841, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1841, ( () )), ((Trx_runtime.emptyError) (input_1841)))))))))) in
(Hashtbl.add (memo_Default_lparen_err) (input) (res)) ; res)
)
let try_Default_raccol = 
#66 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_raccol_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('}')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'}'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1801, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1801)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1802, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1802, ( () )), ((Trx_runtime.emptyError) (input_1802)))))))))) in
(Hashtbl.add (memo_Default_raccol_err) (input) (res)) ; res)
)
let try_Default_rbracket = 
#72 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rbracket_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (']')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("']'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1799, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1799)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1800, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1800, ( () )), ((Trx_runtime.emptyError) (input_1800)))))))))) in
(Hashtbl.add (memo_Default_rbracket_err) (input) (res)) ; res)
)
let try_Default_rparen = 
#70 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rparen_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (')')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("')'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1795, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1795)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1796, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1796, ( () )), ((Trx_runtime.emptyError) (input_1796)))))))))) in
(Hashtbl.add (memo_Default_rparen_err) (input) (res)) ; res)
)
let try_Default_semi = 
#68 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_semi_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) (';')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("';'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1793, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1793)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1794, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1794, ( () )), ((Trx_runtime.emptyError) (input_1794)))))))))) in
(Hashtbl.add (memo_Default_semi_err) (input) (res)) ; res)
)
let try_Default_underscore = 
#82 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_underscore_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'_'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1712, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1712)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1713, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1713, ( () )), ((Trx_runtime.emptyError) (input_1713)))))))))) in
(Hashtbl.add (memo_Default_underscore_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_spacing = 
#20 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_spacing_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_1635 -> (match (match (try_Default_space (_filename) (_text) (input_1635)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1637, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1637, ( () )), ((Trx_runtime.emptyError) (input_1637))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlcomment (_filename) (_text) (input_1635)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1636, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1636, __1), ((Trx_runtime.emptyError) (input_1636)))))))))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1634, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1634, ( () )), ((Trx_runtime.emptyError) (input_1634))))))) in
(Hashtbl.add (memo_Ocaml_keywords_spacing_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_AS = 
#51 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_AS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "as")) ) else ( None )) (input) ("\"as\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1706, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1706)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1707, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1707, ( () )), ((Trx_runtime.emptyError) (input_1707)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_AS_err) (input) (res)) ; res)
)
let try_Default_stringcharspecial = 
#33 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringcharspecial_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('n')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'n'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1747, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1747, 
#34 "default.trx"
( '\n'  )), ((Trx_runtime.emptyError) (input_1747))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('r')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'r'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1746, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1746, 
#34 "default.trx"
( '\r'  )), ((Trx_runtime.emptyError) (input_1746))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('t')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'t'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1745, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1745, 
#34 "default.trx"
( '\t'  )), ((Trx_runtime.emptyError) (input_1745))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1744, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1744, 
#35 "default.trx"
( '\''  )), ((Trx_runtime.emptyError) (input_1744))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\"'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1743, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1743, 
#35 "default.trx"
( '\"'  )), ((Trx_runtime.emptyError) (input_1743))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\\'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1742, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1742, 
#35 "default.trx"
( '\\'  )), ((Trx_runtime.emptyError) (input_1742))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (true) ((fun input_1741 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1741) (_len)) ) then ( let c = ((_get_char) (input_1741)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1741)), c)) ) else ( None ) ) else ( None )) (input_1741) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1740, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1740, 
#36 "default.trx"
( char_of_int (Tgrammar.int_of_chars __1)  )), ((Trx_runtime.emptyError) (input_1740)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_stringcharspecial_err) (input) (res)) ; res)
)
let try_Default_singlequotechar_ = 
#40 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_singlequotechar__err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\\'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1784, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_stringcharspecial (_filename) (_text) (input_1784)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1785, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1785, 
#41 "default.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1785)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\\'))) ((((=)) (c) ('\'')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'''")) ; Trx_runtime.Expected(("'\\'")) ])) with
Trx_runtime.Fail ( ( err ) ) -> let input_1782 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1782) (_len)) ) then ( let c = ((_get_char) (input_1782)) in
Some((((succ) (input_1782)), c)) ) else ( None )) (input_1782) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1783, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1783, __2), ((Trx_runtime.emptyError) (input_1783)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_singlequotechar__err) (input) (res)) ; res)
)
let try_Default_charsinglequote = 
#46 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_charsinglequote_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1878, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_singlequotechar_ (_filename) (_text) (input_1878)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1879, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1879) (_len)) ) then ( let c = ((_get_char) (input_1879)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input_1879)), c)) ) else ( None ) ) else ( None )) (input_1879) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1880, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1880, 
#46 "default.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1880))))))))))))) in
(Hashtbl.add (memo_Default_charsinglequote_err) (input) (res)) ; res)
)
let try_Default_strfloat = 
#97 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_strfloat_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'-'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1766, r ), err ) ) -> Trx_runtime.Ok(((input_1766, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1754, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.while_primary_nores (true) ((fun input_1765 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1765) (_len)) ) then ( let c = ((_get_char) (input_1765)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1765)), c)) ) else ( None ) ) else ( None )) (input_1765) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1754)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1761, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1761) (_len)) ) then ( let c = ((_get_char) (input_1761)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1761)), c)) ) else ( None ) ) else ( None )) (input_1761) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1762, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1764 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1764) (_len)) ) then ( let c = ((_get_char) (input_1764)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1764)), c)) ) else ( None ) ) else ( None )) (input_1764) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1762)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1763, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1763, ()), ((Trx_runtime.emptyError) (input_1763))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1760 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1760) (_len)) ) then ( let c = ((_get_char) (input_1760)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1760)), c)) ) else ( None ) ) else ( None )) (input_1760) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1754)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1756, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1756) (_len)) ) then ( let c = ((_get_char) (input_1756)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1756)), c)) ) else ( None ) ) else ( None )) (input_1756) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1757, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (true) ((fun input_1759 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1759) (_len)) ) then ( let c = ((_get_char) (input_1759)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1759)), c)) ) else ( None ) ) else ( None )) (input_1759) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1757)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1758, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1758, ()), ((Trx_runtime.emptyError) (input_1758)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1755, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1755, (_get_sub (input) ((((-)) (input_1755) (input))))), ((Trx_runtime.emptyError) (input_1755)))))))))) in
(Hashtbl.add (memo_Default_strfloat_err) (input) (res)) ; res)
)
let try_Default_float = 
#98 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_float_err) (input))
) with
Not_found -> let res = (match (try_Default_strfloat (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1866, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1866, 
#98 "default.trx"
( float_of_string __1  )), ((Trx_runtime.emptyError) (input_1866))))))) in
(Hashtbl.add (memo_Default_float_err) (input) (res)) ; res)
)
let try_Default_strint = 
#94 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_strint_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('-')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'-'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1724, r ), err ) ) -> Trx_runtime.Ok(((input_1724, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1721, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (true) ((fun input_1723 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1723) (_len)) ) then ( let c = ((_get_char) (input_1723)) in
if ( (((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9')))) ) then ( Some((((succ) (input_1723)), c)) ) else ( None ) ) else ( None )) (input_1723) (((Trx_runtime.Expected(("['0'-'9']")))::([])))))) (input_1721)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1722, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1722, (_get_sub (input) ((((-)) (input_1722) (input))))), ((Trx_runtime.emptyError) (input_1722)))))))))) in
(Hashtbl.add (memo_Default_strint_err) (input) (res)) ; res)
)
let try_Default_int = 
#95 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_int_err) (input))
) with
Not_found -> let res = (match (try_Default_strint (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1861, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1861, 
#95 "default.trx"
( int_of_string __1  )), ((Trx_runtime.emptyError) (input_1861))))))) in
(Hashtbl.add (memo_Default_int_err) (input) (res)) ; res)
)
let try_Default_stringchar = 
#37 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringchar_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\\')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\\'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1750, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_stringcharspecial (_filename) (_text) (input_1750)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1751, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1751, 
#38 "default.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1751)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('\\'))) ((((=)) (c) ('"')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'\"'")) ; Trx_runtime.Expected(("'\\'")) ])) with
Trx_runtime.Fail ( ( err ) ) -> let input_1748 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1748) (_len)) ) then ( let c = ((_get_char) (input_1748)) in
Some((((succ) (input_1748)), c)) ) else ( None )) (input_1748) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1749, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1749, __2), ((Trx_runtime.emptyError) (input_1749)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Default_stringchar_err) (input) (res)) ; res)
)
let try_Default_stringnosp = 
#28 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_stringnosp_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'\"'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1736, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1739 -> (try_Default_stringchar (_filename) (_text) (input_1739)))) (input_1736)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1737, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1737) (_len)) ) then ( let c = ((_get_char) (input_1737)) in
if ( (((=)) (c) ('"')) ) then ( Some((((succ) (input_1737)), c)) ) else ( None ) ) else ( None )) (input_1737) (((Trx_runtime.Expected(("'\"'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1738, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1738, 
#28 "default.trx"
( Tgrammar.string_of_chars __2  )), ((Trx_runtime.emptyError) (input_1738))))))))))))) in
(Hashtbl.add (memo_Default_stringnosp_err) (input) (res)) ; res)
)
let try_Default_string = 
#27 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_string_err) (input))
) with
Not_found -> let res = (match (try_Default_stringnosp (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1752, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1752)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1753, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1753, 
#27 "default.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1753)))))))))) in
(Hashtbl.add (memo_Default_string_err) (input) (res)) ; res)
)
let try_Ocaml_parser_unit = 
#38 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_unit_err) (input))
) with
Not_found -> let res = (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1097, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1097)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1098, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1098)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1099, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1099, ( () )), ((Trx_runtime.emptyError) (input_1099))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_unit_err) (input) (res)) ; res)
)
let try_Ocaml_parser_const = 
#39 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_const_err) (input))
) with
Not_found -> let res = (match (match (try_Default_float (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1302, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1302)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1303, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1303, 
#40 "ocaml_parser.trx"
( Float __1  )), ((Trx_runtime.emptyError) (input_1303)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_int (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1300, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1300)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1301, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1301, 
#41 "ocaml_parser.trx"
( Int __1  )), ((Trx_runtime.emptyError) (input_1301)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_string (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1298, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1298)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1299, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1299, 
#42 "ocaml_parser.trx"
( String __1  )), ((Trx_runtime.emptyError) (input_1299)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_charsinglequote (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1296, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1296)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1297, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1297, 
#44 "ocaml_parser.trx"
( Char (__1)  )), ((Trx_runtime.emptyError) (input_1297)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_unit (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1295, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1295, 
#45 "ocaml_parser.trx"
( Unit  )), ((Trx_runtime.emptyError) (input_1295))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "false")) ) else ( None )) (input) ("\"false\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1293, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1293)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1294, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1294, 
#46 "ocaml_parser.trx"
( Bool false  )), ((Trx_runtime.emptyError) (input_1294)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "true")) ) else ( None )) (input) ("\"true\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1291, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1291)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1292, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1292, 
#47 "ocaml_parser.trx"
( Bool true  )), ((Trx_runtime.emptyError) (input_1292))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_const_err) (input) (res)) ; res)
)
let try_Ocaml_parser_mlIdent_cont = 
#50 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((=)) (c) ('_'))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('\'')))))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'''")) ; Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1254, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1254, __1), ((Trx_runtime.emptyError) (input_1254))))))))
let try_Ocaml_parser_capMlIdent_ = 
#116 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_capMlIdent__err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((=)) (c) ('`'))) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'`'")) ; Trx_runtime.Expected(("['A'-'Z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1305, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1307 -> (try_Ocaml_parser_mlIdent_cont (_filename) (_text) (input_1307)))) (input_1305)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1306, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1306, (_get_sub (input) ((((-)) (input_1306) (input))))), ((Trx_runtime.emptyError) (input_1306)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1304, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1304, __1), ((Trx_runtime.emptyError) (input_1304))))))) in
(Hashtbl.add (memo_Ocaml_parser_capMlIdent__err) (input) (res)) ; res)
)
let try_Ocaml_parser_constructorName = 
#121 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_constructorName_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary (false) ((fun input_1288 -> (match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input_1288)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1289, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1289) (_len)) ) then ( let c = ((_get_char) (input_1289)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1289)), c)) ) else ( None ) ) else ( None )) (input_1289) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1290, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1290, 
#121 "ocaml_parser.trx"
( __1 )), ((Trx_runtime.emptyError) (input_1290)))))))))))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1284, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input_1284)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1285, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1285) (_len)) ) then ( let c = ((_get_char) (input_1285)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1285)), c)) ) else ( None ) ) else ( None )) (input_1285) (((Trx_runtime.Expected(("'.'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1286 = input_1285 in
let __3 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1286)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1287, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1287, 
#121 "ocaml_parser.trx"
( __1 @ [__2]  )), ((Trx_runtime.emptyError) (input_1287)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))))))) in
(Hashtbl.add (memo_Ocaml_parser_constructorName_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_KEYWORDS = 
#22 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_KEYWORDS_err) (input))
) with
Not_found -> let res = (Trx_runtime.option_to_res_msg (if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'~' -> Some(((((+)) (input) (1)), "~"))
| '}' -> Some(((((+)) (input) (1)), "}"))
| '|' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'|' -> Some(((((+)) (input) (2)), "||"))
| ']' -> Some(((((+)) (input) (2)), "|]"))
| _ -> Some(((((+)) (input) (1)), "|"))) ) else ( Some(((((+)) (input) (1)), "|")) )
| '{' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('<'))) (true)))) ) then ( Some(((((+)) (input) (2)), "{<")) ) else ( Some(((((+)) (input) (1)), "{")) )
| 'w' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "with")) ) else ( None )
| 'h' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (5)), "while")) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))) ) then ( Some(((((+)) (input) (4)), "when")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )
| 'v' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (7)), "virtual")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) (true)))) ) then ( Some(((((+)) (input) (3)), "val")) ) else ( None )
| _ -> None) ) else ( None )
| 't' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'y' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "type")) ) else ( None )
| 'r' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'y' -> Some(((((+)) (input) (3)), "try"))
| 'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))) ) then ( Some(((((+)) (input) (4)), "true")) ) else ( None )
| _ -> None) ) else ( None )
| 'o' -> Some(((((+)) (input) (2)), "to"))
| 'h' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "then")) ) else ( None )
| _ -> None) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "struct")) ) else ( None )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) (true)))) ) then ( Some(((((+)) (input) (3)), "sig")) ) else ( None )
| _ -> None) ) else ( None )
| 'r' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "rec")) ) else ( None )
| 'p' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('v'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (7)), "private")) ) else ( None )
| 'o' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'r' -> Some(((((+)) (input) (2)), "or"))
| 'p' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "open")) ) else ( None )
| 'f' -> Some(((((+)) (input) (2)), "of"))
| 'b' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('j'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "object")) ) else ( None )
| _ -> None) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('w'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "new")) ) else ( None )
| 'm' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (7)), "mutable")) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "module")) ) else ( Some(((((+)) (input) (3)), "mod")) ) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) (true)))))))))) ) then ( Some(((((+)) (input) (6)), "method")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('h'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "match")) ) else ( None )
| _ -> None) ) else ( None )
| 'l' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "lxor")) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'r' -> Some(((((+)) (input) (3)), "lsr"))
| 'l' -> Some(((((+)) (input) (3)), "lsl"))
| _ -> None) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "lor")) ) else ( None )
| 'e' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))) ) then ( Some(((((+)) (input) (3)), "let")) ) else ( None )
| 'a' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'z' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('y'))) (true)))) ) then ( Some(((((+)) (input) (4)), "lazy")) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (4)), "land")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )
| 'i' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'n' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (11))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('z'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (9))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (10))))) ('r'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (11)), "initializer")) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'h' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (7)), "inherit")) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'c' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (7)), "include")) ) else ( Some(((((+)) (input) (2)), "in")) )
| _ -> Some(((((+)) (input) (2)), "in"))) ) else ( Some(((((+)) (input) (2)), "in")) )
| 'f' -> Some(((((+)) (input) (2)), "if"))
| _ -> None) ) else ( None )
| 'f' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'u' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) (true)))) ) then ( if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) (true)))))) ) then ( if ( (((<)) ((((+)) (input) (5))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (5)))) with
'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (7)), "functor")) ) else ( Some(((((+)) (input) (3)), "fun")) )
| 'i' -> if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (8)), "function")) ) else ( Some(((((+)) (input) (3)), "fun")) )
| _ -> Some(((((+)) (input) (3)), "fun"))) ) else ( Some(((((+)) (input) (3)), "fun")) ) ) else ( Some(((((+)) (input) (3)), "fun")) ) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "for")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "false")) ) else ( None )
| _ -> None) ) else ( None )
| 'e' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
't' -> if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('l'))) (true)))))))))))) ) then ( Some(((((+)) (input) (8)), "external")) ) else ( None )
| 'c' -> if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (9)), "exception")) ) else ( None )
| _ -> None) ) else ( None )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (3)), "end")) ) else ( None )
| 'l' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "else")) ) else ( None )
| _ -> None) ) else ( None )
| 'd' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) (true)))) ) then ( if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'w' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('o'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "downto")) ) else ( Some(((((+)) (input) (2)), "do")) )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))) ) then ( Some(((((+)) (input) (4)), "done")) ) else ( Some(((((+)) (input) (2)), "do")) )
| _ -> Some(((((+)) (input) (2)), "do"))) ) else ( Some(((((+)) (input) (2)), "do")) ) ) else ( None )
| 'c' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (10))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (9))))) ('t'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (10)), "constraint")) ) else ( None )
| 'l' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('s'))) (true)))))))) ) then ( Some(((((+)) (input) (5)), "class")) ) else ( None )
| _ -> None) ) else ( None )
| 'b' -> if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (5)), "begin")) ) else ( None )
| 'a' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
's' -> if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (6)), "assert")) ) else ( Some(((((+)) (input) (2)), "as")) )
| 'r' -> Some(((((+)) (input) (3)), "asr"))
| _ -> Some(((((+)) (input) (2)), "as"))) ) else ( Some(((((+)) (input) (2)), "as")) )
| 'n' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))) ) then ( Some(((((+)) (input) (3)), "and")) ) else ( None )
| _ -> None) ) else ( None )
| '`' -> Some(((((+)) (input) (1)), "`"))
| '_' -> Some(((((+)) (input) (1)), "_"))
| ']' -> Some(((((+)) (input) (1)), "]"))
| '[' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'|' -> Some(((((+)) (input) (2)), "[|"))
| '>' -> Some(((((+)) (input) (2)), "[>"))
| '<' -> Some(((((+)) (input) (2)), "[<"))
| _ -> Some(((((+)) (input) (1)), "["))) ) else ( Some(((((+)) (input) (1)), "[")) )
| '?' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('?'))) (true)))) ) then ( Some(((((+)) (input) (2)), "??")) ) else ( Some(((((+)) (input) (1)), "?")) )
| '>' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'}' -> Some(((((+)) (input) (2)), ">}"))
| ']' -> Some(((((+)) (input) (2)), ">]"))
| _ -> Some(((((+)) (input) (1)), ">"))) ) else ( Some(((((+)) (input) (1)), ">")) )
| '=' -> Some(((((+)) (input) (1)), "="))
| '<' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))) ) then ( Some(((((+)) (input) (2)), "<-")) ) else ( Some(((((+)) (input) (1)), "<")) )
| ';' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (';'))) (true)))) ) then ( Some(((((+)) (input) (2)), ";;")) ) else ( Some(((((+)) (input) (1)), ";")) )
| ':' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'>' -> Some(((((+)) (input) (2)), ":>"))
| '=' -> Some(((((+)) (input) (2)), ":="))
| ':' -> Some(((((+)) (input) (2)), "::"))
| _ -> Some(((((+)) (input) (1)), ":"))) ) else ( Some(((((+)) (input) (1)), ":")) )
| '.' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))) ) then ( Some(((((+)) (input) (2)), "..")) ) else ( Some(((((+)) (input) (1)), ".")) )
| '-' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'>' -> Some(((((+)) (input) (2)), "->"))
| '.' -> Some(((((+)) (input) (2)), "-."))
| _ -> Some(((((+)) (input) (1)), "-"))) ) else ( Some(((((+)) (input) (1)), "-")) )
| ',' -> Some(((((+)) (input) (1)), ","))
| '+' -> Some(((((+)) (input) (1)), "+"))
| '*' -> Some(((((+)) (input) (1)), "*"))
| ')' -> Some(((((+)) (input) (1)), ")"))
| '(' -> Some(((((+)) (input) (1)), "("))
| '\'' -> Some(((((+)) (input) (1)), "'"))
| '&' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('&'))) (true)))) ) then ( Some(((((+)) (input) (2)), "&&")) ) else ( Some(((((+)) (input) (1)), "&")) )
| '#' -> Some(((((+)) (input) (1)), "#"))
| _ -> None) ) else ( None )) (input) ("\"#\" or \"&\" or \"&&\" or \"'\" or \"(\" or \")\" or \"*\" or \"+\" or \",\" or \"-\" or \"-.\" or \"->\" or \".\" or \"..\" or \":\" or \"::\" or \":=\" or \":>\" or \";\" or \";;\" or \"<\" or \"<-\" or \"=\" or \">\" or \">]\" or \">}\" or \"?\" or \"??\" or \"[\" or \"[<\" or \"[>\" or \"[|\" or \"]\" or \"_\" or \"`\" or \"and\" or \"as\" or \"asr\" or \"begin\" or \"class\" or \"constraint\" or \"do\" or \"done\" or \"downto\" or \"else\" or \"end\" or \"exception\" or \"external\" or \"false\" or \"for\" or \"fun\" or \"function\" or \"functor\" or \"if\" or \"in\" or \"include\" or \"inherit\" or \"initializer\" or \"land\" or \"lazy\" or \"let\" or \"lor\" or \"lsl\" or \"lsr\" or \"lxor\" or \"match\" or \"method\" or \"mod\" or \"module\" or \"mutable\" or \"new\" or \"object\" or \"of\" or \"open\" or \"or\" or \"private\" or \"rec\" or \"sig\" or \"struct\" or \"then\" or \"to\" or \"true\" or \"try\" or \"type\" or \"val\" or \"virtual\" or \"when\" or \"while\" or \"with\" or \"{\" or \"{<\" or \"|\" or \"|]\" or \"||\" or \"}\" or \"~\" or \"assert\"")) in
(Hashtbl.add (memo_Ocaml_keywords_KEYWORDS_err) (input) (res)) ; res)
)
let try_Ocaml_parser_mlIdent_aux_ = 
#51 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_aux__err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((=)) (c) ('_')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['a'-'z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1256, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1258 -> (try_Ocaml_parser_mlIdent_cont (_filename) (_text) (input_1258)))) (input_1256)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1257, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1257, (_get_sub (input) ((((-)) (input_1257) (input))))), ((Trx_runtime.emptyError) (input_1257)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1255, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1255, 
#51 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1255))))))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_aux__err) (input) (res)) ; res)
)
let try_Ocaml_parser_mlIdent_aux = 
#52 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_aux_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_mlIdent_aux_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1259, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1259)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1260, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1260, 
#52 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1260)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_aux_err) (input) (res)) ; res)
)
let try_Ocaml_parser_mlIdent = 
#53 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_keywords_KEYWORDS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1273, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_cont (_filename) (_text) (input_1273)) with
Trx_runtime.Fail ( ( err ) ) -> let input_1274 = input_1273 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1274, __1), ((Trx_runtime.emptyError) (input_1274))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1271 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_aux (_filename) (_text) (input_1271)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1272, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1272, 
#53 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1272)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1265, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1265) (_len)) ) then ( let c = ((_get_char) (input_1265)) in
if ( (((||)) ((((=)) (c) ('!'))) ((((||)) ((((=)) (c) ('$'))) ((((||)) ((((=)) (c) ('%'))) ((((||)) ((((=)) (c) ('&'))) ((((||)) ((((=)) (c) ('*'))) ((((||)) ((((&&)) ((((>=)) (c) ('+'))) ((((<=)) (c) ('.'))))) ((((||)) ((((=)) (c) ('/'))) ((((||)) ((((=)) (c) (':'))) ((((||)) ((((=)) (c) ('<'))) ((((||)) ((((=)) (c) ('='))) ((((||)) ((((=)) (c) ('>'))) ((((||)) ((((=)) (c) ('?'))) ((((||)) ((((=)) (c) ('@'))) ((((||)) ((((=)) (c) ('^'))) ((((||)) ((((=)) (c) ('|'))) ((((=)) (c) ('~')))))))))))))))))))))))))))))))) ) then ( Some((((succ) (input_1265)), c)) ) else ( None ) ) else ( None )) (input_1265) ([ Trx_runtime.Expected(("'!'")) ; Trx_runtime.Expected(("'$'")) ; Trx_runtime.Expected(("'%'")) ; Trx_runtime.Expected(("'&'")) ; Trx_runtime.Expected(("'*'")) ; Trx_runtime.Expected(("'/'")) ; Trx_runtime.Expected(("':'")) ; Trx_runtime.Expected(("'<'")) ; Trx_runtime.Expected(("'='")) ; Trx_runtime.Expected(("'>'")) ; Trx_runtime.Expected(("'?'")) ; Trx_runtime.Expected(("'@'")) ; Trx_runtime.Expected(("'^'")) ; Trx_runtime.Expected(("'|'")) ; Trx_runtime.Expected(("'~'")) ; Trx_runtime.Expected(("['+'-'.']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1268, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1270 -> (Trx_runtime.option_to_res_err (if ( (((<)) (input_1270) (_len)) ) then ( let c = ((_get_char) (input_1270)) in
if ( (((||)) ((((=)) (c) ('!'))) ((((||)) ((((=)) (c) ('$'))) ((((||)) ((((=)) (c) ('%'))) ((((||)) ((((=)) (c) ('&'))) ((((||)) ((((=)) (c) ('*'))) ((((||)) ((((&&)) ((((>=)) (c) ('+'))) ((((<=)) (c) ('.'))))) ((((||)) ((((=)) (c) ('/'))) ((((||)) ((((=)) (c) (':'))) ((((||)) ((((=)) (c) ('<'))) ((((||)) ((((=)) (c) ('='))) ((((||)) ((((=)) (c) ('>'))) ((((||)) ((((=)) (c) ('?'))) ((((||)) ((((=)) (c) ('@'))) ((((||)) ((((=)) (c) ('^'))) ((((||)) ((((=)) (c) ('|'))) ((((=)) (c) ('~')))))))))))))))))))))))))))))))) ) then ( Some((((succ) (input_1270)), c)) ) else ( None ) ) else ( None )) (input_1270) ([ Trx_runtime.Expected(("'!'")) ; Trx_runtime.Expected(("'$'")) ; Trx_runtime.Expected(("'%'")) ; Trx_runtime.Expected(("'&'")) ; Trx_runtime.Expected(("'*'")) ; Trx_runtime.Expected(("'/'")) ; Trx_runtime.Expected(("':'")) ; Trx_runtime.Expected(("'<'")) ; Trx_runtime.Expected(("'='")) ; Trx_runtime.Expected(("'>'")) ; Trx_runtime.Expected(("'?'")) ; Trx_runtime.Expected(("'@'")) ; Trx_runtime.Expected(("'^'")) ; Trx_runtime.Expected(("'|'")) ; Trx_runtime.Expected(("'~'")) ; Trx_runtime.Expected(("['+'-'.']")) ])))) (input_1268)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1269, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1269, (_get_sub (input_1265) ((((-)) (input_1269) (input_1265))))), ((Trx_runtime.emptyError) (input_1269)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1266, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1266)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1267, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1267, 
#55 "ocaml_parser.trx"
( sprintf "(%s)" __2  )), ((Trx_runtime.emptyError) (input_1267)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_CONS = 
#79 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_CONS_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "::")) ) else ( None )) (input) ("\"::\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1700, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1700)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1701, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1701, ( () )), ((Trx_runtime.emptyError) (input_1701)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_CONS_err) (input) (res)) ; res)
)
let try_Default_rightarrow = 
#86 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_rightarrow_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "->")) ) else ( None )) (input) ("\"->\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1797, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1797)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1798, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1798, ( () )), ((Trx_runtime.emptyError) (input_1798)))))))))) in
(Hashtbl.add (memo_Default_rightarrow_err) (input) (res)) ; res)
)
let try_Ocaml_types_spacing = 
#19 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_spacing_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_1075 -> (match (match (try_Default_space (_filename) (_text) (input_1075)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1077, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1077, ( () )), ((Trx_runtime.emptyError) (input_1077))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_mlcomment (_filename) (_text) (input_1075)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1076, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1076, __1), ((Trx_runtime.emptyError) (input_1076)))))))))
| ( _ok ) as __pat_var -> __pat_var))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1074, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1074, ( () )), ((Trx_runtime.emptyError) (input_1074))))))) in
(Hashtbl.add (memo_Ocaml_types_spacing_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_OF = 
#50 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_OF_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('f'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "of")) ) else ( None )) (input) ("\"of\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1666, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1666)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1667, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1667, ( () )), ((Trx_runtime.emptyError) (input_1667)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_OF_err) (input) (res)) ; res)
)
let try_Ocaml_types_typeIdent_cont = 
#30 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((||)) ((((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z'))))) ((((||)) ((((&&)) ((((>=)) (c) ('0'))) ((((<=)) (c) ('9'))))) ((((=)) (c) ('_')))))))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) ([ Trx_runtime.Expected(("'_'")) ; Trx_runtime.Expected(("['0'-'9']")) ; Trx_runtime.Expected(("['A'-'Z']")) ; Trx_runtime.Expected(("['a'-'z']")) ])) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1056, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1056, __1), ((Trx_runtime.emptyError) (input_1056))))))))
let try_Ocaml_types_typeconstructor = 
#33 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeconstructor_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('A'))) ((((<=)) (c) ('Z')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("['A'-'Z']")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1040, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1042 -> (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_1042)))) (input_1040)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1041, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1041, (_get_sub (input) ((((-)) (input_1041) (input))))), ((Trx_runtime.emptyError) (input_1041)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1038, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_1038)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1039, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1039, 
#33 "ocaml_types.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1039)))))))))) in
(Hashtbl.add (memo_Ocaml_types_typeconstructor_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_MUTABLE = 
#64 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MUTABLE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (7))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('e'))) (true)))))))))))))))) ) then ( Some(((((+)) (input) (7)), "mutable")) ) else ( None )) (input) ("\"mutable\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1668, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1668)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1669, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1669, ( () )), ((Trx_runtime.emptyError) (input_1669)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_MUTABLE_err) (input) (res)) ; res)
)
let try_Ocaml_types_typeIdent_aux = 
#31 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeIdent_aux_err) (input))
) with
Not_found -> let res = (match (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((&&)) ((((>=)) (c) ('a'))) ((((<=)) (c) ('z')))) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("['a'-'z']")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1060, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1062 -> (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_1062)))) (input_1060)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1061, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1061, (_get_sub (input) ((((-)) (input_1061) (input))))), ((Trx_runtime.emptyError) (input_1061)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('_')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'_'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1057, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (true) ((fun input_1059 -> (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_1059)))) (input_1057)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1058, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1058, (_get_sub (input) ((((-)) (input_1058) (input))))), ((Trx_runtime.emptyError) (input_1058))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typeIdent_aux_err) (input) (res)) ; res)
)
let try_Ocaml_types_typeIdent = 
#32 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeIdent_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_KEYWORDS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1066, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_1066)) with
Trx_runtime.Fail ( ( err ) ) -> let input_1067 = input_1066 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1067, __1), ((Trx_runtime.emptyError) (input_1067))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1063 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent_aux (_filename) (_text) (input_1063)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1064, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_1064)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1065, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1065, 
#32 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1065))))))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) in
(Hashtbl.add (memo_Ocaml_types_typeIdent_err) (input) (res)) ; res)
)
let try_Ocaml_types_BoolT = 
#28 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('l'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "bool")) ) else ( None )) (input) ("\"bool\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1096, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1096, 
#28 "ocaml_types.trx"
( TypeBool  )), ((Trx_runtime.emptyError) (input_1096))))))))
let try_Ocaml_types_FloatT = 
#25 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "float")) ) else ( None )) (input) ("\"float\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1095, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1095, 
#25 "ocaml_types.trx"
( TypeFloat  )), ((Trx_runtime.emptyError) (input_1095))))))))
let try_Ocaml_types_Int64T = 
#24 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('6'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('4'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "int64")) ) else ( None )) (input) ("\"int64\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1094, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1094, 
#24 "ocaml_types.trx"
( TypeInt64  )), ((Trx_runtime.emptyError) (input_1094))))))))
let try_Ocaml_types_IntT = 
#23 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "int")) ) else ( None )) (input) ("\"int\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1093, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1093, 
#23 "ocaml_types.trx"
( TypeInt  )), ((Trx_runtime.emptyError) (input_1093))))))))
let try_Ocaml_types_StringT = 
#26 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('g'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "string")) ) else ( None )) (input) ("\"string\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1092, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1092, 
#26 "ocaml_types.trx"
( TypeString  )), ((Trx_runtime.emptyError) (input_1092))))))))
let try_Ocaml_types_UnitT = 
#27 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('t'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "unit")) ) else ( None )) (input) ("\"unit\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1091, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1091, 
#27 "ocaml_types.trx"
( TypeUnit  )), ((Trx_runtime.emptyError) (input_1091))))))))
let try_Ocaml_types_typeconst = 
#22 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeconst_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_types_IntT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1049, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1049, __1), ((Trx_runtime.emptyError) (input_1049))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_Int64T (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1048, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1048, __1), ((Trx_runtime.emptyError) (input_1048))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_FloatT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1047, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1047, __1), ((Trx_runtime.emptyError) (input_1047))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_StringT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1046, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1046, __1), ((Trx_runtime.emptyError) (input_1046))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_UnitT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1045, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1045, __1), ((Trx_runtime.emptyError) (input_1045))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_BoolT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1044, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1044, __1), ((Trx_runtime.emptyError) (input_1044)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1043, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1043, 
#22 "ocaml_types.trx"
( TypeConst __1  )), ((Trx_runtime.emptyError) (input_1043))))))) in
(Hashtbl.add (memo_Ocaml_types_typeconst_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typename = 
#35 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typename_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeconstructor (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_989, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_989) (_len)) ) then ( let c = ((_get_char) (input_989)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_989)), c)) ) else ( None ) ) else ( None )) (input_989) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_990, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typename (_filename) (_text) (input_990)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_991, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_991, 
#35 "ocaml_types.trx"
( __1 :: __3  )), ((Trx_runtime.emptyError) (input_991))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_988, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_988, 
#36 "ocaml_types.trx"
( [__1]  )), ((Trx_runtime.emptyError) (input_988)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typename_err) (input) (res)) ; res)
)
let try_Ocaml_types_typevar = 
#34 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevar_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('\'')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'''")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_967, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input_967)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_968, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_968, 
#34 "ocaml_types.trx"
( TypeVar ("'" ^ __2)  )), ((Trx_runtime.emptyError) (input_968)))))))))) in
(Hashtbl.add (memo_Ocaml_types_typevar_err) (input) (res)) ; res)
)
let try_Ocaml_types_typevarorname = 
#45 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevarorname_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typevar (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_966, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_966, __1), ((Trx_runtime.emptyError) (input_966))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_types_typeconst (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_964, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent_cont (_filename) (_text) (input_964)) with
Trx_runtime.Fail ( ( err ) ) -> let input_965 = input_964 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_965, __1), ((Trx_runtime.emptyError) (input_965))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_962 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typename (_filename) (_text) (input_962)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_963, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_963, 
#45 "ocaml_types.trx"
( TypeName ([], __2)  )), ((Trx_runtime.emptyError) (input_963)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeconst (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_960, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_960)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_961, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_961, 
#45 "ocaml_types.trx"
( __1  )), ((Trx_runtime.emptyError) (input_961))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typevarorname_err) (input) (res)) ; res)
)
let rec try_Ocaml_types_typeparam = 
#68 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeparam_err) (input))
) with
Not_found -> let res = (match (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_981, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_981)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_982, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_985 -> (match (try_Default_comma (_filename) (_text) (input_985)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_986, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_986)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_987, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_987, 
#69 "ocaml_types.trx"
( __2 )), ((Trx_runtime.emptyError) (input_987)))))))))))) (input_982)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_983, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_983)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_984, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_984, 
#69 "ocaml_types.trx"
( __2 :: __3  )), ((Trx_runtime.emptyError) (input_984)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef_base (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_980, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_980, 
#70 "ocaml_types.trx"
( [__1]  )), ((Trx_runtime.emptyError) (input_980)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typeparam_err) (input) (res)) ; res)
)
and try_Ocaml_types_typerecord = 
#101 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typerecord_err) (input))
) with
Not_found -> let res = (match (try_Default_laccol (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_976, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typerecord_aux (_filename) (_text) (input_976)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_979, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_979, 
#101 "ocaml_types.trx"
( TypeRecord __1  )), ((Trx_runtime.emptyError) (input_979))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_977, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_raccol (_filename) (_text) (input_977)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_978, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_978, 
#100 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_978))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typerecord_err) (input) (res)) ; res)
)
and try_Ocaml_types_typedef = 
#88 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typedef_no_arrow (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1021, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rightarrow (_filename) (_text) (input_1021)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1022, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1022)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1023, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1023, 
#89 "ocaml_types.trx"
( TypeArrow ( __1, __3)  )), ((Trx_runtime.emptyError) (input_1023))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef_no_arrow (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1020, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1020, 
#90 "ocaml_types.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1020)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_err) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_aux = 
#72 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_aux_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeparam (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1017, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (true) ((fun input_1019 -> (try_Ocaml_types_typename (_filename) (_text) (input_1019)))) (input_1017)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1018, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1018, 
#73 "ocaml_types.trx"
( match __2 with
| hd :: tl -> 
  List.fold_left (fun acc x -> TypeName ([acc], x)) (TypeName (__1, hd)) tl 
| _ -> assert false
 )), ((Trx_runtime.emptyError) (input_1018)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef_base (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1016, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1016, __1), ((Trx_runtime.emptyError) (input_1016)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_aux_err) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_no_arrow = 
#81 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_no_arrow_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedef_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1004, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1006 -> (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1006) (_len)) ) then ( let c = ((_get_char) (input_1006)) in
if ( (((=)) (c) ('*')) ) then ( Some((((succ) (input_1006)), c)) ) else ( None ) ) else ( None )) (input_1006) (((Trx_runtime.Expected(("'*'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1007, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_1007)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1008, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef_aux (_filename) (_text) (input_1008)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1009, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1009, 
#81 "ocaml_types.trx"
( __3 )), ((Trx_runtime.emptyError) (input_1009))))))))))))))) (input_1004)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1005, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1005, 
#81 "ocaml_types.trx"
( match (__1::__2) with
    | [] -> failwith "@Ocaml_types.typedef_no_arrow : empty type tuple"
    | [td] -> td
    | tdl -> TypeTuple tdl
 )), ((Trx_runtime.emptyError) (input_1005)))))))))) in
(Hashtbl.add (memo_Ocaml_types_typedef_no_arrow_err) (input) (res)) ; res)
)
and try_Ocaml_types_typedef_base = 
#64 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedef_base_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typeSum (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1015, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1015, __1), ((Trx_runtime.emptyError) (input_1015))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typerecord (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1014, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1014, __1), ((Trx_runtime.emptyError) (input_1014))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typevarorname (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1013, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1013, __1), ((Trx_runtime.emptyError) (input_1013))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1010, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1010)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1011, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1011)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1012, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1012, 
#66 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1012)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typedef_base_err) (input) (res)) ; res)
)
and try_Ocaml_types_typeSum = 
#97 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typeSum_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typeconstructor (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1050, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1050) (_len)) ) then ( let c = ((_get_char) (input_1050)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1050)), c)) ) else ( None ) ) else ( None )) (input_1050) (((Trx_runtime.Expected(("'.'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1051 = input_1050 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_OF (_filename) (_text) (input_1051)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1053, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1053)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1054, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1054, 
#97 "ocaml_types.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1054)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1051, None), err))
| Trx_runtime.Ok ( ( ( input_1055, r ), err ) ) -> Trx_runtime.Ok(((input_1055, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1052, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1052, 
#97 "ocaml_types.trx"
( TypeConstructor [__1, __3]  )), ((Trx_runtime.emptyError) (input_1052)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) in
(Hashtbl.add (memo_Ocaml_types_typeSum_err) (input) (res)) ; res)
)
and try_Ocaml_types_typerecord_aux = 
#95 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typerecord_aux_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_onetyperecord (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_969, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_973 -> (match (try_Default_semi (_filename) (_text) (input_973)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_974, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_onetyperecord (_filename) (_text) (input_974)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_975, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_975, 
#95 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_975)))))))))))) (input_969)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_970, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_semi (_filename) (_text) (input_970)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_970, None), err))
| Trx_runtime.Ok ( ( ( input_972, r ), err ) ) -> Trx_runtime.Ok(((input_972, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_971, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_971, 
#95 "ocaml_types.trx"
( __1 ::__2  )), ((Trx_runtime.emptyError) (input_971))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typerecord_aux_err) (input) (res)) ; res)
)
and try_Ocaml_types_onetyperecord = 
#94 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_onetyperecord_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_MUTABLE (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1082, r ), err ) ) -> Trx_runtime.Ok(((input_1082, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1078, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input_1078)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1079, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_colon (_filename) (_text) (input_1079)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1080, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1080)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1081, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1081, 
#94 "ocaml_types.trx"
( (match __1 with None -> false | _ -> true), __2, __4  )), ((Trx_runtime.emptyError) (input_1081)))))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_onetyperecord_err) (input) (res)) ; res)
)
let try_Ocaml_parser_type = 
#123 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_type_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedef (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1100, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1100, __1), ((Trx_runtime.emptyError) (input_1100))))))) in
(Hashtbl.add (memo_Ocaml_parser_type_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_pattern_aux = 
#178 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_l (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1163, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1163, 
#179 "ocaml_parser.trx"
( match __1 with
     | [t] -> t
     | _ -> PatTuple __1
   )), ((Trx_runtime.emptyError) (input_1163))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_err) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_aux_l = 
#171 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_l_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1110, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_comma (_filename) (_text) (input_1110)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1112, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux_l (_filename) (_text) (input_1112)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1113, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1113, 
#171 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1113)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1110, None), err))
| Trx_runtime.Ok ( ( ( input_1114, r ), err ) ) -> Trx_runtime.Ok(((input_1114, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1111, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1111, 
#172 "ocaml_parser.trx"
( match __2 with
     | None -> [__1]
     | Some s -> __1::s
   )), ((Trx_runtime.emptyError) (input_1111)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_l_err) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_cons = 
#164 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_cons_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1105, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_CONS (_filename) (_text) (input_1105)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1107, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input_1107)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1108, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1108, 
#164 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1108)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1105, None), err))
| Trx_runtime.Ok ( ( ( input_1109, r ), err ) ) -> Trx_runtime.Ok(((input_1109, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1106, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1106, 
#165 "ocaml_parser.trx"
( match __2 with
     | None -> __1
     | Some x -> PatList (__1, x)
   )), ((Trx_runtime.emptyError) (input_1106)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_cons_err) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_aux_aux = 
#127 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_aux_aux_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_mlIdent (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1162, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1162, 
#129 "ocaml_parser.trx"
( PatVar (Ident.source __1)  )), ((Trx_runtime.emptyError) (input_1162))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1155, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1155)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1156, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1156)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1159, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1159)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1160, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1160, ()), ((Trx_runtime.emptyError) (input_1160)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1156, None), err))
| Trx_runtime.Ok ( ( ( input_1161, r ), err ) ) -> Trx_runtime.Ok(((input_1161, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1157, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1157)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1158, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1158, 
#131 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1158)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_underscore (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1154, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1154, 
#133 "ocaml_parser.trx"
( PatAny  )), ((Trx_runtime.emptyError) (input_1154))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_const (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1153, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1153, 
#135 "ocaml_parser.trx"
( PatConst __1  )), ((Trx_runtime.emptyError) (input_1153))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_laccol (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1140, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1140)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1141, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1141)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1142, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1142)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1143, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1148 -> (match (try_Default_semi (_filename) (_text) (input_1148)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1149, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1149)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1150, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1150)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1151, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1151)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1152, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1152, 
#137 "ocaml_parser.trx"
( __2, __4 )), ((Trx_runtime.emptyError) (input_1152)))))))))))))))))) (input_1143)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1144, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_semi (_filename) (_text) (input_1144)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1144, None), err))
| Trx_runtime.Ok ( ( ( input_1147, r ), err ) ) -> Trx_runtime.Ok(((input_1147, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1145, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_raccol (_filename) (_text) (input_1145)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1146, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1146, 
#138 "ocaml_parser.trx"
( PatRecord ((__2, __4)::__5)
     )), ((Trx_runtime.emptyError) (input_1146))))))))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_lbracket (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1131, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1131)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1134, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1136 -> (match (try_Default_semi (_filename) (_text) (input_1136)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1137, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1137)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1138, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1138, 
#142 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1138)))))))))))) (input_1134)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1135, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1135, 
#142 "ocaml_parser.trx"
( __1, __2 )), ((Trx_runtime.emptyError) (input_1135)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1131, None), err))
| Trx_runtime.Ok ( ( ( input_1139, r ), err ) ) -> Trx_runtime.Ok(((input_1139, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1132, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rbracket (_filename) (_text) (input_1132)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1133, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1133, 
#143 "ocaml_parser.trx"
( match __2 with
       | None -> PatEmptyList
       | Some (a, l) ->
           PatList (a, List.fold_right (fun e accu -> PatList (e, accu)) l PatEmptyList)
     )), ((Trx_runtime.emptyError) (input_1133))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1123, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1123)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1124, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input_1124)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1125, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1128 -> (match (try_Default_comma (_filename) (_text) (input_1128)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1129, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input_1129)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1130, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1130, 
#150 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1130)))))))))))) (input_1125)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1126, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1126)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1127, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1127, 
#151 "ocaml_parser.trx"
( PatConstructor (List.map Ident.source __1, __3::__4)
     )), ((Trx_runtime.emptyError) (input_1127))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1120, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_pattern_cons (_filename) (_text) (input_1120)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1120, None), err))
| Trx_runtime.Ok ( ( ( input_1122, r ), err ) ) -> Trx_runtime.Ok(((input_1122, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1121, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1121, 
#156 "ocaml_parser.trx"
( PatConstructor (List.map Ident.source __1, match __2 with Some x -> [x] | None -> [])
     )), ((Trx_runtime.emptyError) (input_1121))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1115, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1117 -> (match (try_Ocaml_keywords_AS (_filename) (_text) (input_1117)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1118, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1118)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1119, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1119, 
#159 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1119)))))))))))) (input_1115)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1116, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1116, 
#160 "ocaml_parser.trx"
( List.fold_left (fun accu e -> PatAs (accu, Ident.source e)) __1 __2
   )), ((Trx_runtime.emptyError) (input_1116)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_aux_aux_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_equal_struct = 
#383 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_equal_struct_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('='))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "==")) ) else ( None )) (input) ("\"==\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1242, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1242)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1243, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1243, 
#383 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1243)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_equal_struct_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_and = 
#380 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_and_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('&'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('&'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "&&")) ) else ( None )) (input) ("\"&&\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1250, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1250)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1251, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1251, 
#380 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1251)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_and_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_or = 
#381 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_or_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'|' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('|'))) (true)))) ) then ( Some(((((+)) (input) (2)), "||")) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (2)), "or")) ) else ( None )
| _ -> None) ) else ( None )) (input) ("\"or\" or \"||\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1234, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1234)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1235, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1235, 
#381 "ocaml_parser.trx"
( "||"  )), ((Trx_runtime.emptyError) (input_1235)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_or_err) (input) (res)) ; res)
)
let try_Ocaml_parser_InfOpLevel1 = 
#354 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel1_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_op_and (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1514, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1514, __1), ((Trx_runtime.emptyError) (input_1514))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_op_or (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1513, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1513, __1), ((Trx_runtime.emptyError) (input_1513)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1512, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1512, 
#355 "ocaml_parser.trx"
( Ocaml.make_Var __1
   )), ((Trx_runtime.emptyError) (input_1512))))))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel1_err) (input) (res)) ; res)
)
let try_Ocaml_parser_GE = 
#396 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('>'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), ">=")) ) else ( None )) (input) ("\">=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1527, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1527)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1528, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1528, 
#396 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1528)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_GE_err) (input) (res)) ; res)
)
let try_Ocaml_parser_GT = 
#394 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('>'))) (true)))) ) then ( Some(((((+)) (input) (1)), ">")) ) else ( None )) (input) ("\">\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1525, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1525)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1526, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1526, 
#394 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1526)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_GT_err) (input) (res)) ; res)
)
let try_Ocaml_parser_LE = 
#395 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<=")) ) else ( None )) (input) ("\"<=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1491, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1491)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1492, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1492, 
#395 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1492)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_LE_err) (input) (res)) ; res)
)
let try_Ocaml_parser_LT = 
#393 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) (true)))) ) then ( Some(((((+)) (input) (1)), "<")) ) else ( None )) (input) ("\"<\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1489, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1489)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1490, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1490, 
#393 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1490)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_LT_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_equal = 
#382 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_equal_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('='))) (true)))) ) then ( Some(((((+)) (input) (1)), "=")) ) else ( None )) (input) ("\"=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1244, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1244)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1245, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1245, 
#382 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1245)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_equal_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_notequal = 
#385 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_notequal_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<>")) ) else ( None )) (input) ("\"<>\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1238, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1238)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1239, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1239, 
#385 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1239)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_notequal_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_notequal_struct = 
#384 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_notequal_struct_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "!=")) ) else ( None )) (input) ("\"!=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1236, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1236)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1237, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1237, 
#384 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1237)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_notequal_struct_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_SPECIALS = 
#39 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_SPECIALS_err) (input))
) with
Not_found -> let res = (Trx_runtime.option_to_res_msg (if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'm' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "mod")) ) else ( None )
| 'l' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "lxor")) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'r' -> Some(((((+)) (input) (3)), "lsr"))
| 'l' -> Some(((((+)) (input) (3)), "lsl"))
| _ -> None) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "lor")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "land")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None )) (input) ("\"land\" or \"lor\" or \"lsl\" or \"lsr\" or \"lxor\" or \"mod\"")) in
(Hashtbl.add (memo_Ocaml_keywords_SPECIALS_err) (input) (res)) ; res)
)
let try_Ocaml_parser_op_special = 
#391 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_special_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_SPECIALS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1232, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1232)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1233, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1233, 
#391 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1233)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_op_special_err) (input) (res)) ; res)
)
let try_Ocaml_parser_InfOpLevel2 = 
#359 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel2_err) (input))
) with
Not_found -> let res = (match (match (match (match (try_Ocaml_parser_op_equal_struct (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1511, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1511, __1), ((Trx_runtime.emptyError) (input_1511))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_equal (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1510, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1510, __1), ((Trx_runtime.emptyError) (input_1510))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_notequal (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1509, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1509, __1), ((Trx_runtime.emptyError) (input_1509))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_op_notequal_struct (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1508, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1508, __1), ((Trx_runtime.emptyError) (input_1508))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_LE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1507, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1507, __1), ((Trx_runtime.emptyError) (input_1507))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_GE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1506, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1506, __1), ((Trx_runtime.emptyError) (input_1506))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_LT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1505, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1505, __1), ((Trx_runtime.emptyError) (input_1505))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_GT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1504, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1504, __1), ((Trx_runtime.emptyError) (input_1504)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1503, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1503, 
#361 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )), ((Trx_runtime.emptyError) (input_1503))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_op_special (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1502, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1502, 
#366 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )), ((Trx_runtime.emptyError) (input_1502)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel2_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_FUN = 
#41 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_FUN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "fun")) ) else ( None )) (input) ("\"fun\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1684, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1684)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1685, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1685, ( () )), ((Trx_runtime.emptyError) (input_1685)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_FUN_err) (input) (res)) ; res)
)
let try_Default_question = 
#76 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_question_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('?')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'?'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1804, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1804)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1805, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1805, ( () )), ((Trx_runtime.emptyError) (input_1805)))))))))) in
(Hashtbl.add (memo_Default_question_err) (input) (res)) ; res)
)
let try_Default_tilde_ = 
#83 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('~')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'~'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1716, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1716, ( () )), ((Trx_runtime.emptyError) (input_1716))))))))
let try_Ocaml_parser_mlIdent_ = 
#56 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent__err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_KEYWORDS (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1263, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_cont (_filename) (_text) (input_1263)) with
Trx_runtime.Fail ( ( err ) ) -> let input_1264 = input_1263 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1264, __1), ((Trx_runtime.emptyError) (input_1264))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1261 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_aux_ (_filename) (_text) (input_1261)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1262, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1262, 
#56 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1262)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent__err) (input) (res)) ; res)
)
let try_Ocaml_keywords_ASSERT = 
#65 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_ASSERT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "assert")) ) else ( None )) (input) ("\"assert\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1704, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1704)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1705, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1705, ( () )), ((Trx_runtime.emptyError) (input_1705)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_ASSERT_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_ELSE = 
#73 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_ELSE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "else")) ) else ( None )) (input) ("\"else\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1692, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1692)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1693, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1693, ( () )), ((Trx_runtime.emptyError) (input_1693)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_ELSE_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_IF = 
#71 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_IF_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('f'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "if")) ) else ( None )) (input) ("\"if\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1678, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1678)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1679, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1679, ( () )), ((Trx_runtime.emptyError) (input_1679)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_IF_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_THEN = 
#72 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_THEN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "then")) ) else ( None )) (input) ("\"then\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1650, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1650)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1651, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1651, ( () )), ((Trx_runtime.emptyError) (input_1651)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_THEN_err) (input) (res)) ; res)
)
let try_Ocaml_parser_emptylist = 
#37 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_emptylist_err) (input))
) with
Not_found -> let res = (match (try_Default_lbracket (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1278, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1278)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1279, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rbracket (_filename) (_text) (input_1279)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1280, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1280, 
#37 "ocaml_parser.trx"
( EmptyList  )), ((Trx_runtime.emptyError) (input_1280))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_emptylist_err) (input) (res)) ; res)
)
let try_Ocaml_parser_EmptyList = 
#226 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_EmptyList_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_emptylist (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1576, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1576, __1), ((Trx_runtime.emptyError) (input_1576))))))) in
(Hashtbl.add (memo_Ocaml_parser_EmptyList_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_EXCEPTION = 
#61 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_EXCEPTION_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('x'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) (true)))))))))))))))))))) ) then ( Some(((((+)) (input) (9)), "exception")) ) else ( None )) (input) ("\"exception\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1688, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1688)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1689, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1689, ( () )), ((Trx_runtime.emptyError) (input_1689)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_EXCEPTION_err) (input) (res)) ; res)
)
let try_Ocaml_parser_capMlIdent = 
#117 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_capMlIdent_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1308, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1308)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1309, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1309, 
#117 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1309)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_capMlIdent_err) (input) (res)) ; res)
)
let try_Ocaml_parser_Exception = 
#280 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Exception_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_EXCEPTION (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1570, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_capMlIdent (_filename) (_text) (input_1570)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1571, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_OF (_filename) (_text) (input_1571)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1573, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1573)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1574, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1574, ()), ((Trx_runtime.emptyError) (input_1574)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1571, None), err))
| Trx_runtime.Ok ( ( ( input_1575, r ), err ) ) -> Trx_runtime.Ok(((input_1575, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1572, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1572, 
#280 "ocaml_parser.trx"
( Exception (__2, None) (* FIXME *) )), ((Trx_runtime.emptyError) (input_1572))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Exception_err) (input) (res)) ; res)
)
let try_Default_leftarrow = 
#85 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_leftarrow_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<-")) ) else ( None )) (input) ("\"<-\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1842, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1842)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1843, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1843, ( () )), ((Trx_runtime.emptyError) (input_1843)))))))))) in
(Hashtbl.add (memo_Default_leftarrow_err) (input) (res)) ; res)
)
let try_Ocaml_parser_Const = 
#218 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Const_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_const (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1600, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1600, 
#218 "ocaml_parser.trx"
( Const __1  )), ((Trx_runtime.emptyError) (input_1600))))))) in
(Hashtbl.add (memo_Ocaml_parser_Const_err) (input) (res)) ; res)
)
let try_Default_dot = 
#78 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_dot_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1872, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1872)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1873, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1873, ( () )), ((Trx_runtime.emptyError) (input_1873)))))))))) in
(Hashtbl.add (memo_Default_dot_err) (input) (res)) ; res)
)
let try_Ocaml_parser_Dot = 
#315 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Dot_err) (input))
) with
Not_found -> let res = (match (try_Default_dot (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1577, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_1586 -> (match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input_1586)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1587, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1587) (_len)) ) then ( let c = ((_get_char) (input_1587)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1587)), c)) ) else ( None ) ) else ( None )) (input_1587) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1588, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1588, 
#315 "ocaml_parser.trx"
( __1 )), ((Trx_runtime.emptyError) (input_1588)))))))))))) (input_1577)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1585, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1585, 
#315 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1585))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1578, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1578)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1584, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1584, 
#315 "ocaml_parser.trx"
( `MlIdent __1 )), ((Trx_runtime.emptyError) (input_1584))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1578)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1580, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_int (_filename) (_text) (input_1580)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1581, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1581)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1582, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1582)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1583, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1583, 
#315 "ocaml_parser.trx"
( `Int __2 )), ((Trx_runtime.emptyError) (input_1583))))))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1579, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1579, 
#315 "ocaml_parser.trx"
( match __3 with `MlIdent s ->
  let tmp = String.concat_map "." (fun s -> s) __2 in
  let tmp = if tmp = "" then "" else tmp ^ "." in
  `MlIdent (tmp ^ s) | `Int i -> `Int i  )), ((Trx_runtime.emptyError) (input_1579))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Dot_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_BEGIN = 
#58 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_BEGIN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "begin")) ) else ( None )) (input) ("\"begin\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1702, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1702)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1703, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1703, ( () )), ((Trx_runtime.emptyError) (input_1703)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_BEGIN_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_END = 
#56 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_END_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "end")) ) else ( None )) (input) ("\"end\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1690, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1690)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1691, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1691, ( () )), ((Trx_runtime.emptyError) (input_1691)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_END_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_WITH = 
#47 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_WITH_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('w'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "with")) ) else ( None )) (input) ("\"with\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1638, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1638)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1639, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1639, ( () )), ((Trx_runtime.emptyError) (input_1639)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_WITH_err) (input) (res)) ; res)
)
let try_Ocaml_parser_RNameOpt = 
#257 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_RNameOpt_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_mlIdent (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1359, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_WITH (_filename) (_text) (input_1359)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1360, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1360, 
#257 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1360)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1358, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1358, __1), ((Trx_runtime.emptyError) (input_1358))))))) in
(Hashtbl.add (memo_Ocaml_parser_RNameOpt_err) (input) (res)) ; res)
)
let try_Ocaml_parser_moduleName_ = 
#119 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_moduleName__err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1252, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1252, 
#119 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1252))))))) in
(Hashtbl.add (memo_Ocaml_parser_moduleName__err) (input) (res)) ; res)
)
let try_Ocaml_keywords_AND = 
#49 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_AND_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "and")) ) else ( None )) (input) ("\"and\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1710, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1710)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1711, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1711, ( () )), ((Trx_runtime.emptyError) (input_1711)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_AND_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_IN = 
#44 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_IN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "in")) ) else ( None )) (input) ("\"in\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1676, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1676)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1677, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1677, ( () )), ((Trx_runtime.emptyError) (input_1677)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_IN_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_LET = 
#42 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_LET_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "let")) ) else ( None )) (input) ("\"let\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1674, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1674)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1675, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1675, ( () )), ((Trx_runtime.emptyError) (input_1675)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_LET_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_REC = 
#45 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_REC_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "rec")) ) else ( None )) (input) ("\"rec\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1658, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1658)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1659, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1659, ( () )), ((Trx_runtime.emptyError) (input_1659)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_REC_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_REF = 
#60 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_REF_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('f'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "ref")) ) else ( None )) (input) ("\"ref\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1656, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1656)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1657, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1657, ( () )), ((Trx_runtime.emptyError) (input_1657)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_REF_err) (input) (res)) ; res)
)
let try_Default_bar = 
#80 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_bar_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('|')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'|'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1890, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_spacing (_filename) (_text) (input_1890)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1891, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1891, ( () )), ((Trx_runtime.emptyError) (input_1891)))))))))) in
(Hashtbl.add (memo_Default_bar_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_FUNCTION = 
#52 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_FUNCTION_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('n'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (8)), "function")) ) else ( None )) (input) ("\"function\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1682, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1682)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1683, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1683, ( () )), ((Trx_runtime.emptyError) (input_1683)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_FUNCTION_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_MATCH = 
#46 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MATCH_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('h'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "match")) ) else ( None )) (input) ("\"match\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1672, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1672)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1673, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1673, ( () )), ((Trx_runtime.emptyError) (input_1673)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_MATCH_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_WHEN = 
#80 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_WHEN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('w'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "when")) ) else ( None )) (input) ("\"when\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1640, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1640)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1641, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1641, ( () )), ((Trx_runtime.emptyError) (input_1641)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_WHEN_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_MODULE = 
#54 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MODULE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "module")) ) else ( None )) (input) ("\"module\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1670, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1670)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1671, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1671, ( () )), ((Trx_runtime.emptyError) (input_1671)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_MODULE_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_STRUCT = 
#55 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_STRUCT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "struct")) ) else ( None )) (input) ("\"struct\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1652, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1652)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1653, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1653, ( () )), ((Trx_runtime.emptyError) (input_1653)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_STRUCT_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_TYPE = 
#48 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_TYPE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('y'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "type")) ) else ( None )) (input) ("\"type\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1644, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1644)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1645, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1645, ( () )), ((Trx_runtime.emptyError) (input_1645)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_TYPE_err) (input) (res)) ; res)
)
let try_Ocaml_types_typedeflist = 
#56 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedeflist_err) (input))
) with
Not_found -> let res = (match (match (try_Default_bar (_filename) (_text) (input)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1003, r ), err ) ) -> Trx_runtime.Ok(((input_1003, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_997, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_997)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_998, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1000 -> (match (try_Default_bar (_filename) (_text) (input_1000)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1001, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedef (_filename) (_text) (input_1001)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1002, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1002, 
#56 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1002)))))))))))) (input_998)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_999, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_999, 
#56 "ocaml_types.trx"
( match __2, __3 with
| _, [] -> __2
| TypeConstructor l1, l2 -> 
	TypeConstructor ( l1 @ List.flatten (List.map (function | TypeConstructor l -> l | _ -> failwith "@Ocaml_types.typedeflist : must be a constructor") l2))
| _x, _xl -> failwith "@Ocaml_types.typedeflist : impossible"
 )), ((Trx_runtime.emptyError) (input_999))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typedeflist_err) (input) (res)) ; res)
)
let try_Ocaml_types_typevars = 
#43 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevars_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typevar (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_959, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_959, 
#43 "ocaml_types.trx"
( [__1]  )), ((Trx_runtime.emptyError) (input_959))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_952, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typevar (_filename) (_text) (input_952)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_953, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_956 -> (match (try_Default_comma (_filename) (_text) (input_956)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_957, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typevar (_filename) (_text) (input_957)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_958, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_958, 
#44 "ocaml_types.trx"
( __2  )), ((Trx_runtime.emptyError) (input_958)))))))))))) (input_953)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_954, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_954)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_955, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_955, 
#44 "ocaml_types.trx"
( __2 :: __3  )), ((Trx_runtime.emptyError) (input_955))))))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typevars_err) (input) (res)) ; res)
)
let try_Ocaml_types_typedeclaration = 
#48 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedeclaration_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_TYPE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1024, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typevars (_filename) (_text) (input_1024)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1024, None), err))
| Trx_runtime.Ok ( ( ( input_1037, r ), err ) ) -> Trx_runtime.Ok(((input_1037, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1025, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input_1025)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1026, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1026)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1027, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedeflist (_filename) (_text) (input_1027)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1028, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1030 -> (match (try_Ocaml_keywords_AND (_filename) (_text) (input_1030)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1031, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typevars (_filename) (_text) (input_1031)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1031, None), err))
| Trx_runtime.Ok ( ( ( input_1036, r ), err ) ) -> Trx_runtime.Ok(((input_1036, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1032, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typeIdent (_filename) (_text) (input_1032)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1033, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1033)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1034, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedeflist (_filename) (_text) (input_1034)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1035, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1035, 
#49 "ocaml_types.trx"
( compute_vars __2, __3, __5 )), ((Trx_runtime.emptyError) (input_1035))))))))))))))))))))) (input_1028)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1029, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1029, 
#50 "ocaml_types.trx"
( (compute_vars __2, __3, __5) :: __6  )), ((Trx_runtime.emptyError) (input_1029)))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typedeclaration_err) (input) (res)) ; res)
)
let try_Ocaml_parser_Type = 
#262 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Type_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedeclaration (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1311, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1311, 
#262 "ocaml_parser.trx"
( Type __1  )), ((Trx_runtime.emptyError) (input_1311))))))) in
(Hashtbl.add (memo_Ocaml_parser_Type_err) (input) (res)) ; res)
)
let try_Ocaml_parser_moduleName = 
#118 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_moduleName_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1253, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1253, 
#118 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1253))))))) in
(Hashtbl.add (memo_Ocaml_parser_moduleName_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_OPEN = 
#59 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_OPEN_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "open")) ) else ( None )) (input) ("\"open\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1664, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1664)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1665, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1665, ( () )), ((Trx_runtime.emptyError) (input_1665)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_OPEN_err) (input) (res)) ; res)
)
let try_Ocaml_parser_Open = 
#194 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Open_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_OPEN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1377, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1377)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1378, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1378, 
#194 "ocaml_parser.trx"
( Open [ Ident.source __2 ] )), ((Trx_runtime.emptyError) (input_1378)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Open_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_RAISE = 
#63 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_RAISE_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "raise")) ) else ( None )) (input) ("\"raise\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1660, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1660)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1661, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1661, ( () )), ((Trx_runtime.emptyError) (input_1661)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_RAISE_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_GETREF = 
#78 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_GETREF_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), ":=")) ) else ( None )) (input) ("\":=\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1680, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1680)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1681, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1681, ( () )), ((Trx_runtime.emptyError) (input_1681)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_GETREF_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_TRY = 
#62 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_TRY_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('y'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "try")) ) else ( None )) (input) ("\"try\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1646, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_spacing (_filename) (_text) (input_1646)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1647, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1647, ( () )), ((Trx_runtime.emptyError) (input_1647)))))))))) in
(Hashtbl.add (memo_Ocaml_keywords_TRY_err) (input) (res)) ; res)
)
let try_Ocaml_parser_FDIV = 
#411 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FDIV_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "/.")) ) else ( None )) (input) ("\"/.\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1535, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1535)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1536, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1536, 
#411 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1536)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_FDIV_err) (input) (res)) ; res)
)
let try_Ocaml_parser_IDIV = 
#406 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IDIV_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) (true)))) ) then ( Some(((((+)) (input) (1)), "/")) ) else ( None )) (input) ("\"/\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1521, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1521)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1522, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1522, 
#406 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1522)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_IDIV_err) (input) (res)) ; res)
)
let try_Ocaml_parser_DIV = 
#401 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_DIV_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_FDIV (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1590, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1590, __1), ((Trx_runtime.emptyError) (input_1590))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_IDIV (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1589, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1589, __1), ((Trx_runtime.emptyError) (input_1589)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_DIV_err) (input) (res)) ; res)
)
let try_Ocaml_parser_FMULT = 
#410 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FMULT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "*.")) ) else ( None )) (input) ("\"*.\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1531, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1531)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1532, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1532, 
#410 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1532)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_FMULT_err) (input) (res)) ; res)
)
let try_Ocaml_parser_IMULT = 
#405 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IMULT_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) (true)))) ) then ( Some(((((+)) (input) (1)), "*")) ) else ( None )) (input) ("\"*\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1517, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1517)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1518, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1518, 
#405 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1518)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_IMULT_err) (input) (res)) ; res)
)
let try_Ocaml_parser_MULT = 
#400 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MULT_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_FMULT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1442, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1442, __1), ((Trx_runtime.emptyError) (input_1442))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_IMULT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1441, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1441, __1), ((Trx_runtime.emptyError) (input_1441)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_MULT_err) (input) (res)) ; res)
)
let try_Ocaml_parser_InfOpLevel4 = 
#375 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel4_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_MULT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1495, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1495, __1), ((Trx_runtime.emptyError) (input_1495))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_DIV (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1494, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1494, __1), ((Trx_runtime.emptyError) (input_1494)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1493, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1493, 
#376 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )), ((Trx_runtime.emptyError) (input_1493))))))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel4_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_Paren = 
#320 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Paren_err) (input))
) with
Not_found -> let res = (match (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1364, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1364)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1365, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1365)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1368, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1368)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1369, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1369, ()), ((Trx_runtime.emptyError) (input_1369)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1365, None), err))
| Trx_runtime.Ok ( ( ( input_1370, r ), err ) ) -> Trx_runtime.Ok(((input_1370, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1366, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1366)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1367, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1367, 
#320 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1367)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_BEGIN (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1361, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1361)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1362, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_END (_filename) (_text) (input_1362)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1363, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1363, 
#320 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1363)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Paren_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr = 
#333 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1565, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_semi (_filename) (_text) (input_1565)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1567, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1567)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1568, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1568, 
#333 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1568)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1565, None), err))
| Trx_runtime.Ok ( ( ( input_1569, r ), err ) ) -> Trx_runtime.Ok(((input_1569, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1566, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1566, 
#333 "ocaml_parser.trx"
( match __2 with None -> __1 | Some x -> Sequence (__1, x)  )), ((Trx_runtime.emptyError) (input_1566)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Try = 
#287 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Try_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_TRY (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1312, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1312)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1313, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_WITH (_filename) (_text) (input_1313)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1314, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_bar (_filename) (_text) (input_1314)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1314, None), err))
| Trx_runtime.Ok ( ( ( input_1321, r ), err ) ) -> Trx_runtime.Ok(((input_1321, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1315, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1315)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1316, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1318 -> (match (try_Default_bar (_filename) (_text) (input_1318)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1319, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1319)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1320, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1320, 
#288 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1320)))))))))))) (input_1316)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1317, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1317, 
#288 "ocaml_parser.trx"
( Try (__2 , __5::__6)  )), ((Trx_runtime.emptyError) (input_1317)))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Try_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Module = 
#195 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Module_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_MODULE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1399, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1399)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1400, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1413 -> (match (try_Default_lparen (_filename) (_text) (input_1413)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1414, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1414)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1415, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1415)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1418, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1418)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1419, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1419, 
#196 "ocaml_parser.trx"
( Signature (Referenced [__2])  )), ((Trx_runtime.emptyError) (input_1419)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1415, None), err))
| Trx_runtime.Ok ( ( ( input_1420, r ), err ) ) -> Trx_runtime.Ok(((input_1420, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1416, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1416)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1417, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1417, 
#196 "ocaml_parser.trx"
( __2, __3 )), ((Trx_runtime.emptyError) (input_1417)))))))))))))))))) (input_1400)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1401, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1401)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1410, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_moduleName (_filename) (_text) (input_1410)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1411, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1411, 
#197 "ocaml_parser.trx"
( Signature (Referenced [__2])  )), ((Trx_runtime.emptyError) (input_1411)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1401, None), err))
| Trx_runtime.Ok ( ( ( input_1412, r ), err ) ) -> Trx_runtime.Ok(((input_1412, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1402, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1402)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1403, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_STRUCT (_filename) (_text) (input_1403)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1406, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1409 -> (try_Ocaml_parser_LetOrType (_filename) (_text) (input_1409)))) (input_1406)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1407, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_END (_filename) (_text) (input_1407)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1408, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1408, 
#198 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1408))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_LetOrType (_filename) (_text) (input_1403)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1405, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1405, 
#198 "ocaml_parser.trx"
( [__1]  )), ((Trx_runtime.emptyError) (input_1405)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1404, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1404, 
#198 "ocaml_parser.trx"
( match __3 with [] -> Module (__2, __4, __6, None) | _ -> DeclareFunctor (__2, __3, __4, Structure __6)  )), ((Trx_runtime.emptyError) (input_1404)))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Module_err) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel1 = 
#335 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel1_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel2 (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1394, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_InfOpLevel1 (_filename) (_text) (input_1394)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1396, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel1 (_filename) (_text) (input_1396)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1397, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1397, 
#335 "ocaml_parser.trx"
( __1, __2  )), ((Trx_runtime.emptyError) (input_1397)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1394, None), err))
| Trx_runtime.Ok ( ( ( input_1398, r ), err ) ) -> Trx_runtime.Ok(((input_1398, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1395, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1395, 
#335 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  )), ((Trx_runtime.emptyError) (input_1395)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel1_err) (input) (res)) ; res)
)
and try_Ocaml_parser_MakeRef = 
#220 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MakeRef_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_REF (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1439, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input_1439)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1440, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1440, 
#220 "ocaml_parser.trx"
( MakeRef __2 )), ((Trx_runtime.emptyError) (input_1440)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_MakeRef_err) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel3 = 
#337 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel3_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel4 (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1384, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_InfOpLevel3 (_filename) (_text) (input_1384)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1386, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel3 (_filename) (_text) (input_1386)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1387, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1387, 
#337 "ocaml_parser.trx"
( __1, __2  )), ((Trx_runtime.emptyError) (input_1387)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1384, None), err))
| Trx_runtime.Ok ( ( ( input_1388, r ), err ) ) -> Trx_runtime.Ok(((input_1388, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1385, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1385, 
#337 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  )), ((Trx_runtime.emptyError) (input_1385)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel3_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Letin = 
#249 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Letin_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_LET (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1445, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_keywords_REC (_filename) (_text) (input_1445)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1445, None), err))
| Trx_runtime.Ok ( ( ( input_1462, r ), err ) ) -> Trx_runtime.Ok(((input_1462, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1446, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1446)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1447, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1461 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1461)))) (input_1447)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1448, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1448)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1449, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1449)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1450, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1454 -> (match (try_Ocaml_keywords_AND (_filename) (_text) (input_1454)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1455, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1455)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1456, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1460 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1460)))) (input_1456)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1457, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1457)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1458, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1458)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1459, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1459, 
#250 "ocaml_parser.trx"
( let tmp = make_fun __5 __3 in __2, tmp  )), ((Trx_runtime.emptyError) (input_1459))))))))))))))))))))) (input_1450)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1451, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_IN (_filename) (_text) (input_1451)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1452, __8 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1452)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1453, __9 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1453, 
#252 "ocaml_parser.trx"
( match __2 with Some _ -> let tmp = make_fun __6 __4 in Letrecin ((__3, tmp)::__7, __9)
        | None -> let tmp = make_fun __6 __4 in Letin ((__3, tmp)::__7, __9)
         )), ((Trx_runtime.emptyError) (input_1453))))))))))))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Letin_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Raise = 
#282 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Raise_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_RAISE (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1351, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_capMlIdent (_filename) (_text) (input_1351)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1352, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_lparen (_filename) (_text) (input_1352)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1354, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1354)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1355, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1355)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1356, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1356, 
#282 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1356))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1352, None), err))
| Trx_runtime.Ok ( ( ( input_1357, r ), err ) ) -> Trx_runtime.Ok(((input_1357, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1353, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1353, 
#283 "ocaml_parser.trx"
( Raise ([Ident.source __2], __3)
   )), ((Trx_runtime.emptyError) (input_1353))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Raise_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Assert = 
#290 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Assert_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_ASSERT (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1616, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1616)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1617, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1617, 
#290 "ocaml_parser.trx"
( Assert __2  )), ((Trx_runtime.emptyError) (input_1617)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Assert_err) (input) (res)) ; res)
)
and try_Ocaml_parser_dotable = 
#321 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_dotable_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_Record (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1283, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1283, __1), ((Trx_runtime.emptyError) (input_1283))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Paren (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1282, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1282, __1), ((Trx_runtime.emptyError) (input_1282))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Var (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1281, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1281, __1), ((Trx_runtime.emptyError) (input_1281)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_dotable_err) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern = 
#185 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1164, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_WHEN (_filename) (_text) (input_1164)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1166, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1166)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1167, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1167, 
#185 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1167)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1164, None), err))
| Trx_runtime.Ok ( ( ( input_1168, r ), err ) ) -> Trx_runtime.Ok(((input_1168, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1165, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1165, 
#186 "ocaml_parser.trx"
( match __2 with
     | None -> None, __1
     | Some x -> Some x, __1
   )), ((Trx_runtime.emptyError) (input_1165)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern_err) (input) (res)) ; res)
)
and try_Ocaml_parser_matchExpr = 
#273 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_matchExpr_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1275, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rightarrow (_filename) (_text) (input_1275)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1276, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1276)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1277, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1277, 
#274 "ocaml_parser.trx"
( match __1 with
     | Some guard, pat -> pat, Some guard, __3
     | None, pat -> pat, None, __3
   )), ((Trx_runtime.emptyError) (input_1277))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_matchExpr_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_without_seq_aux = 
#331 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_without_seq_aux_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel1 (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1537, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_comma (_filename) (_text) (input_1537)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1539, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq_aux (_filename) (_text) (input_1539)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1540, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1540, 
#331 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1540)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1537, None), err))
| Trx_runtime.Ok ( ( ( input_1541, r ), err ) ) -> Trx_runtime.Ok(((input_1541, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1538, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1538, 
#331 "ocaml_parser.trx"
( match __2 with None -> [__1] | Some s -> __1::s  )), ((Trx_runtime.emptyError) (input_1538)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_without_seq_aux_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Constructor = 
#200 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Constructor_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1596, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1596)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1597, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1597)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1598, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1598)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1599, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1599, 
#202 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, match __3 with Tuple l -> l | x -> [x])
     )), ((Trx_runtime.emptyError) (input_1599)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1594, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input_1594)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1595, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1595, 
#207 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, [__2])
     )), ((Trx_runtime.emptyError) (input_1595)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1591, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_ExprNotApp (_filename) (_text) (input_1591)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1591, None), err))
| Trx_runtime.Ok ( ( ( input_1593, r ), err ) ) -> Trx_runtime.Ok(((input_1593, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1592, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1592, 
#214 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, match __2 with None -> [] | Some s -> [s])
     )), ((Trx_runtime.emptyError) (input_1592))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Constructor_err) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel2 = 
#336 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel2_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel3 (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1389, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_InfOpLevel2 (_filename) (_text) (input_1389)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1391, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel2 (_filename) (_text) (input_1391)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1392, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1392, 
#336 "ocaml_parser.trx"
( __1, __2  )), ((Trx_runtime.emptyError) (input_1392)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1389, None), err))
| Trx_runtime.Ok ( ( ( input_1393, r ), err ) ) -> Trx_runtime.Ok(((input_1393, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1390, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1390, 
#336 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  )), ((Trx_runtime.emptyError) (input_1390)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel2_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Record = 
#258 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Record_err) (input))
) with
Not_found -> let res = (match (try_Default_laccol (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1336, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_RNameOpt (_filename) (_text) (input_1336)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1336, None), err))
| Trx_runtime.Ok ( ( ( input_1350, r ), err ) ) -> Trx_runtime.Ok(((input_1350, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1337, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1337)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1338, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1338)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1339, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1339)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1340, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1345 -> (match (try_Default_semi (_filename) (_text) (input_1345)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1346, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1346)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1347, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1347)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1348, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1348)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1349, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1349, 
#259 "ocaml_parser.trx"
( __2, __4 )), ((Trx_runtime.emptyError) (input_1349)))))))))))))))))) (input_1340)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1341, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_semi (_filename) (_text) (input_1341)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1341, None), err))
| Trx_runtime.Ok ( ( ( input_1344, r ), err ) ) -> Trx_runtime.Ok(((input_1344, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1342, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_raccol (_filename) (_text) (input_1342)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1343, __8 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1343, 
#261 "ocaml_parser.trx"
( Record (__2,((__3, __5)::__6))  )), ((Trx_runtime.emptyError) (input_1343)))))))))))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Record_err) (input) (res)) ; res)
)
and try_Ocaml_parser_SimpleExpr = 
#325 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_SimpleExpr_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_dotable (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1326, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1332 -> (try_Ocaml_parser_Dot (_filename) (_text) (input_1332)))) (input_1326)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1327, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_leftarrow (_filename) (_text) (input_1327)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1329, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1329)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1330, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1330, 
#326 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1330)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1327, None), err))
| Trx_runtime.Ok ( ( ( input_1331, r ), err ) ) -> Trx_runtime.Ok(((input_1331, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1328, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1328, 
#326 "ocaml_parser.trx"
( let tmp = List.fold_left (fun accu -> function | `MlIdent e -> Dot (accu, e)
        | `Int i -> Dot (accu, sprintf "(%d)" i)) __1 __2 in match __3  with None -> tmp | Some s -> SetMutable (tmp, s)  )), ((Trx_runtime.emptyError) (input_1328))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Const (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1325, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1325, 
#328 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1325))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1322, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_op_special (_filename) (_text) (input_1322)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1323, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1323)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1324, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1324, 
#329 "ocaml_parser.trx"
( Var (Pated ([Ident.source __2], true))  )), ((Trx_runtime.emptyError) (input_1324)))))))))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_SimpleExpr_err) (input) (res)) ; res)
)
and try_Ocaml_parser_LetOrType = 
#413 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LetOrType_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1463, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_Type (_filename) (_text) (input_1463)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1470, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1470, __1), ((Trx_runtime.emptyError) (input_1470))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Let (_filename) (_text) (input_1463)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1469, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1469, __1), ((Trx_runtime.emptyError) (input_1469)))))))))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1464, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1464) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1464) (0))))) (';'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1464) (1))))) (';'))) (true)))))) ) then ( Some(((((+)) (input_1464) (2)), ";;")) ) else ( None )) (input_1464) ("\";;\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1466, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1466)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1467, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1467, ()), ((Trx_runtime.emptyError) (input_1467)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1464, None), err))
| Trx_runtime.Ok ( ( ( input_1468, r ), err ) ) -> Trx_runtime.Ok(((input_1468, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1465, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1465, 
#413 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1465))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_LetOrType_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Var = 
#219 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Var_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_paramEffectif (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1310, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1310, 
#219 "ocaml_parser.trx"
( Var __1  )), ((Trx_runtime.emptyError) (input_1310))))))) in
(Hashtbl.add (memo_Ocaml_parser_Var_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Let = 
#233 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Let_err) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_keywords_LET (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1481, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_keywords_REC (_filename) (_text) (input_1481)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1481, None), err))
| Trx_runtime.Ok ( ( ( input_1487, r ), err ) ) -> Trx_runtime.Ok(((input_1487, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1482, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1482)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1483, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1486 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1486)))) (input_1483)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1484, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1484)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1485, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1485, 
#234 "ocaml_parser.trx"
( __2, __3, __4 )), ((Trx_runtime.emptyError) (input_1485))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input, None), err))
| Trx_runtime.Ok ( ( ( input_1488, r ), err ) ) -> Trx_runtime.Ok(((input_1488, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1471, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1471)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1472, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1474 -> (match (try_Ocaml_keywords_AND (_filename) (_text) (input_1474)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1475, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1475)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1476, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1480 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1480)))) (input_1476)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1477, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_equal (_filename) (_text) (input_1477)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1478, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1478)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1479, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1479, 
#236 "ocaml_parser.trx"
( let tmp = make_fun __5 __3 in __2, tmp  )), ((Trx_runtime.emptyError) (input_1479))))))))))))))))))))) (input_1472)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1473, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1473, 
#238 "ocaml_parser.trx"
( match __1 with
        | None -> __2
        | Some (_rec, name, pfs) ->
                match _rec with
                | Some _ ->
                        let tmp = make_fun __2 pfs in Letrec ((name, tmp)::__3)
                | None -> let tmp = make_fun __2 pfs in Let ((name, tmp)::__3)
         )), ((Trx_runtime.emptyError) (input_1473))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Let_err) (input) (res)) ; res)
)
and try_Ocaml_parser_ExprNotApp = 
#292 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_ExprNotApp_err) (input))
) with
Not_found -> let res = (match (match (match (match (try_Ocaml_parser_Open (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1564, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1564, __1), ((Trx_runtime.emptyError) (input_1564))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Module (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1563, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1563, __1), ((Trx_runtime.emptyError) (input_1563))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Cond (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1562, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1562, __1), ((Trx_runtime.emptyError) (input_1562))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Letin (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1561, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1561, __1), ((Trx_runtime.emptyError) (input_1561))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Match (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1560, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1560, __1), ((Trx_runtime.emptyError) (input_1560))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Exception (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1559, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1559, __1), ((Trx_runtime.emptyError) (input_1559))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Raise (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1558, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1558, __1), ((Trx_runtime.emptyError) (input_1558))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Try (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1557, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1557, __1), ((Trx_runtime.emptyError) (input_1557))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Assert (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1556, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1556, __1), ((Trx_runtime.emptyError) (input_1556))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_MakeRef (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1555, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1555, __1), ((Trx_runtime.emptyError) (input_1555))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_GetRef (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1554, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1554, __1), ((Trx_runtime.emptyError) (input_1554))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_SetRef (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1553, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1553, __1), ((Trx_runtime.emptyError) (input_1553))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Cons (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1552, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1552, __1), ((Trx_runtime.emptyError) (input_1552))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_EmptyList (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1551, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1551, __1), ((Trx_runtime.emptyError) (input_1551))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_parser_Abs (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1550, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1550, __1), ((Trx_runtime.emptyError) (input_1550))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1549, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1549, __1), ((Trx_runtime.emptyError) (input_1549)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1544, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_CONS (_filename) (_text) (input_1544)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1546, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel1 (_filename) (_text) (input_1546)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1547, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1547, 
#311 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1547)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1544, None), err))
| Trx_runtime.Ok ( ( ( input_1548, r ), err ) ) -> Trx_runtime.Ok(((input_1548, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1545, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1545, 
#311 "ocaml_parser.trx"
( match __2 with | None -> __1 | Some x -> Cons (__1, x) )), ((Trx_runtime.emptyError) (input_1545)))))))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1543, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1543, 
#312 "ocaml_parser.trx"
( __1  )), ((Trx_runtime.emptyError) (input_1543))))))) in
(Hashtbl.add (memo_Ocaml_parser_ExprNotApp_err) (input) (res)) ; res)
)
and try_Ocaml_parser_App = 
#339 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_App_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_Constructor (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1626, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1626, __1), ((Trx_runtime.emptyError) (input_1626))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1622, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1622) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1622) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input_1622) (1)), "-")) ) else ( None )) (input_1622) ("\"-\"")) with
Trx_runtime.Fail ( ( err ) ) -> let input_1623 = input_1622 in
let __2 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1623) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1623) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1623) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input_1623) (2)), "::")) ) else ( None )) (input_1623) ("\"::\"")) with
Trx_runtime.Fail ( ( err ) ) -> let input_1624 = input_1623 in
let __3 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1624) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1624) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1624) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input_1624) (2)), ":=")) ) else ( None )) (input_1624) ("\":=\"")) with
Trx_runtime.Fail ( ( err ) ) -> let input_1625 = input_1624 in
let __4 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1625, __1), ((Trx_runtime.emptyError) (input_1625))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err)))))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1619, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1621 -> (try_Ocaml_parser_ExprNotApp (_filename) (_text) (input_1621)))) (input_1619)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1620, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1620, 
#344 "ocaml_parser.trx"
( match __2 with [] -> __1 | _ -> make_app (__1 :: __2)  )), ((Trx_runtime.emptyError) (input_1620)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_ExprNotApp (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1618, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1618, __1), ((Trx_runtime.emptyError) (input_1618)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_App_err) (input) (res)) ; res)
)
and try_Ocaml_parser_GetRef = 
#221 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GetRef_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('!')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None )) (input) (((Trx_runtime.Expected(("'!'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1523, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input_1523)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1524, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1524, 
#221 "ocaml_parser.trx"
( GetRef __2  )), ((Trx_runtime.emptyError) (input_1524)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_GetRef_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_without_seq = 
#332 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_without_seq_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Expr_without_seq_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1542, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1542, 
#332 "ocaml_parser.trx"
( match __1 with [t] -> t | _ -> Tuple __1  )), ((Trx_runtime.emptyError) (input_1542))))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_without_seq_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Abs = 
#229 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Abs_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary (true) ((fun input_1629 -> (match (try_Ocaml_keywords_FUN (_filename) (_text) (input_1629)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1630, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (true) ((fun input_1633 -> (try_Ocaml_parser_paramFormel (_filename) (_text) (input_1633)))) (input_1630)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1631, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rightarrow (_filename) (_text) (input_1631)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1632, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1632, 
#229 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1632))))))))))))))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1627, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1627)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1628, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1628, 
#229 "ocaml_parser.trx"
( Abs (List.flatten __1, __2)  )), ((Trx_runtime.emptyError) (input_1628)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Abs_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Match = 
#263 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Match_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_MATCH (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1429, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1429)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1430, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_WITH (_filename) (_text) (input_1430)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1431, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_bar (_filename) (_text) (input_1431)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1431, None), err))
| Trx_runtime.Ok ( ( ( input_1438, r ), err ) ) -> Trx_runtime.Ok(((input_1438, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1432, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1432)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1433, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1435 -> (match (try_Default_bar (_filename) (_text) (input_1435)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1436, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1436)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1437, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1437, 
#264 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1437)))))))))))) (input_1433)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1434, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1434, 
#265 "ocaml_parser.trx"
( Match (__2, __5 :: __6)
     )), ((Trx_runtime.emptyError) (input_1434)))))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_FUNCTION (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1421, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_bar (_filename) (_text) (input_1421)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1421, None), err))
| Trx_runtime.Ok ( ( ( input_1428, r ), err ) ) -> Trx_runtime.Ok(((input_1428, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1422, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1422)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1423, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1425 -> (match (try_Default_bar (_filename) (_text) (input_1425)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1426, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_matchExpr (_filename) (_text) (input_1426)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1427, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1427, 
#268 "ocaml_parser.trx"
( __2  )), ((Trx_runtime.emptyError) (input_1427)))))))))))) (input_1423)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1424, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1424, 
#269 "ocaml_parser.trx"
( Function (__3::__4)
     )), ((Trx_runtime.emptyError) (input_1424))))))))))))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Match_err) (input) (res)) ; res)
)
and try_Ocaml_parser_paramEffectif = 
#98 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_paramEffectif_err) (input))
) with
Not_found -> let res = (match (match (try_Default_tilde_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1225, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_ (_filename) (_text) (input_1225)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1226, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1226)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1229, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_ExprNotApp (_filename) (_text) (input_1229)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1230, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1230, 
#99 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1230)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1226, None), err))
| Trx_runtime.Ok ( ( ( input_1231, r ), err ) ) -> Trx_runtime.Ok(((input_1231, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1227, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1227)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1228, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1228, 
#100 "ocaml_parser.trx"
( Labeled (__2, __3)
     )), ((Trx_runtime.emptyError) (input_1228)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (Trx_runtime.while_primary (false) ((fun input_1222 -> (match (try_Ocaml_parser_moduleName_ (_filename) (_text) (input_1222)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1223, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1223) (_len)) ) then ( let c = ((_get_char) (input_1223)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_1223)), c)) ) else ( None ) ) else ( None )) (input_1223) (((Trx_runtime.Expected(("'.'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1224, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1224, 
#106 "ocaml_parser.trx"
( __1 )), ((Trx_runtime.emptyError) (input_1224)))))))))))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1220, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1220)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1221, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1221, 
#107 "ocaml_parser.trx"
( Pated (List.map Ident.source (__1 @ [__2]), false)
     )), ((Trx_runtime.emptyError) (input_1221)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_constructorName (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1219, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1219, 
#112 "ocaml_parser.trx"
( Pated (List.map Ident.source __1, true)
     )), ((Trx_runtime.emptyError) (input_1219)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_paramEffectif_err) (input) (res)) ; res)
)
and try_Ocaml_parser_paramFormel = 
#62 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_paramFormel_err) (input))
) with
Not_found -> let res = (match (match (try_Default_tilde_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1211, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1211)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1212, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1212)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1213, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1213)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1216, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1216)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1217, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1217, 
#63 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1217)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1213, None), err))
| Trx_runtime.Ok ( ( ( input_1218, r ), err ) ) -> Trx_runtime.Ok(((input_1218, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1214, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1214)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1215, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1215, 
#64 "ocaml_parser.trx"
( Label (__3, None, __4)
     )), ((Trx_runtime.emptyError) (input_1215))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_tilde_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1204, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_ (_filename) (_text) (input_1204)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1205, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1205)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1208, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1208)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1209, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1209, 
#68 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1209)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1205, None), err))
| Trx_runtime.Ok ( ( ( input_1210, r ), err ) ) -> Trx_runtime.Ok(((input_1210, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1206, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_spacing (_filename) (_text) (input_1206)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1207, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1207, 
#69 "ocaml_parser.trx"
( Label (__2, __3, None)
     )), ((Trx_runtime.emptyError) (input_1207)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_tilde_ (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1194, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent_ (_filename) (_text) (input_1194)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1195, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_colon (_filename) (_text) (input_1195)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1196, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1196)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1197, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input_1197)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1198, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1198)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1201, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1201)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1202, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1202, 
#73 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1202)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1198, None), err))
| Trx_runtime.Ok ( ( ( input_1203, r ), err ) ) -> Trx_runtime.Ok(((input_1203, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1199, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1199)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1200, __7 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1200, 
#74 "ocaml_parser.trx"
( Label (__2, Some __5, __6)
     )), ((Trx_runtime.emptyError) (input_1200))))))))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_question (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1182, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_lparen (_filename) (_text) (input_1182)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1183, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1183)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1184, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1184)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1191, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1191)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1192, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1192, 
#78 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1192)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1184, None), err))
| Trx_runtime.Ok ( ( ( input_1193, r ), err ) ) -> Trx_runtime.Ok(((input_1193, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1185, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_equal (_filename) (_text) (input_1185)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1188, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1188)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1189, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1189, 
#78 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1189)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1185, None), err))
| Trx_runtime.Ok ( ( ( input_1190, r ), err ) ) -> Trx_runtime.Ok(((input_1190, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1186, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1186)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1187, __6 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1187, 
#79 "ocaml_parser.trx"
( Opt (__3, __4, __5)
      )), ((Trx_runtime.emptyError) (input_1187)))))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_question (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1180, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1180)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1181, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1181, 
#83 "ocaml_parser.trx"
( Opt (__2, None, None)  )), ((Trx_runtime.emptyError) (input_1181)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Default_lparen (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1173, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_mlIdent (_filename) (_text) (input_1173)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1174, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Default_colon (_filename) (_text) (input_1174)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1177, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_type (_filename) (_text) (input_1177)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1178, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1178, 
#85 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1178)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1174, None), err))
| Trx_runtime.Ok ( ( ( input_1179, r ), err ) ) -> Trx_runtime.Ok(((input_1179, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1175, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rparen (_filename) (_text) (input_1175)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1176, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1176, 
#86 "ocaml_parser.trx"
( match __3 with
      | None -> Pat (PatVar (Ident.source __2))
      | Some x -> Pat (PatAnnot (PatVar (Ident.source __2), x))
     )), ((Trx_runtime.emptyError) (input_1176)))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_pattern_aux (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1172, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1172, 
#93 "ocaml_parser.trx"
( Pat __1
     )), ((Trx_runtime.emptyError) (input_1172)))))))))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var)))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_paramFormel_err) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel4 = 
#338 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel4_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_App (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1379, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_parser_InfOpLevel4 (_filename) (_text) (input_1379)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1381, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_OpLevel4 (_filename) (_text) (input_1381)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1382, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1382, 
#338 "ocaml_parser.trx"
( __1, __2  )), ((Trx_runtime.emptyError) (input_1382)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1379, None), err))
| Trx_runtime.Ok ( ( ( input_1383, r ), err ) ) -> Trx_runtime.Ok(((input_1383, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1380, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1380, 
#338 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  )), ((Trx_runtime.emptyError) (input_1380)))))))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel4_err) (input) (res)) ; res)
)
and try_Ocaml_parser_SetRef = 
#222 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_SetRef_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_SimpleExpr (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1333, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_GETREF (_filename) (_text) (input_1333)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1334, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1334)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1335, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1335, 
#222 "ocaml_parser.trx"
( SetRef (__1, __3)  )), ((Trx_runtime.emptyError) (input_1335))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_SetRef_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Cond = 
#227 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Cond_err) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_IF (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1608, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr (_filename) (_text) (input_1608)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1609, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_THEN (_filename) (_text) (input_1609)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1610, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1610)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1611, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (match (try_Ocaml_keywords_ELSE (_filename) (_text) (input_1611)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1613, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1613)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1614, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1614, 
#227 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1614)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_1611, None), err))
| Trx_runtime.Ok ( ( ( input_1615, r ), err ) ) -> Trx_runtime.Ok(((input_1615, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1612, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1612, 
#228 "ocaml_parser.trx"
( Cond (__2, __4, match __5 with None -> Const Unit | Some s -> s)  )), ((Trx_runtime.emptyError) (input_1612))))))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Cond_err) (input) (res)) ; res)
)
and try_Ocaml_parser_Cons = 
#223 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Cons_err) (input))
) with
Not_found -> let res = (match (try_Default_lbracket (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1601, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1601)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1602, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary (false) ((fun input_1605 -> (match (try_Default_semi (_filename) (_text) (input_1605)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1606, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_Expr_without_seq (_filename) (_text) (input_1606)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1607, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1607, 
#224 "ocaml_parser.trx"
( __2 )), ((Trx_runtime.emptyError) (input_1607)))))))))))) (input_1602)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1603, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_rbracket (_filename) (_text) (input_1603)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1604, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1604, 
#225 "ocaml_parser.trx"
( List.fold_right (fun e accu -> Cons (e, accu)) (__2::__3) EmptyList )), ((Trx_runtime.emptyError) (input_1604)))))))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Cons_err) (input) (res)) ; res)
)
let try_Ocaml_keywords_TYPE_noerr = 
#48 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_TYPE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('y'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "type")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_692, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_692)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_693, __2 ) ) -> Some((input_693, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_TYPE) (input) (res)) ; res)
)
let try_Ocaml_parser_FMULT_noerr = 
#410 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FMULT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "*.")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_579, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_579)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_580, __2 ) ) -> Some((input_580, 
#410 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_FMULT) (input) (res)) ; res)
)
let try_Ocaml_keywords_WITH_noerr = 
#47 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_WITH) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('w'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('h'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "with")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_686, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_686)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_687, __2 ) ) -> Some((input_687, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_WITH) (input) (res)) ; res)
)
let try_Ocaml_parser_RNameOpt_noerr = 
#257 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_RNameOpt) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_407, __1 ) ) -> (match (try_Ocaml_keywords_WITH_noerr (_filename) (_text) (input_407)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_408, __2 ) ) -> Some((input_408, 
#257 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_RNameOpt) (input) (res)) ; res)
)
let try_Ocaml_keywords_MATCH_noerr = 
#46 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MATCH) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('h'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "match")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_720, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_720)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_721, __2 ) ) -> Some((input_721, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_MATCH) (input) (res)) ; res)
)
let try_Ocaml_parser_Const_noerr = 
#218 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Const) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_const_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_648, __1 ) ) -> Some((input_648, 
#218 "ocaml_parser.trx"
( Const __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_Const) (input) (res)) ; res)
)
let try_Ocaml_parser_IDIV_noerr = 
#406 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IDIV) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) (true)))) ) then ( Some(((((+)) (input) (1)), "/")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_569, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_569)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_570, __2 ) ) -> Some((input_570, 
#406 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_IDIV) (input) (res)) ; res)
)
let try_Ocaml_keywords_ELSE_noerr = 
#73 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_ELSE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "else")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_740, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_740)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_741, __2 ) ) -> Some((input_741, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_ELSE) (input) (res)) ; res)
)
let try_Ocaml_keywords_GETREF_noerr = 
#78 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_GETREF) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), ":=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_728, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_728)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_729, __2 ) ) -> Some((input_729, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_GETREF) (input) (res)) ; res)
)
let try_Ocaml_parser_op_and_noerr = 
#380 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_and) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('&'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('&'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "&&")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_298, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_298)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_299, __2 ) ) -> Some((input_299, 
#380 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_and) (input) (res)) ; res)
)
let try_Ocaml_parser_op_or_noerr = 
#381 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_or) (input))
) with
Not_found -> let res = (match if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'|' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('|'))) (true)))) ) then ( Some(((((+)) (input) (2)), "||")) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (2)), "or")) ) else ( None )
| _ -> None) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_282, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_282)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_283, __2 ) ) -> Some((input_283, 
#381 "ocaml_parser.trx"
( "||"  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_or) (input) (res)) ; res)
)
let try_Ocaml_parser_InfOpLevel1_noerr = 
#354 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel1) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_op_and_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_op_or_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_560, __1 ) ) -> Some((input_560, 
#355 "ocaml_parser.trx"
( Ocaml.make_Var __1
   )))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel1) (input) (res)) ; res)
)
let try_Ocaml_parser_GE_noerr = 
#396 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('>'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), ">=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_575, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_575)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_576, __2 ) ) -> Some((input_576, 
#396 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_GE) (input) (res)) ; res)
)
let try_Ocaml_parser_GT_noerr = 
#394 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('>'))) (true)))) ) then ( Some(((((+)) (input) (1)), ">")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_573, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_573)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_574, __2 ) ) -> Some((input_574, 
#394 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_GT) (input) (res)) ; res)
)
let try_Ocaml_parser_LE_noerr = 
#395 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_539, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_539)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_540, __2 ) ) -> Some((input_540, 
#395 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_LE) (input) (res)) ; res)
)
let try_Ocaml_parser_LT_noerr = 
#393 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) (true)))) ) then ( Some(((((+)) (input) (1)), "<")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_537, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_537)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_538, __2 ) ) -> Some((input_538, 
#393 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_LT) (input) (res)) ; res)
)
let try_Ocaml_parser_op_equal_noerr = 
#382 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_equal) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('='))) (true)))) ) then ( Some(((((+)) (input) (1)), "=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_292, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_292)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_293, __2 ) ) -> Some((input_293, 
#382 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_equal) (input) (res)) ; res)
)
let try_Ocaml_parser_op_equal_struct_noerr = 
#383 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_equal_struct) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('='))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "==")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_290, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_290)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_291, __2 ) ) -> Some((input_291, 
#383 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_equal_struct) (input) (res)) ; res)
)
let try_Ocaml_parser_op_notequal_noerr = 
#385 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_notequal) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('>'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<>")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_286, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_286)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_287, __2 ) ) -> Some((input_287, 
#385 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_notequal) (input) (res)) ; res)
)
let try_Ocaml_parser_op_notequal_struct_noerr = 
#384 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_notequal_struct) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('!'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input) (2)), "!=")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_284, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_284)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_285, __2 ) ) -> Some((input_285, 
#384 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_notequal_struct) (input) (res)) ; res)
)
let try_Ocaml_keywords_SPECIALS_noerr = 
#39 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_SPECIALS) (input))
) with
Not_found -> let res = if ( (((<)) ((((+)) (input) (0))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (0)))) with
'm' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))) ) then ( Some(((((+)) (input) (3)), "mod")) ) else ( None )
| 'l' -> if ( (((<)) ((((+)) (input) (1))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (1)))) with
'x' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('r'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "lxor")) ) else ( None )
| 's' -> if ( (((<)) ((((+)) (input) (2))) (_len)) ) then ( (match ((_get_char) ((((+)) (input) (2)))) with
'r' -> Some(((((+)) (input) (3)), "lsr"))
| 'l' -> Some(((((+)) (input) (3)), "lsl"))
| _ -> None) ) else ( None )
| 'o' -> if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))) ) then ( Some(((((+)) (input) (3)), "lor")) ) else ( None )
| 'a' -> if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('d'))) (true)))))) ) then ( Some(((((+)) (input) (4)), "land")) ) else ( None )
| _ -> None) ) else ( None )
| _ -> None) ) else ( None ) in
(Hashtbl.add (memo_Ocaml_keywords_SPECIALS) (input) (res)) ; res)
)
let try_Ocaml_parser_op_special_noerr = 
#391 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_special) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_SPECIALS_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_280, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_280)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_281, __2 ) ) -> Some((input_281, 
#391 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_special) (input) (res)) ; res)
)
let try_Ocaml_parser_InfOpLevel2_noerr = 
#359 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel2) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_op_equal_struct_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_equal_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_notequal_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_notequal_struct_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_LE_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_GE_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_LT_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_GT_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_551, __1 ) ) -> Some((input_551, 
#361 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )))) with
None -> (match (try_Ocaml_parser_op_special_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_550, __1 ) ) -> Some((input_550, 
#366 "ocaml_parser.trx"
( Ocaml.make_Var __1
     ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel2) (input) (res)) ; res)
)
let try_Ocaml_parser_FMINUS_noerr = 
#409 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FMINUS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "-.")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_581, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_581)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_582, __2 ) ) -> Some((input_582, 
#409 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_FMINUS) (input) (res)) ; res)
)
let try_Ocaml_parser_IMINUS_noerr = 
#404 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IMINUS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input) (1)), "-")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_567, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_567)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_568, __2 ) ) -> Some((input_568, 
#404 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_IMINUS) (input) (res)) ; res)
)
let try_Ocaml_parser_MINUS_noerr = 
#399 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MINUS) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_FMINUS_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_IMINUS_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_MINUS) (input) (res)) ; res)
)
let try_Ocaml_parser_FPLUS_noerr = 
#408 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FPLUS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('+'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "+.")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_577, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_577)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_578, __2 ) ) -> Some((input_578, 
#408 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_FPLUS) (input) (res)) ; res)
)
let try_Ocaml_parser_IPLUS_noerr = 
#403 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IPLUS) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('+'))) (true)))) ) then ( Some(((((+)) (input) (1)), "+")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_563, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_563)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_564, __2 ) ) -> Some((input_564, 
#403 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_IPLUS) (input) (res)) ; res)
)
let try_Ocaml_parser_PLUS_noerr = 
#398 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_PLUS) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_FPLUS_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_IPLUS_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_PLUS) (input) (res)) ; res)
)
let try_Ocaml_parser_op_aro_noerr = 
#388 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_aro) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('@'))) (true)))) ) then ( Some(((((+)) (input) (1)), "@")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_296, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_296)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_297, __2 ) ) -> Some((input_297, 
#388 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_aro) (input) (res)) ; res)
)
let try_Ocaml_parser_op_concat_noerr = 
#387 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_concat) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('^'))) (true)))) ) then ( Some(((((+)) (input) (1)), "^")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_294, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_294)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_295, __2 ) ) -> Some((input_295, 
#387 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_concat) (input) (res)) ; res)
)
let try_Ocaml_parser_op_logic_noerr = 
#389 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_op_logic) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "asr")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_288, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_288)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_289, __2 ) ) -> Some((input_289, 
#389 "ocaml_parser.trx"
( "asr"  ))))) in
(Hashtbl.add (memo_Ocaml_parser_op_logic) (input) (res)) ; res)
)
let try_Ocaml_parser_InfOpLevel3_noerr = 
#370 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel3) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_PLUS_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_MINUS_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_concat_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_op_aro_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_op_logic_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_544, __1 ) ) -> Some((input_544, 
#371 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel3) (input) (res)) ; res)
)
let try_Ocaml_keywords_FUN_noerr = 
#41 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_FUN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "fun")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_732, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_732)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_733, __2 ) ) -> Some((input_733, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_FUN) (input) (res)) ; res)
)
let try_Default_question_noerr = 
#76 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_question) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('?')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_852, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_852)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_853, __2 ) ) -> Some((input_853, ( () ))))) in
(Hashtbl.add (memo_Default_question) (input) (res)) ; res)
)
let try_Default_tilde__noerr = 
#83 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('~')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_764, __1 ) ) -> Some((input_764, ( () )))))
let try_Ocaml_parser_mlIdent__noerr = 
#56 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_mlIdent_) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_KEYWORDS_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_311, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_cont_noerr (_filename) (_text) (input_311)) with
None -> let input_312 = input_311 in
let __2 = () in
Some((input_312, __1))
| Some ( ( _, _ ) ) -> None)) with
None -> let input_309 = input in
let __1 = () in
(match (try_Ocaml_parser_mlIdent_aux__noerr (_filename) (_text) (input_309)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_310, __2 ) ) -> Some((input_310, 
#56 "ocaml_parser.trx"
( __2  ))))
| Some ( ( _, _ ) ) -> None) in
(Hashtbl.add (memo_Ocaml_parser_mlIdent_) (input) (res)) ; res)
)
let try_Ocaml_keywords_ASSERT_noerr = 
#65 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_ASSERT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "assert")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_752, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_752)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_753, __2 ) ) -> Some((input_753, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_ASSERT) (input) (res)) ; res)
)
let try_Ocaml_keywords_IF_noerr = 
#71 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_IF) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('f'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "if")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_726, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_726)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_727, __2 ) ) -> Some((input_727, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_IF) (input) (res)) ; res)
)
let try_Ocaml_keywords_THEN_noerr = 
#72 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_THEN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "then")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_698, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_698)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_699, __2 ) ) -> Some((input_699, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_THEN) (input) (res)) ; res)
)
let try_Ocaml_parser_emptylist_noerr = 
#37 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_emptylist) (input))
) with
Not_found -> let res = (match (try_Default_lbracket_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_326, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_326)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_327, __2 ) ) -> (match (try_Default_rbracket_noerr (_filename) (_text) (input_327)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_328, __3 ) ) -> Some((input_328, 
#37 "ocaml_parser.trx"
( EmptyList  )))))) in
(Hashtbl.add (memo_Ocaml_parser_emptylist) (input) (res)) ; res)
)
let try_Ocaml_parser_EmptyList_noerr = 
#226 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_EmptyList) (input))
) with
Not_found -> let res = (try_Ocaml_parser_emptylist_noerr (_filename) (_text) (input)) in
(Hashtbl.add (memo_Ocaml_parser_EmptyList) (input) (res)) ; res)
)
let try_Ocaml_keywords_EXCEPTION_noerr = 
#61 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_EXCEPTION) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (9))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('x'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (8))))) ('n'))) (true)))))))))))))))))))) ) then ( Some(((((+)) (input) (9)), "exception")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_736, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_736)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_737, __2 ) ) -> Some((input_737, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_EXCEPTION) (input) (res)) ; res)
)
let try_Ocaml_parser_capMlIdent_noerr = 
#117 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_capMlIdent) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_356, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_356)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_357, __2 ) ) -> Some((input_357, 
#117 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_capMlIdent) (input) (res)) ; res)
)
let try_Ocaml_parser_Exception_noerr = 
#280 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Exception) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_EXCEPTION_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_618, __1 ) ) -> (match (try_Ocaml_parser_capMlIdent_noerr (_filename) (_text) (input_618)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_619, __2 ) ) -> (match (match (match (try_Ocaml_keywords_OF_noerr (_filename) (_text) (input_619)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_621, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_621)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_622, __2 ) ) -> Some((input_622, ())))) with
None -> Some((input_619, None))
| Some ( ( input_623, r ) ) -> Some((input_623, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_620, __3 ) ) -> Some((input_620, 
#280 "ocaml_parser.trx"
( Exception (__2, None) (* FIXME *) )))))) in
(Hashtbl.add (memo_Ocaml_parser_Exception) (input) (res)) ; res)
)
let try_Default_leftarrow_noerr = 
#85 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_leftarrow) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('<'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('-'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "<-")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_890, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_890)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_891, __2 ) ) -> Some((input_891, ( () ))))) in
(Hashtbl.add (memo_Default_leftarrow) (input) (res)) ; res)
)
let try_Default_dot_noerr = 
#78 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_dot) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_920, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_920)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_921, __2 ) ) -> Some((input_921, ( () ))))) in
(Hashtbl.add (memo_Default_dot) (input) (res)) ; res)
)
let try_Ocaml_parser_Dot_noerr = 
#315 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Dot) (input))
) with
Not_found -> let res = (match (try_Default_dot_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_625, __1 ) ) -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_634 -> (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input_634)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_635, __1 ) ) -> (match if ( (((<)) (input_635) (_len)) ) then ( let c = ((_get_char) (input_635)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_635)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_636, __2 ) ) -> Some((input_636, 
#315 "ocaml_parser.trx"
( __1 ))))))) (input_625)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_633, __1 ) ) -> Some((input_633, 
#315 "ocaml_parser.trx"
( __1  )))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_626, __2 ) ) -> (match (match (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_626)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_632, __1 ) ) -> Some((input_632, 
#315 "ocaml_parser.trx"
( `MlIdent __1 )))) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input_626)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_628, __1 ) ) -> (match (try_Default_int_noerr (_filename) (_text) (input_628)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_629, __2 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_629)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_630, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_630)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_631, __4 ) ) -> Some((input_631, 
#315 "ocaml_parser.trx"
( `Int __2 )))))))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_627, __3 ) ) -> Some((input_627, 
#315 "ocaml_parser.trx"
( match __3 with `MlIdent s ->
  let tmp = String.concat_map "." (fun s -> s) __2 in
  let tmp = if tmp = "" then "" else tmp ^ "." in
  `MlIdent (tmp ^ s) | `Int i -> `Int i  )))))) in
(Hashtbl.add (memo_Ocaml_parser_Dot) (input) (res)) ; res)
)
let try_Ocaml_keywords_BEGIN_noerr = 
#58 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_BEGIN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('b'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('g'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('n'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "begin")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_750, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_750)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_751, __2 ) ) -> Some((input_751, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_BEGIN) (input) (res)) ; res)
)
let try_Ocaml_keywords_END_noerr = 
#56 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_END) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "end")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_738, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_738)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_739, __2 ) ) -> Some((input_739, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_END) (input) (res)) ; res)
)
let try_Ocaml_parser_moduleName__noerr = 
#119 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_moduleName_) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_300, __1 ) ) -> Some((input_300, 
#119 "ocaml_parser.trx"
( __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_moduleName_) (input) (res)) ; res)
)
let try_Ocaml_keywords_AND_noerr = 
#49 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_AND) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "and")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_758, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_758)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_759, __2 ) ) -> Some((input_759, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_AND) (input) (res)) ; res)
)
let try_Ocaml_keywords_IN_noerr = 
#44 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_IN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('n'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "in")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_724, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_724)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_725, __2 ) ) -> Some((input_725, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_IN) (input) (res)) ; res)
)
let try_Ocaml_keywords_LET_noerr = 
#42 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_LET) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('t'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "let")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_722, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_722)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_723, __2 ) ) -> Some((input_723, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_LET) (input) (res)) ; res)
)
let try_Ocaml_keywords_REC_noerr = 
#45 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_REC) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('c'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "rec")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_706, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_706)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_707, __2 ) ) -> Some((input_707, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_REC) (input) (res)) ; res)
)
let try_Ocaml_keywords_REF_noerr = 
#60 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_REF) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('f'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "ref")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_704, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_704)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_705, __2 ) ) -> Some((input_705, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_REF) (input) (res)) ; res)
)
let try_Default_bar_noerr = 
#80 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Default_bar) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('|')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_938, __1 ) ) -> (match (try_Default_spacing_noerr (_filename) (_text) (input_938)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_939, __2 ) ) -> Some((input_939, ( () ))))) in
(Hashtbl.add (memo_Default_bar) (input) (res)) ; res)
)
let try_Ocaml_keywords_FUNCTION_noerr = 
#52 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_FUNCTION) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (8))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('f'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('n'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (6))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (7))))) ('n'))) (true)))))))))))))))))) ) then ( Some(((((+)) (input) (8)), "function")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_730, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_730)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_731, __2 ) ) -> Some((input_731, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_FUNCTION) (input) (res)) ; res)
)
let try_Ocaml_keywords_WHEN_noerr = 
#80 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_WHEN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('w'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('h'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "when")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_688, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_688)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_689, __2 ) ) -> Some((input_689, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_WHEN) (input) (res)) ; res)
)
let try_Ocaml_keywords_MODULE_noerr = 
#54 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_MODULE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('m'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('d'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('l'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('e'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "module")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_718, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_718)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_719, __2 ) ) -> Some((input_719, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_MODULE) (input) (res)) ; res)
)
let try_Ocaml_keywords_STRUCT_noerr = 
#55 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_STRUCT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (6))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('u'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('c'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (5))))) ('t'))) (true)))))))))))))) ) then ( Some(((((+)) (input) (6)), "struct")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_700, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_700)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_701, __2 ) ) -> Some((input_701, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_STRUCT) (input) (res)) ; res)
)
let try_Ocaml_types_typedeflist_noerr = 
#56 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedeflist) (input))
) with
Not_found -> let res = (match (match (try_Default_bar_noerr (_filename) (_text) (input)) with
None -> Some((input, None))
| Some ( ( input_51, r ) ) -> Some((input_51, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_45, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_45)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_46, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_48 -> (match (try_Default_bar_noerr (_filename) (_text) (input_48)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_49, __1 ) ) -> (match (try_Ocaml_types_typedef_noerr (_filename) (_text) (input_49)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_50, __2 ) ) -> Some((input_50, 
#56 "ocaml_types.trx"
( __2  ))))))) (input_46)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_47, __3 ) ) -> Some((input_47, 
#56 "ocaml_types.trx"
( match __2, __3 with
| _, [] -> __2
| TypeConstructor l1, l2 -> 
	TypeConstructor ( l1 @ List.flatten (List.map (function | TypeConstructor l -> l | _ -> failwith "@Ocaml_types.typedeflist : must be a constructor") l2))
| _x, _xl -> failwith "@Ocaml_types.typedeflist : impossible"
 )))))) in
(Hashtbl.add (memo_Ocaml_types_typedeflist) (input) (res)) ; res)
)
let try_Ocaml_types_typevars_noerr = 
#43 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typevars) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_typevar_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_7, __1 ) ) -> Some((input_7, 
#43 "ocaml_types.trx"
( [__1]  )))) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_0, __1 ) ) -> (match (try_Ocaml_types_typevar_noerr (_filename) (_text) (input_0)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_1, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_4 -> (match (try_Default_comma_noerr (_filename) (_text) (input_4)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_5, __1 ) ) -> (match (try_Ocaml_types_typevar_noerr (_filename) (_text) (input_5)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_6, __2 ) ) -> Some((input_6, 
#44 "ocaml_types.trx"
( __2  ))))))) (input_1)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_2, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_2)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_3, __4 ) ) -> Some((input_3, 
#44 "ocaml_types.trx"
( __2 :: __3  )))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_typevars) (input) (res)) ; res)
)
let try_Ocaml_types_typedeclaration_noerr = 
#48 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typedeclaration) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_TYPE_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_72, __1 ) ) -> (match (match (try_Ocaml_types_typevars_noerr (_filename) (_text) (input_72)) with
None -> Some((input_72, None))
| Some ( ( input_85, r ) ) -> Some((input_85, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_73, __2 ) ) -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input_73)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_74, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_74)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_75, __4 ) ) -> (match (try_Ocaml_types_typedeflist_noerr (_filename) (_text) (input_75)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_76, __5 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_78 -> (match (try_Ocaml_keywords_AND_noerr (_filename) (_text) (input_78)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_79, __1 ) ) -> (match (match (try_Ocaml_types_typevars_noerr (_filename) (_text) (input_79)) with
None -> Some((input_79, None))
| Some ( ( input_84, r ) ) -> Some((input_84, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_80, __2 ) ) -> (match (try_Ocaml_types_typeIdent_noerr (_filename) (_text) (input_80)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_81, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_81)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_82, __4 ) ) -> (match (try_Ocaml_types_typedeflist_noerr (_filename) (_text) (input_82)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_83, __5 ) ) -> Some((input_83, 
#49 "ocaml_types.trx"
( compute_vars __2, __3, __5 )))))))))) (input_76)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_77, __6 ) ) -> Some((input_77, 
#50 "ocaml_types.trx"
( (compute_vars __2, __3, __5) :: __6  ))))))))) in
(Hashtbl.add (memo_Ocaml_types_typedeclaration) (input) (res)) ; res)
)
let try_Ocaml_parser_Type_noerr = 
#262 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Type) (input))
) with
Not_found -> let res = (match (try_Ocaml_types_typedeclaration_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_359, __1 ) ) -> Some((input_359, 
#262 "ocaml_parser.trx"
( Type __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_Type) (input) (res)) ; res)
)
let try_Ocaml_parser_moduleName_noerr = 
#118 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_moduleName) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_capMlIdent_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_301, __1 ) ) -> Some((input_301, 
#118 "ocaml_parser.trx"
( __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_moduleName) (input) (res)) ; res)
)
let try_Ocaml_keywords_OPEN_noerr = 
#59 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_OPEN) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (4))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('o'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('p'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('e'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('n'))) (true)))))))))) ) then ( Some(((((+)) (input) (4)), "open")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_712, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_712)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_713, __2 ) ) -> Some((input_713, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_OPEN) (input) (res)) ; res)
)
let try_Ocaml_parser_Open_noerr = 
#194 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Open) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_OPEN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_425, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_425)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_426, __2 ) ) -> Some((input_426, 
#194 "ocaml_parser.trx"
( Open [ Ident.source __2 ] ))))) in
(Hashtbl.add (memo_Ocaml_parser_Open) (input) (res)) ; res)
)
let try_Ocaml_keywords_RAISE_noerr = 
#63 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_RAISE) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (5))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('a'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('i'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (3))))) ('s'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (4))))) ('e'))) (true)))))))))))) ) then ( Some(((((+)) (input) (5)), "raise")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_708, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_708)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_709, __2 ) ) -> Some((input_709, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_RAISE) (input) (res)) ; res)
)
let try_Ocaml_keywords_TRY_noerr = 
#62 "ocaml_keywords.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_keywords_TRY) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (3))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('t'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('r'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (2))))) ('y'))) (true)))))))) ) then ( Some(((((+)) (input) (3)), "try")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_694, __1 ) ) -> (match (try_Ocaml_keywords_spacing_noerr (_filename) (_text) (input_694)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_695, __2 ) ) -> Some((input_695, ( () ))))) in
(Hashtbl.add (memo_Ocaml_keywords_TRY) (input) (res)) ; res)
)
let try_Ocaml_parser_FDIV_noerr = 
#411 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_FDIV) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('/'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (1))))) ('.'))) (true)))))) ) then ( Some(((((+)) (input) (2)), "/.")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_583, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_583)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_584, __2 ) ) -> Some((input_584, 
#411 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_FDIV) (input) (res)) ; res)
)
let try_Ocaml_parser_DIV_noerr = 
#401 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_DIV) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_FDIV_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_IDIV_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_DIV) (input) (res)) ; res)
)
let try_Ocaml_parser_IMULT_noerr = 
#405 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_IMULT) (input))
) with
Not_found -> let res = (match if ( (((&&)) ((((<=)) ((((+)) (input) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input) (0))))) ('*'))) (true)))) ) then ( Some(((((+)) (input) (1)), "*")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_565, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_565)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_566, __2 ) ) -> Some((input_566, 
#405 "ocaml_parser.trx"
( __1  ))))) in
(Hashtbl.add (memo_Ocaml_parser_IMULT) (input) (res)) ; res)
)
let try_Ocaml_parser_MULT_noerr = 
#400 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MULT) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_FMULT_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_IMULT_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_MULT) (input) (res)) ; res)
)
let try_Ocaml_parser_InfOpLevel4_noerr = 
#375 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_InfOpLevel4) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_MULT_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_DIV_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_541, __1 ) ) -> Some((input_541, 
#376 "ocaml_parser.trx"
( Ocaml.make_Var __1
     )))) in
(Hashtbl.add (memo_Ocaml_parser_InfOpLevel4) (input) (res)) ; res)
)
let rec try_Ocaml_parser_paramEffectif_noerr = 
#98 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_paramEffectif) (input))
) with
Not_found -> let res = (match (match (try_Default_tilde__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_273, __1 ) ) -> (match (try_Ocaml_parser_mlIdent__noerr (_filename) (_text) (input_273)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_274, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_274)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_277, __1 ) ) -> (match (try_Ocaml_parser_ExprNotApp_noerr (_filename) (_text) (input_277)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_278, __2 ) ) -> Some((input_278, 
#99 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_274, None))
| Some ( ( input_279, r ) ) -> Some((input_279, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_275, __3 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_275)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_276, __4 ) ) -> Some((input_276, 
#100 "ocaml_parser.trx"
( Labeled (__2, __3)
     ))))))) with
None -> (match (match (Trx_runtime.while_primary_noerr (false) ((fun input_270 -> (match (try_Ocaml_parser_moduleName__noerr (_filename) (_text) (input_270)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_271, __1 ) ) -> (match if ( (((<)) (input_271) (_len)) ) then ( let c = ((_get_char) (input_271)) in
if ( (((=)) (c) ('.')) ) then ( Some((((succ) (input_271)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_272, __2 ) ) -> Some((input_272, 
#106 "ocaml_parser.trx"
( __1 ))))))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_268, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_268)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_269, __2 ) ) -> Some((input_269, 
#107 "ocaml_parser.trx"
( Pated (List.map Ident.source (__1 @ [__2]), false)
     ))))) with
None -> (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_267, __1 ) ) -> Some((input_267, 
#112 "ocaml_parser.trx"
( Pated (List.map Ident.source __1, true)
     ))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_paramEffectif) (input) (res)) ; res)
)
and try_Ocaml_parser_dotable_noerr = 
#321 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_dotable) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Record_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Paren_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_Var_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_dotable) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel3_noerr = 
#337 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel3) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel4_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_432, __1 ) ) -> (match (match (match (try_Ocaml_parser_InfOpLevel3_noerr (_filename) (_text) (input_432)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_434, __1 ) ) -> (match (try_Ocaml_parser_OpLevel3_noerr (_filename) (_text) (input_434)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_435, __2 ) ) -> Some((input_435, 
#337 "ocaml_parser.trx"
( __1, __2  ))))) with
None -> Some((input_432, None))
| Some ( ( input_436, r ) ) -> Some((input_436, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_433, __2 ) ) -> Some((input_433, 
#337 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel3) (input) (res)) ; res)
)
and try_Ocaml_parser_LetOrType_noerr = 
#413 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_LetOrType) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_511, __1 ) ) -> (match (match (try_Ocaml_parser_Type_noerr (_filename) (_text) (input_511)) with
None -> (try_Ocaml_parser_Let_noerr (_filename) (_text) (input_511))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_512, __2 ) ) -> (match (match (match if ( (((&&)) ((((<=)) ((((+)) (input_512) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_512) (0))))) (';'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_512) (1))))) (';'))) (true)))))) ) then ( Some(((((+)) (input_512) (2)), ";;")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_514, __1 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_514)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_515, __2 ) ) -> Some((input_515, ())))) with
None -> Some((input_512, None))
| Some ( ( input_516, r ) ) -> Some((input_516, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_513, __3 ) ) -> Some((input_513, 
#413 "ocaml_parser.trx"
( __2  )))))) in
(Hashtbl.add (memo_Ocaml_parser_LetOrType) (input) (res)) ; res)
)
and try_Ocaml_parser_Letin_noerr = 
#249 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Letin) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_LET_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_493, __1 ) ) -> (match (match (try_Ocaml_keywords_REC_noerr (_filename) (_text) (input_493)) with
None -> Some((input_493, None))
| Some ( ( input_510, r ) ) -> Some((input_510, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_494, __2 ) ) -> (match (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_494)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_495, __3 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_509 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_509)))) (input_495)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_496, __4 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_496)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_497, __5 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_497)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_498, __6 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_502 -> (match (try_Ocaml_keywords_AND_noerr (_filename) (_text) (input_502)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_503, __1 ) ) -> (match (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_503)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_504, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_508 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_508)))) (input_504)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_505, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_505)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_506, __4 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_506)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_507, __5 ) ) -> Some((input_507, 
#250 "ocaml_parser.trx"
( let tmp = make_fun __5 __3 in __2, tmp  )))))))))) (input_498)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_499, __7 ) ) -> (match (try_Ocaml_keywords_IN_noerr (_filename) (_text) (input_499)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_500, __8 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_500)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_501, __9 ) ) -> Some((input_501, 
#252 "ocaml_parser.trx"
( match __2 with Some _ -> let tmp = make_fun __6 __4 in Letrecin ((__3, tmp)::__7, __9)
        | None -> let tmp = make_fun __6 __4 in Letin ((__3, tmp)::__7, __9)
         )))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Letin) (input) (res)) ; res)
)
and try_Ocaml_parser_paramFormel_noerr = 
#62 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_paramFormel) (input))
) with
Not_found -> let res = (match (match (try_Default_tilde__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_259, __1 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_259)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_260, __2 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_260)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_261, __3 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_261)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_264, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_264)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_265, __2 ) ) -> Some((input_265, 
#63 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_261, None))
| Some ( ( input_266, r ) ) -> Some((input_266, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_262, __4 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_262)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_263, __5 ) ) -> Some((input_263, 
#64 "ocaml_parser.trx"
( Label (__3, None, __4)
     )))))))) with
None -> (match (match (try_Default_tilde__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_252, __1 ) ) -> (match (try_Ocaml_parser_mlIdent__noerr (_filename) (_text) (input_252)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_253, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_253)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_256, __1 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_256)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_257, __2 ) ) -> Some((input_257, 
#68 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_253, None))
| Some ( ( input_258, r ) ) -> Some((input_258, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_254, __3 ) ) -> (match (try_Ocaml_parser_spacing_noerr (_filename) (_text) (input_254)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_255, __4 ) ) -> Some((input_255, 
#69 "ocaml_parser.trx"
( Label (__2, __3, None)
     ))))))) with
None -> (match (match (try_Default_tilde__noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_242, __1 ) ) -> (match (try_Ocaml_parser_mlIdent__noerr (_filename) (_text) (input_242)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_243, __2 ) ) -> (match (try_Default_colon_noerr (_filename) (_text) (input_243)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_244, __3 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_244)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_245, __4 ) ) -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input_245)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_246, __5 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_246)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_249, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_249)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_250, __2 ) ) -> Some((input_250, 
#73 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_246, None))
| Some ( ( input_251, r ) ) -> Some((input_251, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_247, __6 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_247)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_248, __7 ) ) -> Some((input_248, 
#74 "ocaml_parser.trx"
( Label (__2, Some __5, __6)
     )))))))))) with
None -> (match (match (try_Default_question_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_230, __1 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_230)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_231, __2 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_231)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_232, __3 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_232)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_239, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_239)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_240, __2 ) ) -> Some((input_240, 
#78 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_232, None))
| Some ( ( input_241, r ) ) -> Some((input_241, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_233, __4 ) ) -> (match (match (match (try_Default_equal_noerr (_filename) (_text) (input_233)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_236, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_236)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_237, __2 ) ) -> Some((input_237, 
#78 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_233, None))
| Some ( ( input_238, r ) ) -> Some((input_238, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_234, __5 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_234)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_235, __6 ) ) -> Some((input_235, 
#79 "ocaml_parser.trx"
( Opt (__3, __4, __5)
      ))))))))) with
None -> (match (match (try_Default_question_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_228, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_228)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_229, __2 ) ) -> Some((input_229, 
#83 "ocaml_parser.trx"
( Opt (__2, None, None)  ))))) with
None -> (match (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_221, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_221)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_222, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_222)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_225, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_225)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_226, __2 ) ) -> Some((input_226, 
#85 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_222, None))
| Some ( ( input_227, r ) ) -> Some((input_227, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_223, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_223)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_224, __4 ) ) -> Some((input_224, 
#86 "ocaml_parser.trx"
( match __3 with
      | None -> Pat (PatVar (Ident.source __2))
      | Some x -> Pat (PatAnnot (PatVar (Ident.source __2), x))
     ))))))) with
None -> (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_220, __1 ) ) -> Some((input_220, 
#93 "ocaml_parser.trx"
( Pat __1
     ))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_paramFormel) (input) (res)) ; res)
)
and try_Ocaml_parser_pattern_noerr = 
#185 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_pattern) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_212, __1 ) ) -> (match (match (match (try_Ocaml_keywords_WHEN_noerr (_filename) (_text) (input_212)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_214, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_214)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_215, __2 ) ) -> Some((input_215, 
#185 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_212, None))
| Some ( ( input_216, r ) ) -> Some((input_216, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_213, __2 ) ) -> Some((input_213, 
#186 "ocaml_parser.trx"
( match __2 with
     | None -> None, __1
     | Some x -> Some x, __1
   ))))) in
(Hashtbl.add (memo_Ocaml_parser_pattern) (input) (res)) ; res)
)
and try_Ocaml_parser_SimpleExpr_noerr = 
#325 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_SimpleExpr) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_dotable_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_374, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_380 -> (try_Ocaml_parser_Dot_noerr (_filename) (_text) (input_380)))) (input_374)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_375, __2 ) ) -> (match (match (match (try_Default_leftarrow_noerr (_filename) (_text) (input_375)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_377, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_377)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_378, __2 ) ) -> Some((input_378, 
#326 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_375, None))
| Some ( ( input_379, r ) ) -> Some((input_379, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_376, __3 ) ) -> Some((input_376, 
#326 "ocaml_parser.trx"
( let tmp = List.fold_left (fun accu -> function | `MlIdent e -> Dot (accu, e)
        | `Int i -> Dot (accu, sprintf "(%d)" i)) __1 __2 in match __3  with None -> tmp | Some s -> SetMutable (tmp, s)  )))))) with
None -> (match (match (try_Ocaml_parser_Const_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_373, __1 ) ) -> Some((input_373, 
#328 "ocaml_parser.trx"
( __1  )))) with
None -> (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_370, __1 ) ) -> (match (try_Ocaml_parser_op_special_noerr (_filename) (_text) (input_370)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_371, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_371)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_372, __3 ) ) -> Some((input_372, 
#329 "ocaml_parser.trx"
( Var (Pated ([Ident.source __2], true))  ))))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_SimpleExpr) (input) (res)) ; res)
)
and try_Ocaml_parser_Assert_noerr = 
#290 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Assert) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_ASSERT_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_664, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_664)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_665, __2 ) ) -> Some((input_665, 
#290 "ocaml_parser.trx"
( Assert __2  ))))) in
(Hashtbl.add (memo_Ocaml_parser_Assert) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_without_seq_noerr = 
#332 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_without_seq) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Expr_without_seq_aux_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_590, __1 ) ) -> Some((input_590, 
#332 "ocaml_parser.trx"
( match __1 with [t] -> t | _ -> Tuple __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_without_seq) (input) (res)) ; res)
)
and try_Ocaml_parser_Var_noerr = 
#219 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Var) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_paramEffectif_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_358, __1 ) ) -> Some((input_358, 
#219 "ocaml_parser.trx"
( Var __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_Var) (input) (res)) ; res)
)
and try_Ocaml_parser_Let_noerr = 
#233 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Let) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_keywords_LET_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_529, __1 ) ) -> (match (match (try_Ocaml_keywords_REC_noerr (_filename) (_text) (input_529)) with
None -> Some((input_529, None))
| Some ( ( input_535, r ) ) -> Some((input_535, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_530, __2 ) ) -> (match (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_530)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_531, __3 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_534 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_534)))) (input_531)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_532, __4 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_532)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_533, __5 ) ) -> Some((input_533, 
#234 "ocaml_parser.trx"
( __2, __3, __4 )))))))) with
None -> Some((input, None))
| Some ( ( input_536, r ) ) -> Some((input_536, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_519, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_519)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_520, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_522 -> (match (try_Ocaml_keywords_AND_noerr (_filename) (_text) (input_522)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_523, __1 ) ) -> (match (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_523)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_524, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_528 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_528)))) (input_524)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_525, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_525)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_526, __4 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_526)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_527, __5 ) ) -> Some((input_527, 
#236 "ocaml_parser.trx"
( let tmp = make_fun __5 __3 in __2, tmp  )))))))))) (input_520)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_521, __3 ) ) -> Some((input_521, 
#238 "ocaml_parser.trx"
( match __1 with
        | None -> __2
        | Some (_rec, name, pfs) ->
                match _rec with
                | Some _ ->
                        let tmp = make_fun __2 pfs in Letrec ((name, tmp)::__3)
                | None -> let tmp = make_fun __2 pfs in Let ((name, tmp)::__3)
         )))))) in
(Hashtbl.add (memo_Ocaml_parser_Let) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel4_noerr = 
#338 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel4) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_App_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_427, __1 ) ) -> (match (match (match (try_Ocaml_parser_InfOpLevel4_noerr (_filename) (_text) (input_427)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_429, __1 ) ) -> (match (try_Ocaml_parser_OpLevel4_noerr (_filename) (_text) (input_429)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_430, __2 ) ) -> Some((input_430, 
#338 "ocaml_parser.trx"
( __1, __2  ))))) with
None -> Some((input_427, None))
| Some ( ( input_431, r ) ) -> Some((input_431, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_428, __2 ) ) -> Some((input_428, 
#338 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel4) (input) (res)) ; res)
)
and try_Ocaml_parser_Constructor_noerr = 
#200 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Constructor) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_644, __1 ) ) -> (match (try_Default_lparen_noerr (_filename) (_text) (input_644)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_645, __2 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_645)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_646, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_646)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_647, __4 ) ) -> Some((input_647, 
#202 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, match __3 with Tuple l -> l | x -> [x])
     ))))))) with
None -> (match (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_642, __1 ) ) -> (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input_642)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_643, __2 ) ) -> Some((input_643, 
#207 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, [__2])
     ))))) with
None -> (match (try_Ocaml_parser_constructorName_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_639, __1 ) ) -> (match (match (try_Ocaml_parser_ExprNotApp_noerr (_filename) (_text) (input_639)) with
None -> Some((input_639, None))
| Some ( ( input_641, r ) ) -> Some((input_641, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_640, __2 ) ) -> Some((input_640, 
#214 "ocaml_parser.trx"
( Constructor (List.map Ident.source __1, match __2 with None -> [] | Some s -> [s])
     )))))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Constructor) (input) (res)) ; res)
)
and try_Ocaml_parser_Match_noerr = 
#263 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Match) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_keywords_MATCH_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_477, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_477)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_478, __2 ) ) -> (match (try_Ocaml_keywords_WITH_noerr (_filename) (_text) (input_478)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_479, __3 ) ) -> (match (match (try_Default_bar_noerr (_filename) (_text) (input_479)) with
None -> Some((input_479, None))
| Some ( ( input_486, r ) ) -> Some((input_486, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_480, __4 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_480)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_481, __5 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_483 -> (match (try_Default_bar_noerr (_filename) (_text) (input_483)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_484, __1 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_484)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_485, __2 ) ) -> Some((input_485, 
#264 "ocaml_parser.trx"
( __2  ))))))) (input_481)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_482, __6 ) ) -> Some((input_482, 
#265 "ocaml_parser.trx"
( Match (__2, __5 :: __6)
     ))))))))) with
None -> (match (try_Ocaml_keywords_FUNCTION_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_469, __1 ) ) -> (match (match (try_Default_bar_noerr (_filename) (_text) (input_469)) with
None -> Some((input_469, None))
| Some ( ( input_476, r ) ) -> Some((input_476, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_470, __2 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_470)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_471, __3 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_473 -> (match (try_Default_bar_noerr (_filename) (_text) (input_473)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_474, __1 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_474)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_475, __2 ) ) -> Some((input_475, 
#268 "ocaml_parser.trx"
( __2  ))))))) (input_471)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_472, __4 ) ) -> Some((input_472, 
#269 "ocaml_parser.trx"
( Function (__3::__4)
     )))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Match) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_without_seq_aux_noerr = 
#331 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr_without_seq_aux) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel1_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_585, __1 ) ) -> (match (match (match (try_Default_comma_noerr (_filename) (_text) (input_585)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_587, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_aux_noerr (_filename) (_text) (input_587)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_588, __2 ) ) -> Some((input_588, 
#331 "ocaml_parser.trx"
( __2  ))))) with
None -> Some((input_585, None))
| Some ( ( input_589, r ) ) -> Some((input_589, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_586, __2 ) ) -> Some((input_586, 
#331 "ocaml_parser.trx"
( match __2 with None -> [__1] | Some s -> __1::s  ))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr_without_seq_aux) (input) (res)) ; res)
)
and try_Ocaml_parser_App_noerr = 
#339 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_App) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Constructor_noerr (_filename) (_text) (input)) with
None -> (match (match (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_670, __1 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_670) (1))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_670) (0))))) ('-'))) (true)))) ) then ( Some(((((+)) (input_670) (1)), "-")) ) else ( None ) with
None -> let input_671 = input_670 in
let __2 = () in
(match if ( (((&&)) ((((<=)) ((((+)) (input_671) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_671) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_671) (1))))) (':'))) (true)))))) ) then ( Some(((((+)) (input_671) (2)), "::")) ) else ( None ) with
None -> let input_672 = input_671 in
let __3 = () in
(match if ( (((&&)) ((((<=)) ((((+)) (input_672) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_672) (0))))) (':'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_672) (1))))) ('='))) (true)))))) ) then ( Some(((((+)) (input_672) (2)), ":=")) ) else ( None ) with
None -> let input_673 = input_672 in
let __4 = () in
Some((input_673, __1))
| Some ( ( _, _ ) ) -> None)
| Some ( ( _, _ ) ) -> None)
| Some ( ( _, _ ) ) -> None)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_667, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_669 -> (try_Ocaml_parser_ExprNotApp_noerr (_filename) (_text) (input_669)))) (input_667)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_668, __2 ) ) -> Some((input_668, 
#344 "ocaml_parser.trx"
( match __2 with [] -> __1 | _ -> make_app (__1 :: __2)  ))))) with
None -> (try_Ocaml_parser_ExprNotApp_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_App) (input) (res)) ; res)
)
and try_Ocaml_parser_MakeRef_noerr = 
#220 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_MakeRef) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_REF_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_487, __1 ) ) -> (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input_487)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_488, __2 ) ) -> Some((input_488, 
#220 "ocaml_parser.trx"
( MakeRef __2 ))))) in
(Hashtbl.add (memo_Ocaml_parser_MakeRef) (input) (res)) ; res)
)
and try_Ocaml_parser_Cond_noerr = 
#227 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Cond) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_IF_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_656, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_656)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_657, __2 ) ) -> (match (try_Ocaml_keywords_THEN_noerr (_filename) (_text) (input_657)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_658, __3 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_658)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_659, __4 ) ) -> (match (match (match (try_Ocaml_keywords_ELSE_noerr (_filename) (_text) (input_659)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_661, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_661)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_662, __2 ) ) -> Some((input_662, 
#227 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_659, None))
| Some ( ( input_663, r ) ) -> Some((input_663, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_660, __5 ) ) -> Some((input_660, 
#228 "ocaml_parser.trx"
( Cond (__2, __4, match __5 with None -> Const Unit | Some s -> s)  )))))))) in
(Hashtbl.add (memo_Ocaml_parser_Cond) (input) (res)) ; res)
)
and try_Ocaml_parser_Abs_noerr = 
#229 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Abs) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr (true) ((fun input_677 -> (match (try_Ocaml_keywords_FUN_noerr (_filename) (_text) (input_677)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_678, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (true) ((fun input_681 -> (try_Ocaml_parser_paramFormel_noerr (_filename) (_text) (input_681)))) (input_678)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_679, __2 ) ) -> (match (try_Default_rightarrow_noerr (_filename) (_text) (input_679)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_680, __3 ) ) -> Some((input_680, 
#229 "ocaml_parser.trx"
( __2 )))))))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_675, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_675)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_676, __2 ) ) -> Some((input_676, 
#229 "ocaml_parser.trx"
( Abs (List.flatten __1, __2)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_Abs) (input) (res)) ; res)
)
and try_Ocaml_parser_Cons_noerr = 
#223 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Cons) (input))
) with
Not_found -> let res = (match (try_Default_lbracket_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_649, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_649)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_650, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_653 -> (match (try_Default_semi_noerr (_filename) (_text) (input_653)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_654, __1 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_654)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_655, __2 ) ) -> Some((input_655, 
#224 "ocaml_parser.trx"
( __2 ))))))) (input_650)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_651, __3 ) ) -> (match (try_Default_rbracket_noerr (_filename) (_text) (input_651)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_652, __4 ) ) -> Some((input_652, 
#225 "ocaml_parser.trx"
( List.fold_right (fun e accu -> Cons (e, accu)) (__2::__3) EmptyList ))))))) in
(Hashtbl.add (memo_Ocaml_parser_Cons) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel1_noerr = 
#335 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel1) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel2_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_442, __1 ) ) -> (match (match (match (try_Ocaml_parser_InfOpLevel1_noerr (_filename) (_text) (input_442)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_444, __1 ) ) -> (match (try_Ocaml_parser_OpLevel1_noerr (_filename) (_text) (input_444)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_445, __2 ) ) -> Some((input_445, 
#335 "ocaml_parser.trx"
( __1, __2  ))))) with
None -> Some((input_442, None))
| Some ( ( input_446, r ) ) -> Some((input_446, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_443, __2 ) ) -> Some((input_443, 
#335 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel1) (input) (res)) ; res)
)
and try_Ocaml_parser_Raise_noerr = 
#282 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Raise) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_RAISE_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_399, __1 ) ) -> (match (try_Ocaml_parser_capMlIdent_noerr (_filename) (_text) (input_399)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_400, __2 ) ) -> (match (match (match (try_Default_lparen_noerr (_filename) (_text) (input_400)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_402, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_402)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_403, __2 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_403)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_404, __3 ) ) -> Some((input_404, 
#282 "ocaml_parser.trx"
( __2 )))))) with
None -> Some((input_400, None))
| Some ( ( input_405, r ) ) -> Some((input_405, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_401, __3 ) ) -> Some((input_401, 
#283 "ocaml_parser.trx"
( Raise ([Ident.source __2], __3)
   )))))) in
(Hashtbl.add (memo_Ocaml_parser_Raise) (input) (res)) ; res)
)
and try_Ocaml_parser_ExprNotApp_noerr = 
#292 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_ExprNotApp) (input))
) with
Not_found -> let res = (match (match (match (try_Ocaml_parser_Open_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Module_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Cond_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Letin_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Match_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Exception_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Raise_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Try_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Assert_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_MakeRef_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_GetRef_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_SetRef_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Cons_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_EmptyList_noerr (_filename) (_text) (input)) with
None -> (match (try_Ocaml_parser_Abs_noerr (_filename) (_text) (input)) with
None -> (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input))
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var)
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_592, __1 ) ) -> (match (match (match (try_Ocaml_keywords_CONS_noerr (_filename) (_text) (input_592)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_594, __1 ) ) -> (match (try_Ocaml_parser_OpLevel1_noerr (_filename) (_text) (input_594)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_595, __2 ) ) -> Some((input_595, 
#311 "ocaml_parser.trx"
( __2 ))))) with
None -> Some((input_592, None))
| Some ( ( input_596, r ) ) -> Some((input_596, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_593, __2 ) ) -> Some((input_593, 
#311 "ocaml_parser.trx"
( match __2 with | None -> __1 | Some x -> Cons (__1, x) ))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_591, __1 ) ) -> Some((input_591, 
#312 "ocaml_parser.trx"
( __1  )))) in
(Hashtbl.add (memo_Ocaml_parser_ExprNotApp) (input) (res)) ; res)
)
and try_Ocaml_parser_Record_noerr = 
#258 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Record) (input))
) with
Not_found -> let res = (match (try_Default_laccol_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_384, __1 ) ) -> (match (match (try_Ocaml_parser_RNameOpt_noerr (_filename) (_text) (input_384)) with
None -> Some((input_384, None))
| Some ( ( input_398, r ) ) -> Some((input_398, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_385, __2 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_385)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_386, __3 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_386)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_387, __4 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_387)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_388, __5 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_393 -> (match (try_Default_semi_noerr (_filename) (_text) (input_393)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_394, __1 ) ) -> (match (try_Ocaml_parser_mlIdent_noerr (_filename) (_text) (input_394)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_395, __2 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_395)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_396, __3 ) ) -> (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input_396)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_397, __4 ) ) -> Some((input_397, 
#259 "ocaml_parser.trx"
( __2, __4 ))))))))) (input_388)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_389, __6 ) ) -> (match (match (try_Default_semi_noerr (_filename) (_text) (input_389)) with
None -> Some((input_389, None))
| Some ( ( input_392, r ) ) -> Some((input_392, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_390, __7 ) ) -> (match (try_Default_raccol_noerr (_filename) (_text) (input_390)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_391, __8 ) ) -> Some((input_391, 
#261 "ocaml_parser.trx"
( Record (__2,((__3, __5)::__6))  ))))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Record) (input) (res)) ; res)
)
and try_Ocaml_parser_Paren_noerr = 
#320 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Paren) (input))
) with
Not_found -> let res = (match (match (try_Default_lparen_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_412, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_412)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_413, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_413)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_416, __1 ) ) -> (match (try_Ocaml_parser_type_noerr (_filename) (_text) (input_416)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_417, __2 ) ) -> Some((input_417, ())))) with
None -> Some((input_413, None))
| Some ( ( input_418, r ) ) -> Some((input_418, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_414, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_414)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_415, __4 ) ) -> Some((input_415, 
#320 "ocaml_parser.trx"
( __2  ))))))) with
None -> (match (try_Ocaml_keywords_BEGIN_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_409, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_409)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_410, __2 ) ) -> (match (try_Ocaml_keywords_END_noerr (_filename) (_text) (input_410)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_411, __3 ) ) -> Some((input_411, 
#320 "ocaml_parser.trx"
( __2  ))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_Paren) (input) (res)) ; res)
)
and try_Ocaml_parser_Try_noerr = 
#287 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Try) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_TRY_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_360, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_360)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_361, __2 ) ) -> (match (try_Ocaml_keywords_WITH_noerr (_filename) (_text) (input_361)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_362, __3 ) ) -> (match (match (try_Default_bar_noerr (_filename) (_text) (input_362)) with
None -> Some((input_362, None))
| Some ( ( input_369, r ) ) -> Some((input_369, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_363, __4 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_363)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_364, __5 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_366 -> (match (try_Default_bar_noerr (_filename) (_text) (input_366)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_367, __1 ) ) -> (match (try_Ocaml_parser_matchExpr_noerr (_filename) (_text) (input_367)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_368, __2 ) ) -> Some((input_368, 
#288 "ocaml_parser.trx"
( __2  ))))))) (input_364)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_365, __6 ) ) -> Some((input_365, 
#288 "ocaml_parser.trx"
( Try (__2 , __5::__6)  ))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Try) (input) (res)) ; res)
)
and try_Ocaml_parser_OpLevel2_noerr = 
#336 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_OpLevel2) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_OpLevel3_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_437, __1 ) ) -> (match (match (match (try_Ocaml_parser_InfOpLevel2_noerr (_filename) (_text) (input_437)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_439, __1 ) ) -> (match (try_Ocaml_parser_OpLevel2_noerr (_filename) (_text) (input_439)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_440, __2 ) ) -> Some((input_440, 
#336 "ocaml_parser.trx"
( __1, __2  ))))) with
None -> Some((input_437, None))
| Some ( ( input_441, r ) ) -> Some((input_441, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_438, __2 ) ) -> Some((input_438, 
#336 "ocaml_parser.trx"
( match __2 with None -> __1 | Some (__2, __3) -> App (App (__2, __1), __3)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_OpLevel2) (input) (res)) ; res)
)
and try_Ocaml_parser_Module_noerr = 
#195 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Module) (input))
) with
Not_found -> let res = (match (try_Ocaml_keywords_MODULE_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_447, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_447)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_448, __2 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_461 -> (match (try_Default_lparen_noerr (_filename) (_text) (input_461)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_462, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_462)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_463, __2 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_463)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_466, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_466)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_467, __2 ) ) -> Some((input_467, 
#196 "ocaml_parser.trx"
( Signature (Referenced [__2])  ))))) with
None -> Some((input_463, None))
| Some ( ( input_468, r ) ) -> Some((input_468, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_464, __3 ) ) -> (match (try_Default_rparen_noerr (_filename) (_text) (input_464)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_465, __4 ) ) -> Some((input_465, 
#196 "ocaml_parser.trx"
( __2, __3 ))))))))) (input_448)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_449, __3 ) ) -> (match (match (match (try_Default_colon_noerr (_filename) (_text) (input_449)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_458, __1 ) ) -> (match (try_Ocaml_parser_moduleName_noerr (_filename) (_text) (input_458)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_459, __2 ) ) -> Some((input_459, 
#197 "ocaml_parser.trx"
( Signature (Referenced [__2])  ))))) with
None -> Some((input_449, None))
| Some ( ( input_460, r ) ) -> Some((input_460, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_450, __4 ) ) -> (match (try_Default_equal_noerr (_filename) (_text) (input_450)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_451, __5 ) ) -> (match (match (match (try_Ocaml_keywords_STRUCT_noerr (_filename) (_text) (input_451)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_454, __1 ) ) -> (match (Trx_runtime.while_primary_noerr (false) ((fun input_457 -> (try_Ocaml_parser_LetOrType_noerr (_filename) (_text) (input_457)))) (input_454)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_455, __2 ) ) -> (match (try_Ocaml_keywords_END_noerr (_filename) (_text) (input_455)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_456, __3 ) ) -> Some((input_456, 
#198 "ocaml_parser.trx"
( __2  )))))) with
None -> (match (try_Ocaml_parser_LetOrType_noerr (_filename) (_text) (input_451)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_453, __1 ) ) -> Some((input_453, 
#198 "ocaml_parser.trx"
( [__1]  ))))
| ( _ok ) as __pat_var -> __pat_var) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_452, __6 ) ) -> Some((input_452, 
#198 "ocaml_parser.trx"
( match __3 with [] -> Module (__2, __4, __6, None) | _ -> DeclareFunctor (__2, __3, __4, Structure __6)  ))))))))) in
(Hashtbl.add (memo_Ocaml_parser_Module) (input) (res)) ; res)
)
and try_Ocaml_parser_Expr_noerr = 
#333 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_Expr) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_Expr_without_seq_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_613, __1 ) ) -> (match (match (match (try_Default_semi_noerr (_filename) (_text) (input_613)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_615, __1 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_615)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_616, __2 ) ) -> Some((input_616, 
#333 "ocaml_parser.trx"
( __2  ))))) with
None -> Some((input_613, None))
| Some ( ( input_617, r ) ) -> Some((input_617, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_614, __2 ) ) -> Some((input_614, 
#333 "ocaml_parser.trx"
( match __2 with None -> __1 | Some x -> Sequence (__1, x)  ))))) in
(Hashtbl.add (memo_Ocaml_parser_Expr) (input) (res)) ; res)
)
and try_Ocaml_parser_matchExpr_noerr = 
#273 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_matchExpr) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_pattern_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_323, __1 ) ) -> (match (try_Default_rightarrow_noerr (_filename) (_text) (input_323)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_324, __2 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_324)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_325, __3 ) ) -> Some((input_325, 
#274 "ocaml_parser.trx"
( match __1 with
     | Some guard, pat -> pat, Some guard, __3
     | None, pat -> pat, None, __3
   )))))) in
(Hashtbl.add (memo_Ocaml_parser_matchExpr) (input) (res)) ; res)
)
and try_Ocaml_parser_GetRef_noerr = 
#221 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_GetRef) (input))
) with
Not_found -> let res = (match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
if ( (((=)) (c) ('!')) ) then ( Some((((succ) (input)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_571, __1 ) ) -> (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input_571)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_572, __2 ) ) -> Some((input_572, 
#221 "ocaml_parser.trx"
( GetRef __2  ))))) in
(Hashtbl.add (memo_Ocaml_parser_GetRef) (input) (res)) ; res)
)
and try_Ocaml_parser_SetRef_noerr = 
#222 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_SetRef) (input))
) with
Not_found -> let res = (match (try_Ocaml_parser_SimpleExpr_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_381, __1 ) ) -> (match (try_Ocaml_keywords_GETREF_noerr (_filename) (_text) (input_381)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_382, __2 ) ) -> (match (try_Ocaml_parser_Expr_noerr (_filename) (_text) (input_382)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_383, __3 ) ) -> Some((input_383, 
#222 "ocaml_parser.trx"
( SetRef (__1, __3)  )))))) in
(Hashtbl.add (memo_Ocaml_parser_SetRef) (input) (res)) ; res)
)
let try_Ocaml_types_lineskipper = 
#53 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_lineskipper_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1089, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_keywords_TYPE (_filename) (_text) (input_1089)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1090, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1090, ()), ((Trx_runtime.emptyError) (input_1090)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1083 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.while_primary_nores (false) ((fun input_1086 -> (match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1086) (_len)) ) then ( let c = ((_get_char) (input_1086)) in
if ( (((=)) (c) ('\n')) ) then ( Some((((succ) (input_1086)), c)) ) else ( None ) ) else ( None )) (input_1086) (((Trx_runtime.Expected(("'\n'")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1087 = input_1086 in
let __1 = () in
(Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1087) (_len)) ) then ( let c = ((_get_char) (input_1087)) in
Some((((succ) (input_1087)), c)) ) else ( None )) (input_1087) (((Trx_runtime.Expected(("any character")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1088, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1088, __2), ((Trx_runtime.emptyError) (input_1088)))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))) (input_1083)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1084, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_err (if ( (((<)) (input_1084) (_len)) ) then ( let c = ((_get_char) (input_1084)) in
if ( (((=)) (c) ('\n')) ) then ( Some((((succ) (input_1084)), c)) ) else ( None ) ) else ( None )) (input_1084) (((Trx_runtime.Expected(("'\n'")))::([])))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1085, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1085, ( () )), ((Trx_runtime.emptyError) (input_1085))))))))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))) in
(Hashtbl.add (memo_Ocaml_types_lineskipper_err) (input) (res)) ; res)
)
let try_Ocaml_types_typefinder = 
#54 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typefinder_err) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_nores (false) ((fun input_996 -> (try_Ocaml_types_lineskipper (_filename) (_text) (input_996)))) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_992, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_992)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_993, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (match (try_Ocaml_types_typedeclaration (_filename) (_text) (input_993)) with
Trx_runtime.Fail ( ( err ) ) -> Trx_runtime.Ok(((input_993, None), err))
| Trx_runtime.Ok ( ( ( input_995, r ), err ) ) -> Trx_runtime.Ok(((input_995, Some((r))), err))) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_994, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_994, 
#54 "ocaml_types.trx"
( __3  )), ((Trx_runtime.emptyError) (input_994))))))))))))) in
(Hashtbl.add (memo_Ocaml_types_typefinder_err) (input) (res)) ; res)
)
let try_Default_eof = 
#24 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match (Trx_runtime.option_to_res_err (if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
Some((((succ) (input)), c)) ) else ( None )) (input) (((Trx_runtime.Expected(("any character")))::([])))) with
Trx_runtime.Fail ( ( err ) ) -> let input_1871 = input in
let __1 = () in
(Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1871, ()), ((Trx_runtime.emptyError) (input_1871))))))
| Trx_runtime.Ok ( ( ( _, _ ), err ) ) -> let err = err in
Trx_runtime.Fail((err))))
let try_Ocaml_types_lineskipper_noerr = 
#53 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_lineskipper) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_137, __1 ) ) -> (match (try_Ocaml_keywords_TYPE_noerr (_filename) (_text) (input_137)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_138, __2 ) ) -> Some((input_138, ())))) with
None -> let input_131 = input in
let __1 = () in
(match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_134 -> (match if ( (((<)) (input_134) (_len)) ) then ( let c = ((_get_char) (input_134)) in
if ( (((=)) (c) ('\n')) ) then ( Some((((succ) (input_134)), c)) ) else ( None ) ) else ( None ) with
None -> let input_135 = input_134 in
let __1 = () in
if ( (((<)) (input_135) (_len)) ) then ( let c = ((_get_char) (input_135)) in
Some((((succ) (input_135)), c)) ) else ( None )
| Some ( ( _, _ ) ) -> None))) (input_131)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_132, __2 ) ) -> (match if ( (((<)) (input_132) (_len)) ) then ( let c = ((_get_char) (input_132)) in
if ( (((=)) (c) ('\n')) ) then ( Some((((succ) (input_132)), c)) ) else ( None ) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_133, __3 ) ) -> Some((input_133, ( () )))))
| Some ( ( _, _ ) ) -> None) in
(Hashtbl.add (memo_Ocaml_types_lineskipper) (input) (res)) ; res)
)
let try_Default_eof_noerr = 
#24 "default.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(match if ( (((<)) (input) (_len)) ) then ( let c = ((_get_char) (input)) in
Some((((succ) (input)), c)) ) else ( None ) with
None -> let input_919 = input in
let __1 = () in
Some((input_919, ()))
| Some ( ( _, _ ) ) -> None))
let rec try_Ocaml_types_test_noerr = 
#51 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_test) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_117, __1 ) ) -> (match (try_Ocaml_types_typedeclaration_noerr (_filename) (_text) (input_117)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_118, __2 ) ) -> (match if ( (((&&)) ((((<=)) ((((+)) (input_118) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_118) (0))))) (';'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_118) (1))))) (';'))) (true)))))) ) then ( Some(((((+)) (input_118) (2)), ";;")) ) else ( None ) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_119, __3 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_119)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_120, __4 ) ) -> (match (try_Ocaml_types_test_noerr (_filename) (_text) (input_120)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_121, __5 ) ) -> Some((input_121, 
#51 "ocaml_types.trx"
(  )))))))) with
None -> (match (try_Default_eof_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_116, __1 ) ) -> Some((input_116, 
#51 "ocaml_types.trx"
(  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_test) (input) (res)) ; res)
)
let rec try_Ocaml_parser_parse = 
#415 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_parse_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_LetOrType (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1170, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_parser_parse (_filename) (_text) (input_1170)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1171, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1171, 
#415 "ocaml_parser.trx"
( ((__1 :: __2) : Ocaml.code)  )), ((Trx_runtime.emptyError) (input_1171)))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_eof (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1169, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1169, 
#416 "ocaml_parser.trx"
( []  )), ((Trx_runtime.emptyError) (input_1169)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_parse_err) (input) (res)) ; res)
)
let rec try_Ocaml_parser_parse_noerr = 
#415 "ocaml_parser.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_parser_parse) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_parser_LetOrType_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_218, __1 ) ) -> (match (try_Ocaml_parser_parse_noerr (_filename) (_text) (input_218)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_219, __2 ) ) -> Some((input_219, 
#415 "ocaml_parser.trx"
( ((__1 :: __2) : Ocaml.code)  ))))) with
None -> (match (try_Default_eof_noerr (_filename) (_text) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_217, __1 ) ) -> Some((input_217, 
#416 "ocaml_parser.trx"
( []  ))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_parser_parse) (input) (res)) ; res)
)
let rec try_Ocaml_types_test = 
#51 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_test_err) (input))
) with
Not_found -> let res = (match (match (try_Ocaml_types_spacing (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1069, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_typedeclaration (_filename) (_text) (input_1069)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1070, __2 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (Trx_runtime.option_to_res_msg (if ( (((&&)) ((((<=)) ((((+)) (input_1070) (2))) (_len))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1070) (0))))) (';'))) ((((&&)) ((((=)) (((_get_char) ((((+)) (input_1070) (1))))) (';'))) (true)))))) ) then ( Some(((((+)) (input_1070) (2)), ";;")) ) else ( None )) (input_1070) ("\";;\"")) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1071, __3 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_spacing (_filename) (_text) (input_1071)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1072, __4 ), err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Ocaml_types_test (_filename) (_text) (input_1072)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1073, __5 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1073, 
#51 "ocaml_types.trx"
(  )), ((Trx_runtime.emptyError) (input_1073))))))))))))))))))) with
Trx_runtime.Fail ( ( err ) ) -> (Trx_runtime.addErrorInfo (err) ((match (try_Default_eof (_filename) (_text) (input)) with
( Trx_runtime.Fail ( ( _err ) ) ) as __pat_var -> __pat_var
| Trx_runtime.Ok ( ( ( input_1068, __1 ), err ) ) -> (Trx_runtime.addErrorInfo (err) (Trx_runtime.Ok(((input_1068, 
#51 "ocaml_types.trx"
(  )), ((Trx_runtime.emptyError) (input_1068)))))))))
| ( _ok ) as __pat_var -> __pat_var) in
(Hashtbl.add (memo_Ocaml_types_test_err) (input) (res)) ; res)
)
let try_Ocaml_types_typefinder_noerr = 
#54 "ocaml_types.trx"
(fun _filename _text input -> let _len = ((String.length) (_text))
and _get_char = ((String.unsafe_get) (_text))
and _get_sub = ((String.sub) (_text)) in
(try (
(Hashtbl.find (memo_Ocaml_types_typefinder) (input))
) with
Not_found -> let res = (match (Trx_runtime.while_primary_noerr_nores (false) ((fun input_44 -> (try_Ocaml_types_lineskipper_noerr (_filename) (_text) (input_44)))) (input)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_40, __1 ) ) -> (match (try_Ocaml_types_spacing_noerr (_filename) (_text) (input_40)) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_41, __2 ) ) -> (match (match (try_Ocaml_types_typedeclaration_noerr (_filename) (_text) (input_41)) with
None -> Some((input_41, None))
| Some ( ( input_43, r ) ) -> Some((input_43, Some((r))))) with
( None ) as __pat_var -> __pat_var
| Some ( ( input_42, __3 ) ) -> Some((input_42, 
#54 "ocaml_types.trx"
( __3  )))))) in
(Hashtbl.add (memo_Ocaml_types_typefinder) (input) (res)) ; res)
)
let parse_ocaml_types_typefinder ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Ocaml_types_typefinder_noerr) (_filename))) (((try_Ocaml_types_typefinder) (_filename))) (_text) (_start))
let parse_ocaml_types_typedeclaration ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Ocaml_types_typedeclaration_noerr) (_filename))) (((try_Ocaml_types_typedeclaration) (_filename))) (_text) (_start))
let parse_ocaml_types_test ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Ocaml_types_test_noerr) (_filename))) (((try_Ocaml_types_test) (_filename))) (_text) (_start))
let parse_ocaml_parser_parse ?(_filename = "") ?(_start = 0) _text = ((prepare_cache) (())) ; (parse_with (((try_Ocaml_parser_parse_noerr) (_filename))) (((try_Ocaml_parser_parse) (_filename))) (_text) (_start))
